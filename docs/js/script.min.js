!function (e, t) {
  "object" == typeof exports && "undefined" != typeof module ? t() : "function" == typeof define && define.amd ? define(t) : t();
}(0, function () {
  "use strict";

  function e(e) {
    var t = !0,
      n = !1,
      o = null,
      d = {
        text: !0,
        search: !0,
        url: !0,
        tel: !0,
        email: !0,
        password: !0,
        number: !0,
        date: !0,
        month: !0,
        week: !0,
        time: !0,
        datetime: !0,
        "datetime-local": !0
      };
    function i(e) {
      return !!(e && e !== document && "HTML" !== e.nodeName && "BODY" !== e.nodeName && "classList" in e && "contains" in e.classList);
    }
    function s(e) {
      e.classList.contains("focus-visible") || (e.classList.add("focus-visible"), e.setAttribute("data-focus-visible-added", ""));
    }
    function u(e) {
      t = !1;
    }
    function a() {
      document.addEventListener("mousemove", c), document.addEventListener("mousedown", c), document.addEventListener("mouseup", c), document.addEventListener("pointermove", c), document.addEventListener("pointerdown", c), document.addEventListener("pointerup", c), document.addEventListener("touchmove", c), document.addEventListener("touchstart", c), document.addEventListener("touchend", c);
    }
    function c(e) {
      e.target.nodeName && "html" === e.target.nodeName.toLowerCase() || (t = !1, document.removeEventListener("mousemove", c), document.removeEventListener("mousedown", c), document.removeEventListener("mouseup", c), document.removeEventListener("pointermove", c), document.removeEventListener("pointerdown", c), document.removeEventListener("pointerup", c), document.removeEventListener("touchmove", c), document.removeEventListener("touchstart", c), document.removeEventListener("touchend", c));
    }
    document.addEventListener("keydown", function (n) {
      n.metaKey || n.altKey || n.ctrlKey || (i(e.activeElement) && s(e.activeElement), t = !0);
    }, !0), document.addEventListener("mousedown", u, !0), document.addEventListener("pointerdown", u, !0), document.addEventListener("touchstart", u, !0), document.addEventListener("visibilitychange", function (e) {
      "hidden" === document.visibilityState && (n && (t = !0), a());
    }, !0), a(), e.addEventListener("focus", function (e) {
      var n, o, u;
      i(e.target) && (t || (n = e.target, o = n.type, "INPUT" === (u = n.tagName) && d[o] && !n.readOnly || "TEXTAREA" === u && !n.readOnly || n.isContentEditable)) && s(e.target);
    }, !0), e.addEventListener("blur", function (e) {
      var t;
      i(e.target) && (e.target.classList.contains("focus-visible") || e.target.hasAttribute("data-focus-visible-added")) && (n = !0, window.clearTimeout(o), o = window.setTimeout(function () {
        n = !1;
      }, 100), (t = e.target).hasAttribute("data-focus-visible-added") && (t.classList.remove("focus-visible"), t.removeAttribute("data-focus-visible-added")));
    }, !0), e.nodeType === Node.DOCUMENT_FRAGMENT_NODE && e.host ? e.host.setAttribute("data-js-focus-visible", "") : e.nodeType === Node.DOCUMENT_NODE && (document.documentElement.classList.add("js-focus-visible"), document.documentElement.setAttribute("data-js-focus-visible", ""));
  }
  if ("undefined" != typeof window && "undefined" != typeof document) {
    var t;
    window.applyFocusVisiblePolyfill = e;
    try {
      t = new CustomEvent("focus-visible-polyfill-ready");
    } catch (e) {
      (t = document.createEvent("CustomEvent")).initCustomEvent("focus-visible-polyfill-ready", !1, !1, {});
    }
    window.dispatchEvent(t);
  }
  "undefined" != typeof document && e(document);
});
!function (root, factory) {
  "function" == typeof define && define.amd ?
  // AMD. Register as an anonymous module unless amdModuleId is set
  define([], function () {
    return root.svg4everybody = factory();
  }) : "object" == typeof module && module.exports ?
  // Node. Does not work with strict CommonJS, but
  // only CommonJS-like environments that support module.exports,
  // like Node.
  module.exports = factory() : root.svg4everybody = factory();
}(this, function () {
  /*! svg4everybody v2.1.9 | github.com/jonathantneal/svg4everybody */
  function embed(parent, svg, target) {
    // if the target exists
    if (target) {
      // create a document fragment to hold the contents of the target
      var fragment = document.createDocumentFragment(),
        viewBox = !svg.hasAttribute("viewBox") && target.getAttribute("viewBox");
      // conditionally set the viewBox on the svg
      viewBox && svg.setAttribute("viewBox", viewBox);
      // copy the contents of the clone into the fragment
      for (
      // clone the target
      var clone = target.cloneNode(!0); clone.childNodes.length;) {
        fragment.appendChild(clone.firstChild);
      }
      // append the fragment into the svg
      parent.appendChild(fragment);
    }
  }
  function loadreadystatechange(xhr) {
    // listen to changes in the request
    xhr.onreadystatechange = function () {
      // if the request is ready
      if (4 === xhr.readyState) {
        // get the cached html document
        var cachedDocument = xhr._cachedDocument;
        // ensure the cached html document based on the xhr response
        cachedDocument || (cachedDocument = xhr._cachedDocument = document.implementation.createHTMLDocument(""), cachedDocument.body.innerHTML = xhr.responseText, xhr._cachedTarget = {}),
        // clear the xhr embeds list and embed each item
        xhr._embeds.splice(0).map(function (item) {
          // get the cached target
          var target = xhr._cachedTarget[item.id];
          // ensure the cached target
          target || (target = xhr._cachedTarget[item.id] = cachedDocument.getElementById(item.id)),
          // embed the target into the svg
          embed(item.parent, item.svg, target);
        });
      }
    },
    // test the ready state change immediately
    xhr.onreadystatechange();
  }
  function svg4everybody(rawopts) {
    function oninterval() {
      // while the index exists in the live <use> collection
      for (
      // get the cached <use> index
      var index = 0; index < uses.length;) {
        // get the current <use>
        var use = uses[index],
          parent = use.parentNode,
          svg = getSVGAncestor(parent),
          src = use.getAttribute("xlink:href") || use.getAttribute("href");
        if (!src && opts.attributeName && (src = use.getAttribute(opts.attributeName)), svg && src) {
          if (polyfill) {
            if (!opts.validate || opts.validate(src, svg, use)) {
              // remove the <use> element
              parent.removeChild(use);
              // parse the src and get the url and id
              var srcSplit = src.split("#"),
                url = srcSplit.shift(),
                id = srcSplit.join("#");
              // if the link is external
              if (url.length) {
                // get the cached xhr request
                var xhr = requests[url];
                // ensure the xhr request exists
                xhr || (xhr = requests[url] = new XMLHttpRequest(), xhr.open("GET", url), xhr.send(), xhr._embeds = []),
                // add the svg and id as an item to the xhr embeds list
                xhr._embeds.push({
                  parent: parent,
                  svg: svg,
                  id: id
                }),
                // prepare the xhr ready state change event
                loadreadystatechange(xhr);
              } else {
                // embed the local id into the svg
                embed(parent, svg, document.getElementById(id));
              }
            } else {
              // increase the index when the previous value was not "valid"
              ++index, ++numberOfSvgUseElementsToBypass;
            }
          }
        } else {
          // increase the index when the previous value was not "valid"
          ++index;
        }
      }
      // continue the interval
      (!uses.length || uses.length - numberOfSvgUseElementsToBypass > 0) && requestAnimationFrame(oninterval, 67);
    }
    var polyfill,
      opts = Object(rawopts),
      newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/,
      webkitUA = /\bAppleWebKit\/(\d+)\b/,
      olderEdgeUA = /\bEdge\/12\.(\d+)\b/,
      edgeUA = /\bEdge\/.(\d+)\b/,
      inIframe = window.top !== window.self;
    polyfill = "polyfill" in opts ? opts.polyfill : newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537 || edgeUA.test(navigator.userAgent) && inIframe;
    // create xhr requests object
    var requests = {},
      requestAnimationFrame = window.requestAnimationFrame || setTimeout,
      uses = document.getElementsByTagName("use"),
      numberOfSvgUseElementsToBypass = 0;
    // conditionally start the interval if the polyfill is active
    polyfill && oninterval();
  }
  function getSVGAncestor(node) {
    for (var svg = node; "svg" !== svg.nodeName.toLowerCase() && (svg = svg.parentNode);) {}
    return svg;
  }
  return svg4everybody;
});
/*!
  * Bootstrap v5.3.7 (https://getbootstrap.com/)
  * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = e();
}(this, function () {
  "use strict";

  const t = new Map(),
    e = {
      set(e, i, n) {
        t.has(e) || t.set(e, new Map());
        const s = t.get(e);
        s.has(i) || 0 === s.size ? s.set(i, n) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`);
      },
      get: (e, i) => t.has(e) && t.get(e).get(i) || null,
      remove(e, i) {
        if (!t.has(e)) return;
        const n = t.get(e);
        n.delete(i), 0 === n.size && t.delete(e);
      }
    },
    i = "transitionend",
    n = t => (t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, (t, e) => `#${CSS.escape(e)}`)), t),
    s = t => {
      t.dispatchEvent(new Event(i));
    },
    o = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),
    r = t => o(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(n(t)) : null,
    a = t => {
      if (!o(t) || 0 === t.getClientRects().length) return !1;
      const e = "visible" === getComputedStyle(t).getPropertyValue("visibility"),
        i = t.closest("details:not([open])");
      if (!i) return e;
      if (i !== t) {
        const e = t.closest("summary");
        if (e && e.parentNode !== i) return !1;
        if (null === e) return !1;
      }
      return e;
    },
    l = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")),
    c = t => {
      if (!document.documentElement.attachShadow) return null;
      if ("function" == typeof t.getRootNode) {
        const e = t.getRootNode();
        return e instanceof ShadowRoot ? e : null;
      }
      return t instanceof ShadowRoot ? t : t.parentNode ? c(t.parentNode) : null;
    },
    h = () => {},
    d = t => {
      t.offsetHeight;
    },
    u = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null,
    f = [],
    p = () => "rtl" === document.documentElement.dir,
    m = t => {
      var e;
      e = () => {
        const e = u();
        if (e) {
          const i = t.NAME,
            n = e.fn[i];
          e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = () => (e.fn[i] = n, t.jQueryInterface);
        }
      }, "loading" === document.readyState ? (f.length || document.addEventListener("DOMContentLoaded", () => {
        for (const t of f) t();
      }), f.push(e)) : e();
    },
    g = (t, e = [], i = t) => "function" == typeof t ? t.call(...e) : i,
    _ = (t, e, n = !0) => {
      if (!n) return void g(t);
      const o = (t => {
        if (!t) return 0;
        let {
          transitionDuration: e,
          transitionDelay: i
        } = window.getComputedStyle(t);
        const n = Number.parseFloat(e),
          s = Number.parseFloat(i);
        return n || s ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0;
      })(e) + 5;
      let r = !1;
      const a = ({
        target: n
      }) => {
        n === e && (r = !0, e.removeEventListener(i, a), g(t));
      };
      e.addEventListener(i, a), setTimeout(() => {
        r || s(e);
      }, o);
    },
    b = (t, e, i, n) => {
      const s = t.length;
      let o = t.indexOf(e);
      return -1 === o ? !i && n ? t[s - 1] : t[0] : (o += i ? 1 : -1, n && (o = (o + s) % s), t[Math.max(0, Math.min(o, s - 1))]);
    },
    v = /[^.]*(?=\..*)\.|.*/,
    y = /\..*/,
    w = /::\d+$/,
    A = {};
  let E = 1;
  const T = {
      mouseenter: "mouseover",
      mouseleave: "mouseout"
    },
    C = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
  function O(t, e) {
    return e && `${e}::${E++}` || t.uidEvent || E++;
  }
  function x(t) {
    const e = O(t);
    return t.uidEvent = e, A[e] = A[e] || {}, A[e];
  }
  function k(t, e, i = null) {
    return Object.values(t).find(t => t.callable === e && t.delegationSelector === i);
  }
  function L(t, e, i) {
    const n = "string" == typeof e,
      s = n ? i : e || i;
    let o = I(t);
    return C.has(o) || (o = t), [n, s, o];
  }
  function S(t, e, i, n, s) {
    if ("string" != typeof e || !t) return;
    let [o, r, a] = L(e, i, n);
    if (e in T) {
      const t = t => function (e) {
        if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e);
      };
      r = t(r);
    }
    const l = x(t),
      c = l[a] || (l[a] = {}),
      h = k(c, r, o ? i : null);
    if (h) return void (h.oneOff = h.oneOff && s);
    const d = O(r, e.replace(v, "")),
      u = o ? function (t, e, i) {
        return function n(s) {
          const o = t.querySelectorAll(e);
          for (let {
            target: r
          } = s; r && r !== this; r = r.parentNode) for (const a of o) if (a === r) return P(s, {
            delegateTarget: r
          }), n.oneOff && N.off(t, s.type, e, i), i.apply(r, [s]);
        };
      }(t, i, r) : function (t, e) {
        return function i(n) {
          return P(n, {
            delegateTarget: t
          }), i.oneOff && N.off(t, n.type, e), e.apply(t, [n]);
        };
      }(t, r);
    u.delegationSelector = o ? i : null, u.callable = r, u.oneOff = s, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o);
  }
  function D(t, e, i, n, s) {
    const o = k(e[i], n, s);
    o && (t.removeEventListener(i, o, Boolean(s)), delete e[i][o.uidEvent]);
  }
  function $(t, e, i, n) {
    const s = e[i] || {};
    for (const [o, r] of Object.entries(s)) o.includes(n) && D(t, e, i, r.callable, r.delegationSelector);
  }
  function I(t) {
    return t = t.replace(y, ""), T[t] || t;
  }
  const N = {
    on(t, e, i, n) {
      S(t, e, i, n, !1);
    },
    one(t, e, i, n) {
      S(t, e, i, n, !0);
    },
    off(t, e, i, n) {
      if ("string" != typeof e || !t) return;
      const [s, o, r] = L(e, i, n),
        a = r !== e,
        l = x(t),
        c = l[r] || {},
        h = e.startsWith(".");
      if (void 0 === o) {
        if (h) for (const i of Object.keys(l)) $(t, l, i, e.slice(1));
        for (const [i, n] of Object.entries(c)) {
          const s = i.replace(w, "");
          a && !e.includes(s) || D(t, l, r, n.callable, n.delegationSelector);
        }
      } else {
        if (!Object.keys(c).length) return;
        D(t, l, r, o, s ? i : null);
      }
    },
    trigger(t, e, i) {
      if ("string" != typeof e || !t) return null;
      const n = u();
      let s = null,
        o = !0,
        r = !0,
        a = !1;
      e !== I(e) && n && (s = n.Event(e, i), n(t).trigger(s), o = !s.isPropagationStopped(), r = !s.isImmediatePropagationStopped(), a = s.isDefaultPrevented());
      const l = P(new Event(e, {
        bubbles: o,
        cancelable: !0
      }), i);
      return a && l.preventDefault(), r && t.dispatchEvent(l), l.defaultPrevented && s && s.preventDefault(), l;
    }
  };
  function P(t, e = {}) {
    for (const [i, n] of Object.entries(e)) try {
      t[i] = n;
    } catch (e) {
      Object.defineProperty(t, i, {
        configurable: !0,
        get: () => n
      });
    }
    return t;
  }
  function j(t) {
    if ("true" === t) return !0;
    if ("false" === t) return !1;
    if (t === Number(t).toString()) return Number(t);
    if ("" === t || "null" === t) return null;
    if ("string" != typeof t) return t;
    try {
      return JSON.parse(decodeURIComponent(t));
    } catch (e) {
      return t;
    }
  }
  function M(t) {
    return t.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`);
  }
  const F = {
    setDataAttribute(t, e, i) {
      t.setAttribute(`data-bs-${M(e)}`, i);
    },
    removeDataAttribute(t, e) {
      t.removeAttribute(`data-bs-${M(e)}`);
    },
    getDataAttributes(t) {
      if (!t) return {};
      const e = {},
        i = Object.keys(t.dataset).filter(t => t.startsWith("bs") && !t.startsWith("bsConfig"));
      for (const n of i) {
        let i = n.replace(/^bs/, "");
        i = i.charAt(0).toLowerCase() + i.slice(1), e[i] = j(t.dataset[n]);
      }
      return e;
    },
    getDataAttribute: (t, e) => j(t.getAttribute(`data-bs-${M(e)}`))
  };
  class H {
    static get Default() {
      return {};
    }
    static get DefaultType() {
      return {};
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    _getConfig(t) {
      return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
    }
    _configAfterMerge(t) {
      return t;
    }
    _mergeConfigObj(t, e) {
      const i = o(e) ? F.getDataAttribute(e, "config") : {};
      return {
        ...this.constructor.Default,
        ...("object" == typeof i ? i : {}),
        ...(o(e) ? F.getDataAttributes(e) : {}),
        ...("object" == typeof t ? t : {})
      };
    }
    _typeCheckConfig(t, e = this.constructor.DefaultType) {
      for (const [n, s] of Object.entries(e)) {
        const e = t[n],
          r = o(e) ? "element" : null == (i = e) ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase();
        if (!new RegExp(s).test(r)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${r}" but expected type "${s}".`);
      }
      var i;
    }
  }
  class W extends H {
    constructor(t, i) {
      super(), (t = r(t)) && (this._element = t, this._config = this._getConfig(i), e.set(this._element, this.constructor.DATA_KEY, this));
    }
    dispose() {
      e.remove(this._element, this.constructor.DATA_KEY), N.off(this._element, this.constructor.EVENT_KEY);
      for (const t of Object.getOwnPropertyNames(this)) this[t] = null;
    }
    _queueCallback(t, e, i = !0) {
      _(t, e, i);
    }
    _getConfig(t) {
      return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
    }
    static getInstance(t) {
      return e.get(r(t), this.DATA_KEY);
    }
    static getOrCreateInstance(t, e = {}) {
      return this.getInstance(t) || new this(t, "object" == typeof e ? e : null);
    }
    static get VERSION() {
      return "5.3.7";
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
    static eventName(t) {
      return `${t}${this.EVENT_KEY}`;
    }
  }
  const B = t => {
      let e = t.getAttribute("data-bs-target");
      if (!e || "#" === e) {
        let i = t.getAttribute("href");
        if (!i || !i.includes("#") && !i.startsWith(".")) return null;
        i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), e = i && "#" !== i ? i.trim() : null;
      }
      return e ? e.split(",").map(t => n(t)).join(",") : null;
    },
    z = {
      find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),
      findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t),
      children: (t, e) => [].concat(...t.children).filter(t => t.matches(e)),
      parents(t, e) {
        const i = [];
        let n = t.parentNode.closest(e);
        for (; n;) i.push(n), n = n.parentNode.closest(e);
        return i;
      },
      prev(t, e) {
        let i = t.previousElementSibling;
        for (; i;) {
          if (i.matches(e)) return [i];
          i = i.previousElementSibling;
        }
        return [];
      },
      next(t, e) {
        let i = t.nextElementSibling;
        for (; i;) {
          if (i.matches(e)) return [i];
          i = i.nextElementSibling;
        }
        return [];
      },
      focusableChildren(t) {
        const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(t => `${t}:not([tabindex^="-"])`).join(",");
        return this.find(e, t).filter(t => !l(t) && a(t));
      },
      getSelectorFromElement(t) {
        const e = B(t);
        return e && z.findOne(e) ? e : null;
      },
      getElementFromSelector(t) {
        const e = B(t);
        return e ? z.findOne(e) : null;
      },
      getMultipleElementsFromSelector(t) {
        const e = B(t);
        return e ? z.find(e) : [];
      }
    },
    R = (t, e = "hide") => {
      const i = `click.dismiss${t.EVENT_KEY}`,
        n = t.NAME;
      N.on(document, i, `[data-bs-dismiss="${n}"]`, function (i) {
        if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), l(this)) return;
        const s = z.getElementFromSelector(this) || this.closest(`.${n}`);
        t.getOrCreateInstance(s)[e]();
      });
    },
    q = ".bs.alert",
    V = `close${q}`,
    K = `closed${q}`;
  class Q extends W {
    static get NAME() {
      return "alert";
    }
    close() {
      if (N.trigger(this._element, V).defaultPrevented) return;
      this._element.classList.remove("show");
      const t = this._element.classList.contains("fade");
      this._queueCallback(() => this._destroyElement(), this._element, t);
    }
    _destroyElement() {
      this._element.remove(), N.trigger(this._element, K), this.dispose();
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Q.getOrCreateInstance(this);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  R(Q, "close"), m(Q);
  const X = '[data-bs-toggle="button"]';
  class Y extends W {
    static get NAME() {
      return "button";
    }
    toggle() {
      this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Y.getOrCreateInstance(this);
        "toggle" === t && e[t]();
      });
    }
  }
  N.on(document, "click.bs.button.data-api", X, t => {
    t.preventDefault();
    const e = t.target.closest(X);
    Y.getOrCreateInstance(e).toggle();
  }), m(Y);
  const U = ".bs.swipe",
    G = `touchstart${U}`,
    J = `touchmove${U}`,
    Z = `touchend${U}`,
    tt = `pointerdown${U}`,
    et = `pointerup${U}`,
    it = {
      endCallback: null,
      leftCallback: null,
      rightCallback: null
    },
    nt = {
      endCallback: "(function|null)",
      leftCallback: "(function|null)",
      rightCallback: "(function|null)"
    };
  class st extends H {
    constructor(t, e) {
      super(), this._element = t, t && st.isSupported() && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents());
    }
    static get Default() {
      return it;
    }
    static get DefaultType() {
      return nt;
    }
    static get NAME() {
      return "swipe";
    }
    dispose() {
      N.off(this._element, U);
    }
    _start(t) {
      this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX;
    }
    _end(t) {
      this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), g(this._config.endCallback);
    }
    _move(t) {
      this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
      const t = Math.abs(this._deltaX);
      if (t <= 40) return;
      const e = t / this._deltaX;
      this._deltaX = 0, e && g(e > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
    _initEvents() {
      this._supportPointerEvents ? (N.on(this._element, tt, t => this._start(t)), N.on(this._element, et, t => this._end(t)), this._element.classList.add("pointer-event")) : (N.on(this._element, G, t => this._start(t)), N.on(this._element, J, t => this._move(t)), N.on(this._element, Z, t => this._end(t)));
    }
    _eventIsPointerPenTouch(t) {
      return this._supportPointerEvents && ("pen" === t.pointerType || "touch" === t.pointerType);
    }
    static isSupported() {
      return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
    }
  }
  const ot = ".bs.carousel",
    rt = ".data-api",
    at = "ArrowLeft",
    lt = "ArrowRight",
    ct = "next",
    ht = "prev",
    dt = "left",
    ut = "right",
    ft = `slide${ot}`,
    pt = `slid${ot}`,
    mt = `keydown${ot}`,
    gt = `mouseenter${ot}`,
    _t = `mouseleave${ot}`,
    bt = `dragstart${ot}`,
    vt = `load${ot}${rt}`,
    yt = `click${ot}${rt}`,
    wt = "carousel",
    At = "active",
    Et = ".active",
    Tt = ".carousel-item",
    Ct = Et + Tt,
    Ot = {
      [at]: ut,
      [lt]: dt
    },
    xt = {
      interval: 5e3,
      keyboard: !0,
      pause: "hover",
      ride: !1,
      touch: !0,
      wrap: !0
    },
    kt = {
      interval: "(number|boolean)",
      keyboard: "boolean",
      pause: "(string|boolean)",
      ride: "(boolean|string)",
      touch: "boolean",
      wrap: "boolean"
    };
  class Lt extends W {
    constructor(t, e) {
      super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = z.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === wt && this.cycle();
    }
    static get Default() {
      return xt;
    }
    static get DefaultType() {
      return kt;
    }
    static get NAME() {
      return "carousel";
    }
    next() {
      this._slide(ct);
    }
    nextWhenVisible() {
      !document.hidden && a(this._element) && this.next();
    }
    prev() {
      this._slide(ht);
    }
    pause() {
      this._isSliding && s(this._element), this._clearInterval();
    }
    cycle() {
      this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
    }
    _maybeEnableCycle() {
      this._config.ride && (this._isSliding ? N.one(this._element, pt, () => this.cycle()) : this.cycle());
    }
    to(t) {
      const e = this._getItems();
      if (t > e.length - 1 || t < 0) return;
      if (this._isSliding) return void N.one(this._element, pt, () => this.to(t));
      const i = this._getItemIndex(this._getActive());
      if (i === t) return;
      const n = t > i ? ct : ht;
      this._slide(n, e[t]);
    }
    dispose() {
      this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
    }
    _configAfterMerge(t) {
      return t.defaultInterval = t.interval, t;
    }
    _addEventListeners() {
      this._config.keyboard && N.on(this._element, mt, t => this._keydown(t)), "hover" === this._config.pause && (N.on(this._element, gt, () => this.pause()), N.on(this._element, _t, () => this._maybeEnableCycle())), this._config.touch && st.isSupported() && this._addTouchEventListeners();
    }
    _addTouchEventListeners() {
      for (const t of z.find(".carousel-item img", this._element)) N.on(t, bt, t => t.preventDefault());
      const t = {
        leftCallback: () => this._slide(this._directionToOrder(dt)),
        rightCallback: () => this._slide(this._directionToOrder(ut)),
        endCallback: () => {
          "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval));
        }
      };
      this._swipeHelper = new st(this._element, t);
    }
    _keydown(t) {
      if (/input|textarea/i.test(t.target.tagName)) return;
      const e = Ot[t.key];
      e && (t.preventDefault(), this._slide(this._directionToOrder(e)));
    }
    _getItemIndex(t) {
      return this._getItems().indexOf(t);
    }
    _setActiveIndicatorElement(t) {
      if (!this._indicatorsElement) return;
      const e = z.findOne(Et, this._indicatorsElement);
      e.classList.remove(At), e.removeAttribute("aria-current");
      const i = z.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement);
      i && (i.classList.add(At), i.setAttribute("aria-current", "true"));
    }
    _updateInterval() {
      const t = this._activeElement || this._getActive();
      if (!t) return;
      const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
      this._config.interval = e || this._config.defaultInterval;
    }
    _slide(t, e = null) {
      if (this._isSliding) return;
      const i = this._getActive(),
        n = t === ct,
        s = e || b(this._getItems(), i, n, this._config.wrap);
      if (s === i) return;
      const o = this._getItemIndex(s),
        r = e => N.trigger(this._element, e, {
          relatedTarget: s,
          direction: this._orderToDirection(t),
          from: this._getItemIndex(i),
          to: o
        });
      if (r(ft).defaultPrevented) return;
      if (!i || !s) return;
      const a = Boolean(this._interval);
      this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = s;
      const l = n ? "carousel-item-start" : "carousel-item-end",
        c = n ? "carousel-item-next" : "carousel-item-prev";
      s.classList.add(c), d(s), i.classList.add(l), s.classList.add(l), this._queueCallback(() => {
        s.classList.remove(l, c), s.classList.add(At), i.classList.remove(At, c, l), this._isSliding = !1, r(pt);
      }, i, this._isAnimated()), a && this.cycle();
    }
    _isAnimated() {
      return this._element.classList.contains("slide");
    }
    _getActive() {
      return z.findOne(Ct, this._element);
    }
    _getItems() {
      return z.find(Tt, this._element);
    }
    _clearInterval() {
      this._interval && (clearInterval(this._interval), this._interval = null);
    }
    _directionToOrder(t) {
      return p() ? t === dt ? ht : ct : t === dt ? ct : ht;
    }
    _orderToDirection(t) {
      return p() ? t === ht ? dt : ut : t === ht ? ut : dt;
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Lt.getOrCreateInstance(this, t);
        if ("number" != typeof t) {
          if ("string" == typeof t) {
            if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
            e[t]();
          }
        } else e.to(t);
      });
    }
  }
  N.on(document, yt, "[data-bs-slide], [data-bs-slide-to]", function (t) {
    const e = z.getElementFromSelector(this);
    if (!e || !e.classList.contains(wt)) return;
    t.preventDefault();
    const i = Lt.getOrCreateInstance(e),
      n = this.getAttribute("data-bs-slide-to");
    return n ? (i.to(n), void i._maybeEnableCycle()) : "next" === F.getDataAttribute(this, "slide") ? (i.next(), void i._maybeEnableCycle()) : (i.prev(), void i._maybeEnableCycle());
  }), N.on(window, vt, () => {
    const t = z.find('[data-bs-ride="carousel"]');
    for (const e of t) Lt.getOrCreateInstance(e);
  }), m(Lt);
  const St = ".bs.collapse",
    Dt = `show${St}`,
    $t = `shown${St}`,
    It = `hide${St}`,
    Nt = `hidden${St}`,
    Pt = `click${St}.data-api`,
    jt = "show",
    Mt = "collapse",
    Ft = "collapsing",
    Ht = `:scope .${Mt} .${Mt}`,
    Wt = '[data-bs-toggle="collapse"]',
    Bt = {
      parent: null,
      toggle: !0
    },
    zt = {
      parent: "(null|element)",
      toggle: "boolean"
    };
  class Rt extends W {
    constructor(t, e) {
      super(t, e), this._isTransitioning = !1, this._triggerArray = [];
      const i = z.find(Wt);
      for (const t of i) {
        const e = z.getSelectorFromElement(t),
          i = z.find(e).filter(t => t === this._element);
        null !== e && i.length && this._triggerArray.push(t);
      }
      this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
    }
    static get Default() {
      return Bt;
    }
    static get DefaultType() {
      return zt;
    }
    static get NAME() {
      return "collapse";
    }
    toggle() {
      this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (this._isTransitioning || this._isShown()) return;
      let t = [];
      if (this._config.parent && (t = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter(t => t !== this._element).map(t => Rt.getOrCreateInstance(t, {
        toggle: !1
      }))), t.length && t[0]._isTransitioning) return;
      if (N.trigger(this._element, Dt).defaultPrevented) return;
      for (const e of t) e.hide();
      const e = this._getDimension();
      this._element.classList.remove(Mt), this._element.classList.add(Ft), this._element.style[e] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
      const i = `scroll${e[0].toUpperCase() + e.slice(1)}`;
      this._queueCallback(() => {
        this._isTransitioning = !1, this._element.classList.remove(Ft), this._element.classList.add(Mt, jt), this._element.style[e] = "", N.trigger(this._element, $t);
      }, this._element, !0), this._element.style[e] = `${this._element[i]}px`;
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) return;
      if (N.trigger(this._element, It).defaultPrevented) return;
      const t = this._getDimension();
      this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, d(this._element), this._element.classList.add(Ft), this._element.classList.remove(Mt, jt);
      for (const t of this._triggerArray) {
        const e = z.getElementFromSelector(t);
        e && !this._isShown(e) && this._addAriaAndCollapsedClass([t], !1);
      }
      this._isTransitioning = !0, this._element.style[t] = "", this._queueCallback(() => {
        this._isTransitioning = !1, this._element.classList.remove(Ft), this._element.classList.add(Mt), N.trigger(this._element, Nt);
      }, this._element, !0);
    }
    _isShown(t = this._element) {
      return t.classList.contains(jt);
    }
    _configAfterMerge(t) {
      return t.toggle = Boolean(t.toggle), t.parent = r(t.parent), t;
    }
    _getDimension() {
      return this._element.classList.contains("collapse-horizontal") ? "width" : "height";
    }
    _initializeChildren() {
      if (!this._config.parent) return;
      const t = this._getFirstLevelChildren(Wt);
      for (const e of t) {
        const t = z.getElementFromSelector(e);
        t && this._addAriaAndCollapsedClass([e], this._isShown(t));
      }
    }
    _getFirstLevelChildren(t) {
      const e = z.find(Ht, this._config.parent);
      return z.find(t, this._config.parent).filter(t => !e.includes(t));
    }
    _addAriaAndCollapsedClass(t, e) {
      if (t.length) for (const i of t) i.classList.toggle("collapsed", !e), i.setAttribute("aria-expanded", e);
    }
    static jQueryInterface(t) {
      const e = {};
      return "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1), this.each(function () {
        const i = Rt.getOrCreateInstance(this, e);
        if ("string" == typeof t) {
          if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
          i[t]();
        }
      });
    }
  }
  N.on(document, Pt, Wt, function (t) {
    ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault();
    for (const t of z.getMultipleElementsFromSelector(this)) Rt.getOrCreateInstance(t, {
      toggle: !1
    }).toggle();
  }), m(Rt);
  var qt = "top",
    Vt = "bottom",
    Kt = "right",
    Qt = "left",
    Xt = "auto",
    Yt = [qt, Vt, Kt, Qt],
    Ut = "start",
    Gt = "end",
    Jt = "clippingParents",
    Zt = "viewport",
    te = "popper",
    ee = "reference",
    ie = Yt.reduce(function (t, e) {
      return t.concat([e + "-" + Ut, e + "-" + Gt]);
    }, []),
    ne = [].concat(Yt, [Xt]).reduce(function (t, e) {
      return t.concat([e, e + "-" + Ut, e + "-" + Gt]);
    }, []),
    se = "beforeRead",
    oe = "read",
    re = "afterRead",
    ae = "beforeMain",
    le = "main",
    ce = "afterMain",
    he = "beforeWrite",
    de = "write",
    ue = "afterWrite",
    fe = [se, oe, re, ae, le, ce, he, de, ue];
  function pe(t) {
    return t ? (t.nodeName || "").toLowerCase() : null;
  }
  function me(t) {
    if (null == t) return window;
    if ("[object Window]" !== t.toString()) {
      var e = t.ownerDocument;
      return e && e.defaultView || window;
    }
    return t;
  }
  function ge(t) {
    return t instanceof me(t).Element || t instanceof Element;
  }
  function _e(t) {
    return t instanceof me(t).HTMLElement || t instanceof HTMLElement;
  }
  function be(t) {
    return "undefined" != typeof ShadowRoot && (t instanceof me(t).ShadowRoot || t instanceof ShadowRoot);
  }
  const ve = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: function (t) {
      var e = t.state;
      Object.keys(e.elements).forEach(function (t) {
        var i = e.styles[t] || {},
          n = e.attributes[t] || {},
          s = e.elements[t];
        _e(s) && pe(s) && (Object.assign(s.style, i), Object.keys(n).forEach(function (t) {
          var e = n[t];
          !1 === e ? s.removeAttribute(t) : s.setAttribute(t, !0 === e ? "" : e);
        }));
      });
    },
    effect: function (t) {
      var e = t.state,
        i = {
          popper: {
            position: e.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
          },
          arrow: {
            position: "absolute"
          },
          reference: {}
        };
      return Object.assign(e.elements.popper.style, i.popper), e.styles = i, e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow), function () {
        Object.keys(e.elements).forEach(function (t) {
          var n = e.elements[t],
            s = e.attributes[t] || {},
            o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : i[t]).reduce(function (t, e) {
              return t[e] = "", t;
            }, {});
          _e(n) && pe(n) && (Object.assign(n.style, o), Object.keys(s).forEach(function (t) {
            n.removeAttribute(t);
          }));
        });
      };
    },
    requires: ["computeStyles"]
  };
  function ye(t) {
    return t.split("-")[0];
  }
  var we = Math.max,
    Ae = Math.min,
    Ee = Math.round;
  function Te() {
    var t = navigator.userAgentData;
    return null != t && t.brands && Array.isArray(t.brands) ? t.brands.map(function (t) {
      return t.brand + "/" + t.version;
    }).join(" ") : navigator.userAgent;
  }
  function Ce() {
    return !/^((?!chrome|android).)*safari/i.test(Te());
  }
  function Oe(t, e, i) {
    void 0 === e && (e = !1), void 0 === i && (i = !1);
    var n = t.getBoundingClientRect(),
      s = 1,
      o = 1;
    e && _e(t) && (s = t.offsetWidth > 0 && Ee(n.width) / t.offsetWidth || 1, o = t.offsetHeight > 0 && Ee(n.height) / t.offsetHeight || 1);
    var r = (ge(t) ? me(t) : window).visualViewport,
      a = !Ce() && i,
      l = (n.left + (a && r ? r.offsetLeft : 0)) / s,
      c = (n.top + (a && r ? r.offsetTop : 0)) / o,
      h = n.width / s,
      d = n.height / o;
    return {
      width: h,
      height: d,
      top: c,
      right: l + h,
      bottom: c + d,
      left: l,
      x: l,
      y: c
    };
  }
  function xe(t) {
    var e = Oe(t),
      i = t.offsetWidth,
      n = t.offsetHeight;
    return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
      x: t.offsetLeft,
      y: t.offsetTop,
      width: i,
      height: n
    };
  }
  function ke(t, e) {
    var i = e.getRootNode && e.getRootNode();
    if (t.contains(e)) return !0;
    if (i && be(i)) {
      var n = e;
      do {
        if (n && t.isSameNode(n)) return !0;
        n = n.parentNode || n.host;
      } while (n);
    }
    return !1;
  }
  function Le(t) {
    return me(t).getComputedStyle(t);
  }
  function Se(t) {
    return ["table", "td", "th"].indexOf(pe(t)) >= 0;
  }
  function De(t) {
    return ((ge(t) ? t.ownerDocument : t.document) || window.document).documentElement;
  }
  function $e(t) {
    return "html" === pe(t) ? t : t.assignedSlot || t.parentNode || (be(t) ? t.host : null) || De(t);
  }
  function Ie(t) {
    return _e(t) && "fixed" !== Le(t).position ? t.offsetParent : null;
  }
  function Ne(t) {
    for (var e = me(t), i = Ie(t); i && Se(i) && "static" === Le(i).position;) i = Ie(i);
    return i && ("html" === pe(i) || "body" === pe(i) && "static" === Le(i).position) ? e : i || function (t) {
      var e = /firefox/i.test(Te());
      if (/Trident/i.test(Te()) && _e(t) && "fixed" === Le(t).position) return null;
      var i = $e(t);
      for (be(i) && (i = i.host); _e(i) && ["html", "body"].indexOf(pe(i)) < 0;) {
        var n = Le(i);
        if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== ["transform", "perspective"].indexOf(n.willChange) || e && "filter" === n.willChange || e && n.filter && "none" !== n.filter) return i;
        i = i.parentNode;
      }
      return null;
    }(t) || e;
  }
  function Pe(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
  }
  function je(t, e, i) {
    return we(t, Ae(e, i));
  }
  function Me(t) {
    return Object.assign({}, {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, t);
  }
  function Fe(t, e) {
    return e.reduce(function (e, i) {
      return e[i] = t, e;
    }, {});
  }
  const He = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: function (t) {
      var e,
        i = t.state,
        n = t.name,
        s = t.options,
        o = i.elements.arrow,
        r = i.modifiersData.popperOffsets,
        a = ye(i.placement),
        l = Pe(a),
        c = [Qt, Kt].indexOf(a) >= 0 ? "height" : "width";
      if (o && r) {
        var h = function (t, e) {
            return Me("number" != typeof (t = "function" == typeof t ? t(Object.assign({}, e.rects, {
              placement: e.placement
            })) : t) ? t : Fe(t, Yt));
          }(s.padding, i),
          d = xe(o),
          u = "y" === l ? qt : Qt,
          f = "y" === l ? Vt : Kt,
          p = i.rects.reference[c] + i.rects.reference[l] - r[l] - i.rects.popper[c],
          m = r[l] - i.rects.reference[l],
          g = Ne(o),
          _ = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0,
          b = p / 2 - m / 2,
          v = h[u],
          y = _ - d[c] - h[f],
          w = _ / 2 - d[c] / 2 + b,
          A = je(v, w, y),
          E = l;
        i.modifiersData[n] = ((e = {})[E] = A, e.centerOffset = A - w, e);
      }
    },
    effect: function (t) {
      var e = t.state,
        i = t.options.element,
        n = void 0 === i ? "[data-popper-arrow]" : i;
      null != n && ("string" != typeof n || (n = e.elements.popper.querySelector(n))) && ke(e.elements.popper, n) && (e.elements.arrow = n);
    },
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };
  function We(t) {
    return t.split("-")[1];
  }
  var Be = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function ze(t) {
    var e,
      i = t.popper,
      n = t.popperRect,
      s = t.placement,
      o = t.variation,
      r = t.offsets,
      a = t.position,
      l = t.gpuAcceleration,
      c = t.adaptive,
      h = t.roundOffsets,
      d = t.isFixed,
      u = r.x,
      f = void 0 === u ? 0 : u,
      p = r.y,
      m = void 0 === p ? 0 : p,
      g = "function" == typeof h ? h({
        x: f,
        y: m
      }) : {
        x: f,
        y: m
      };
    f = g.x, m = g.y;
    var _ = r.hasOwnProperty("x"),
      b = r.hasOwnProperty("y"),
      v = Qt,
      y = qt,
      w = window;
    if (c) {
      var A = Ne(i),
        E = "clientHeight",
        T = "clientWidth";
      A === me(i) && "static" !== Le(A = De(i)).position && "absolute" === a && (E = "scrollHeight", T = "scrollWidth"), (s === qt || (s === Qt || s === Kt) && o === Gt) && (y = Vt, m -= (d && A === w && w.visualViewport ? w.visualViewport.height : A[E]) - n.height, m *= l ? 1 : -1), s !== Qt && (s !== qt && s !== Vt || o !== Gt) || (v = Kt, f -= (d && A === w && w.visualViewport ? w.visualViewport.width : A[T]) - n.width, f *= l ? 1 : -1);
    }
    var C,
      O = Object.assign({
        position: a
      }, c && Be),
      x = !0 === h ? function (t, e) {
        var i = t.x,
          n = t.y,
          s = e.devicePixelRatio || 1;
        return {
          x: Ee(i * s) / s || 0,
          y: Ee(n * s) / s || 0
        };
      }({
        x: f,
        y: m
      }, me(i)) : {
        x: f,
        y: m
      };
    return f = x.x, m = x.y, l ? Object.assign({}, O, ((C = {})[y] = b ? "0" : "", C[v] = _ ? "0" : "", C.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", C)) : Object.assign({}, O, ((e = {})[y] = b ? m + "px" : "", e[v] = _ ? f + "px" : "", e.transform = "", e));
  }
  const Re = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: function (t) {
      var e = t.state,
        i = t.options,
        n = i.gpuAcceleration,
        s = void 0 === n || n,
        o = i.adaptive,
        r = void 0 === o || o,
        a = i.roundOffsets,
        l = void 0 === a || a,
        c = {
          placement: ye(e.placement),
          variation: We(e.placement),
          popper: e.elements.popper,
          popperRect: e.rects.popper,
          gpuAcceleration: s,
          isFixed: "fixed" === e.options.strategy
        };
      null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, ze(Object.assign({}, c, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: r,
        roundOffsets: l
      })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, ze(Object.assign({}, c, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: l
      })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
      });
    },
    data: {}
  };
  var qe = {
    passive: !0
  };
  const Ve = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function () {},
    effect: function (t) {
      var e = t.state,
        i = t.instance,
        n = t.options,
        s = n.scroll,
        o = void 0 === s || s,
        r = n.resize,
        a = void 0 === r || r,
        l = me(e.elements.popper),
        c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
      return o && c.forEach(function (t) {
        t.addEventListener("scroll", i.update, qe);
      }), a && l.addEventListener("resize", i.update, qe), function () {
        o && c.forEach(function (t) {
          t.removeEventListener("scroll", i.update, qe);
        }), a && l.removeEventListener("resize", i.update, qe);
      };
    },
    data: {}
  };
  var Ke = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function Qe(t) {
    return t.replace(/left|right|bottom|top/g, function (t) {
      return Ke[t];
    });
  }
  var Xe = {
    start: "end",
    end: "start"
  };
  function Ye(t) {
    return t.replace(/start|end/g, function (t) {
      return Xe[t];
    });
  }
  function Ue(t) {
    var e = me(t);
    return {
      scrollLeft: e.pageXOffset,
      scrollTop: e.pageYOffset
    };
  }
  function Ge(t) {
    return Oe(De(t)).left + Ue(t).scrollLeft;
  }
  function Je(t) {
    var e = Le(t),
      i = e.overflow,
      n = e.overflowX,
      s = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(i + s + n);
  }
  function Ze(t) {
    return ["html", "body", "#document"].indexOf(pe(t)) >= 0 ? t.ownerDocument.body : _e(t) && Je(t) ? t : Ze($e(t));
  }
  function ti(t, e) {
    var i;
    void 0 === e && (e = []);
    var n = Ze(t),
      s = n === (null == (i = t.ownerDocument) ? void 0 : i.body),
      o = me(n),
      r = s ? [o].concat(o.visualViewport || [], Je(n) ? n : []) : n,
      a = e.concat(r);
    return s ? a : a.concat(ti($e(r)));
  }
  function ei(t) {
    return Object.assign({}, t, {
      left: t.x,
      top: t.y,
      right: t.x + t.width,
      bottom: t.y + t.height
    });
  }
  function ii(t, e, i) {
    return e === Zt ? ei(function (t, e) {
      var i = me(t),
        n = De(t),
        s = i.visualViewport,
        o = n.clientWidth,
        r = n.clientHeight,
        a = 0,
        l = 0;
      if (s) {
        o = s.width, r = s.height;
        var c = Ce();
        (c || !c && "fixed" === e) && (a = s.offsetLeft, l = s.offsetTop);
      }
      return {
        width: o,
        height: r,
        x: a + Ge(t),
        y: l
      };
    }(t, i)) : ge(e) ? function (t, e) {
      var i = Oe(t, !1, "fixed" === e);
      return i.top = i.top + t.clientTop, i.left = i.left + t.clientLeft, i.bottom = i.top + t.clientHeight, i.right = i.left + t.clientWidth, i.width = t.clientWidth, i.height = t.clientHeight, i.x = i.left, i.y = i.top, i;
    }(e, i) : ei(function (t) {
      var e,
        i = De(t),
        n = Ue(t),
        s = null == (e = t.ownerDocument) ? void 0 : e.body,
        o = we(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0),
        r = we(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0),
        a = -n.scrollLeft + Ge(t),
        l = -n.scrollTop;
      return "rtl" === Le(s || i).direction && (a += we(i.clientWidth, s ? s.clientWidth : 0) - o), {
        width: o,
        height: r,
        x: a,
        y: l
      };
    }(De(t)));
  }
  function ni(t) {
    var e,
      i = t.reference,
      n = t.element,
      s = t.placement,
      o = s ? ye(s) : null,
      r = s ? We(s) : null,
      a = i.x + i.width / 2 - n.width / 2,
      l = i.y + i.height / 2 - n.height / 2;
    switch (o) {
      case qt:
        e = {
          x: a,
          y: i.y - n.height
        };
        break;
      case Vt:
        e = {
          x: a,
          y: i.y + i.height
        };
        break;
      case Kt:
        e = {
          x: i.x + i.width,
          y: l
        };
        break;
      case Qt:
        e = {
          x: i.x - n.width,
          y: l
        };
        break;
      default:
        e = {
          x: i.x,
          y: i.y
        };
    }
    var c = o ? Pe(o) : null;
    if (null != c) {
      var h = "y" === c ? "height" : "width";
      switch (r) {
        case Ut:
          e[c] = e[c] - (i[h] / 2 - n[h] / 2);
          break;
        case Gt:
          e[c] = e[c] + (i[h] / 2 - n[h] / 2);
      }
    }
    return e;
  }
  function si(t, e) {
    void 0 === e && (e = {});
    var i = e,
      n = i.placement,
      s = void 0 === n ? t.placement : n,
      o = i.strategy,
      r = void 0 === o ? t.strategy : o,
      a = i.boundary,
      l = void 0 === a ? Jt : a,
      c = i.rootBoundary,
      h = void 0 === c ? Zt : c,
      d = i.elementContext,
      u = void 0 === d ? te : d,
      f = i.altBoundary,
      p = void 0 !== f && f,
      m = i.padding,
      g = void 0 === m ? 0 : m,
      _ = Me("number" != typeof g ? g : Fe(g, Yt)),
      b = u === te ? ee : te,
      v = t.rects.popper,
      y = t.elements[p ? b : u],
      w = function (t, e, i, n) {
        var s = "clippingParents" === e ? function (t) {
            var e = ti($e(t)),
              i = ["absolute", "fixed"].indexOf(Le(t).position) >= 0 && _e(t) ? Ne(t) : t;
            return ge(i) ? e.filter(function (t) {
              return ge(t) && ke(t, i) && "body" !== pe(t);
            }) : [];
          }(t) : [].concat(e),
          o = [].concat(s, [i]),
          r = o[0],
          a = o.reduce(function (e, i) {
            var s = ii(t, i, n);
            return e.top = we(s.top, e.top), e.right = Ae(s.right, e.right), e.bottom = Ae(s.bottom, e.bottom), e.left = we(s.left, e.left), e;
          }, ii(t, r, n));
        return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
      }(ge(y) ? y : y.contextElement || De(t.elements.popper), l, h, r),
      A = Oe(t.elements.reference),
      E = ni({
        reference: A,
        element: v,
        placement: s
      }),
      T = ei(Object.assign({}, v, E)),
      C = u === te ? T : A,
      O = {
        top: w.top - C.top + _.top,
        bottom: C.bottom - w.bottom + _.bottom,
        left: w.left - C.left + _.left,
        right: C.right - w.right + _.right
      },
      x = t.modifiersData.offset;
    if (u === te && x) {
      var k = x[s];
      Object.keys(O).forEach(function (t) {
        var e = [Kt, Vt].indexOf(t) >= 0 ? 1 : -1,
          i = [qt, Vt].indexOf(t) >= 0 ? "y" : "x";
        O[t] += k[i] * e;
      });
    }
    return O;
  }
  function oi(t, e) {
    void 0 === e && (e = {});
    var i = e,
      n = i.placement,
      s = i.boundary,
      o = i.rootBoundary,
      r = i.padding,
      a = i.flipVariations,
      l = i.allowedAutoPlacements,
      c = void 0 === l ? ne : l,
      h = We(n),
      d = h ? a ? ie : ie.filter(function (t) {
        return We(t) === h;
      }) : Yt,
      u = d.filter(function (t) {
        return c.indexOf(t) >= 0;
      });
    0 === u.length && (u = d);
    var f = u.reduce(function (e, i) {
      return e[i] = si(t, {
        placement: i,
        boundary: s,
        rootBoundary: o,
        padding: r
      })[ye(i)], e;
    }, {});
    return Object.keys(f).sort(function (t, e) {
      return f[t] - f[e];
    });
  }
  const ri = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: function (t) {
      var e = t.state,
        i = t.options,
        n = t.name;
      if (!e.modifiersData[n]._skip) {
        for (var s = i.mainAxis, o = void 0 === s || s, r = i.altAxis, a = void 0 === r || r, l = i.fallbackPlacements, c = i.padding, h = i.boundary, d = i.rootBoundary, u = i.altBoundary, f = i.flipVariations, p = void 0 === f || f, m = i.allowedAutoPlacements, g = e.options.placement, _ = ye(g), b = l || (_ !== g && p ? function (t) {
            if (ye(t) === Xt) return [];
            var e = Qe(t);
            return [Ye(t), e, Ye(e)];
          }(g) : [Qe(g)]), v = [g].concat(b).reduce(function (t, i) {
            return t.concat(ye(i) === Xt ? oi(e, {
              placement: i,
              boundary: h,
              rootBoundary: d,
              padding: c,
              flipVariations: p,
              allowedAutoPlacements: m
            }) : i);
          }, []), y = e.rects.reference, w = e.rects.popper, A = new Map(), E = !0, T = v[0], C = 0; C < v.length; C++) {
          var O = v[C],
            x = ye(O),
            k = We(O) === Ut,
            L = [qt, Vt].indexOf(x) >= 0,
            S = L ? "width" : "height",
            D = si(e, {
              placement: O,
              boundary: h,
              rootBoundary: d,
              altBoundary: u,
              padding: c
            }),
            $ = L ? k ? Kt : Qt : k ? Vt : qt;
          y[S] > w[S] && ($ = Qe($));
          var I = Qe($),
            N = [];
          if (o && N.push(D[x] <= 0), a && N.push(D[$] <= 0, D[I] <= 0), N.every(function (t) {
            return t;
          })) {
            T = O, E = !1;
            break;
          }
          A.set(O, N);
        }
        if (E) for (var P = function (t) {
            var e = v.find(function (e) {
              var i = A.get(e);
              if (i) return i.slice(0, t).every(function (t) {
                return t;
              });
            });
            if (e) return T = e, "break";
          }, j = p ? 3 : 1; j > 0 && "break" !== P(j); j--);
        e.placement !== T && (e.modifiersData[n]._skip = !0, e.placement = T, e.reset = !0);
      }
    },
    requiresIfExists: ["offset"],
    data: {
      _skip: !1
    }
  };
  function ai(t, e, i) {
    return void 0 === i && (i = {
      x: 0,
      y: 0
    }), {
      top: t.top - e.height - i.y,
      right: t.right - e.width + i.x,
      bottom: t.bottom - e.height + i.y,
      left: t.left - e.width - i.x
    };
  }
  function li(t) {
    return [qt, Kt, Vt, Qt].some(function (e) {
      return t[e] >= 0;
    });
  }
  const ci = {
      name: "hide",
      enabled: !0,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: function (t) {
        var e = t.state,
          i = t.name,
          n = e.rects.reference,
          s = e.rects.popper,
          o = e.modifiersData.preventOverflow,
          r = si(e, {
            elementContext: "reference"
          }),
          a = si(e, {
            altBoundary: !0
          }),
          l = ai(r, n),
          c = ai(a, s, o),
          h = li(l),
          d = li(c);
        e.modifiersData[i] = {
          referenceClippingOffsets: l,
          popperEscapeOffsets: c,
          isReferenceHidden: h,
          hasPopperEscaped: d
        }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
          "data-popper-reference-hidden": h,
          "data-popper-escaped": d
        });
      }
    },
    hi = {
      name: "offset",
      enabled: !0,
      phase: "main",
      requires: ["popperOffsets"],
      fn: function (t) {
        var e = t.state,
          i = t.options,
          n = t.name,
          s = i.offset,
          o = void 0 === s ? [0, 0] : s,
          r = ne.reduce(function (t, i) {
            return t[i] = function (t, e, i) {
              var n = ye(t),
                s = [Qt, qt].indexOf(n) >= 0 ? -1 : 1,
                o = "function" == typeof i ? i(Object.assign({}, e, {
                  placement: t
                })) : i,
                r = o[0],
                a = o[1];
              return r = r || 0, a = (a || 0) * s, [Qt, Kt].indexOf(n) >= 0 ? {
                x: a,
                y: r
              } : {
                x: r,
                y: a
              };
            }(i, e.rects, o), t;
          }, {}),
          a = r[e.placement],
          l = a.x,
          c = a.y;
        null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[n] = r;
      }
    },
    di = {
      name: "popperOffsets",
      enabled: !0,
      phase: "read",
      fn: function (t) {
        var e = t.state,
          i = t.name;
        e.modifiersData[i] = ni({
          reference: e.rects.reference,
          element: e.rects.popper,
          placement: e.placement
        });
      },
      data: {}
    },
    ui = {
      name: "preventOverflow",
      enabled: !0,
      phase: "main",
      fn: function (t) {
        var e = t.state,
          i = t.options,
          n = t.name,
          s = i.mainAxis,
          o = void 0 === s || s,
          r = i.altAxis,
          a = void 0 !== r && r,
          l = i.boundary,
          c = i.rootBoundary,
          h = i.altBoundary,
          d = i.padding,
          u = i.tether,
          f = void 0 === u || u,
          p = i.tetherOffset,
          m = void 0 === p ? 0 : p,
          g = si(e, {
            boundary: l,
            rootBoundary: c,
            padding: d,
            altBoundary: h
          }),
          _ = ye(e.placement),
          b = We(e.placement),
          v = !b,
          y = Pe(_),
          w = "x" === y ? "y" : "x",
          A = e.modifiersData.popperOffsets,
          E = e.rects.reference,
          T = e.rects.popper,
          C = "function" == typeof m ? m(Object.assign({}, e.rects, {
            placement: e.placement
          })) : m,
          O = "number" == typeof C ? {
            mainAxis: C,
            altAxis: C
          } : Object.assign({
            mainAxis: 0,
            altAxis: 0
          }, C),
          x = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
          k = {
            x: 0,
            y: 0
          };
        if (A) {
          if (o) {
            var L,
              S = "y" === y ? qt : Qt,
              D = "y" === y ? Vt : Kt,
              $ = "y" === y ? "height" : "width",
              I = A[y],
              N = I + g[S],
              P = I - g[D],
              j = f ? -T[$] / 2 : 0,
              M = b === Ut ? E[$] : T[$],
              F = b === Ut ? -T[$] : -E[$],
              H = e.elements.arrow,
              W = f && H ? xe(H) : {
                width: 0,
                height: 0
              },
              B = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
              },
              z = B[S],
              R = B[D],
              q = je(0, E[$], W[$]),
              V = v ? E[$] / 2 - j - q - z - O.mainAxis : M - q - z - O.mainAxis,
              K = v ? -E[$] / 2 + j + q + R + O.mainAxis : F + q + R + O.mainAxis,
              Q = e.elements.arrow && Ne(e.elements.arrow),
              X = Q ? "y" === y ? Q.clientTop || 0 : Q.clientLeft || 0 : 0,
              Y = null != (L = null == x ? void 0 : x[y]) ? L : 0,
              U = I + K - Y,
              G = je(f ? Ae(N, I + V - Y - X) : N, I, f ? we(P, U) : P);
            A[y] = G, k[y] = G - I;
          }
          if (a) {
            var J,
              Z = "x" === y ? qt : Qt,
              tt = "x" === y ? Vt : Kt,
              et = A[w],
              it = "y" === w ? "height" : "width",
              nt = et + g[Z],
              st = et - g[tt],
              ot = -1 !== [qt, Qt].indexOf(_),
              rt = null != (J = null == x ? void 0 : x[w]) ? J : 0,
              at = ot ? nt : et - E[it] - T[it] - rt + O.altAxis,
              lt = ot ? et + E[it] + T[it] - rt - O.altAxis : st,
              ct = f && ot ? function (t, e, i) {
                var n = je(t, e, i);
                return n > i ? i : n;
              }(at, et, lt) : je(f ? at : nt, et, f ? lt : st);
            A[w] = ct, k[w] = ct - et;
          }
          e.modifiersData[n] = k;
        }
      },
      requiresIfExists: ["offset"]
    };
  function fi(t, e, i) {
    void 0 === i && (i = !1);
    var n,
      s,
      o = _e(e),
      r = _e(e) && function (t) {
        var e = t.getBoundingClientRect(),
          i = Ee(e.width) / t.offsetWidth || 1,
          n = Ee(e.height) / t.offsetHeight || 1;
        return 1 !== i || 1 !== n;
      }(e),
      a = De(e),
      l = Oe(t, r, i),
      c = {
        scrollLeft: 0,
        scrollTop: 0
      },
      h = {
        x: 0,
        y: 0
      };
    return (o || !o && !i) && (("body" !== pe(e) || Je(a)) && (c = (n = e) !== me(n) && _e(n) ? {
      scrollLeft: (s = n).scrollLeft,
      scrollTop: s.scrollTop
    } : Ue(n)), _e(e) ? ((h = Oe(e, !0)).x += e.clientLeft, h.y += e.clientTop) : a && (h.x = Ge(a))), {
      x: l.left + c.scrollLeft - h.x,
      y: l.top + c.scrollTop - h.y,
      width: l.width,
      height: l.height
    };
  }
  function pi(t) {
    var e = new Map(),
      i = new Set(),
      n = [];
    function s(t) {
      i.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach(function (t) {
        if (!i.has(t)) {
          var n = e.get(t);
          n && s(n);
        }
      }), n.push(t);
    }
    return t.forEach(function (t) {
      e.set(t.name, t);
    }), t.forEach(function (t) {
      i.has(t.name) || s(t);
    }), n;
  }
  var mi = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function gi() {
    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
    return !e.some(function (t) {
      return !(t && "function" == typeof t.getBoundingClientRect);
    });
  }
  function _i(t) {
    void 0 === t && (t = {});
    var e = t,
      i = e.defaultModifiers,
      n = void 0 === i ? [] : i,
      s = e.defaultOptions,
      o = void 0 === s ? mi : s;
    return function (t, e, i) {
      void 0 === i && (i = o);
      var s,
        r,
        a = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, mi, o),
          modifiersData: {},
          elements: {
            reference: t,
            popper: e
          },
          attributes: {},
          styles: {}
        },
        l = [],
        c = !1,
        h = {
          state: a,
          setOptions: function (i) {
            var s = "function" == typeof i ? i(a.options) : i;
            d(), a.options = Object.assign({}, o, a.options, s), a.scrollParents = {
              reference: ge(t) ? ti(t) : t.contextElement ? ti(t.contextElement) : [],
              popper: ti(e)
            };
            var r,
              c,
              u = function (t) {
                var e = pi(t);
                return fe.reduce(function (t, i) {
                  return t.concat(e.filter(function (t) {
                    return t.phase === i;
                  }));
                }, []);
              }((r = [].concat(n, a.options.modifiers), c = r.reduce(function (t, e) {
                var i = t[e.name];
                return t[e.name] = i ? Object.assign({}, i, e, {
                  options: Object.assign({}, i.options, e.options),
                  data: Object.assign({}, i.data, e.data)
                }) : e, t;
              }, {}), Object.keys(c).map(function (t) {
                return c[t];
              })));
            return a.orderedModifiers = u.filter(function (t) {
              return t.enabled;
            }), a.orderedModifiers.forEach(function (t) {
              var e = t.name,
                i = t.options,
                n = void 0 === i ? {} : i,
                s = t.effect;
              if ("function" == typeof s) {
                var o = s({
                  state: a,
                  name: e,
                  instance: h,
                  options: n
                });
                l.push(o || function () {});
              }
            }), h.update();
          },
          forceUpdate: function () {
            if (!c) {
              var t = a.elements,
                e = t.reference,
                i = t.popper;
              if (gi(e, i)) {
                a.rects = {
                  reference: fi(e, Ne(i), "fixed" === a.options.strategy),
                  popper: xe(i)
                }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(function (t) {
                  return a.modifiersData[t.name] = Object.assign({}, t.data);
                });
                for (var n = 0; n < a.orderedModifiers.length; n++) if (!0 !== a.reset) {
                  var s = a.orderedModifiers[n],
                    o = s.fn,
                    r = s.options,
                    l = void 0 === r ? {} : r,
                    d = s.name;
                  "function" == typeof o && (a = o({
                    state: a,
                    options: l,
                    name: d,
                    instance: h
                  }) || a);
                } else a.reset = !1, n = -1;
              }
            }
          },
          update: (s = function () {
            return new Promise(function (t) {
              h.forceUpdate(), t(a);
            });
          }, function () {
            return r || (r = new Promise(function (t) {
              Promise.resolve().then(function () {
                r = void 0, t(s());
              });
            })), r;
          }),
          destroy: function () {
            d(), c = !0;
          }
        };
      if (!gi(t, e)) return h;
      function d() {
        l.forEach(function (t) {
          return t();
        }), l = [];
      }
      return h.setOptions(i).then(function (t) {
        !c && i.onFirstUpdate && i.onFirstUpdate(t);
      }), h;
    };
  }
  var bi = _i(),
    vi = _i({
      defaultModifiers: [Ve, di, Re, ve]
    }),
    yi = _i({
      defaultModifiers: [Ve, di, Re, ve, hi, ri, ui, He, ci]
    });
  const wi = Object.freeze(Object.defineProperty({
      __proto__: null,
      afterMain: ce,
      afterRead: re,
      afterWrite: ue,
      applyStyles: ve,
      arrow: He,
      auto: Xt,
      basePlacements: Yt,
      beforeMain: ae,
      beforeRead: se,
      beforeWrite: he,
      bottom: Vt,
      clippingParents: Jt,
      computeStyles: Re,
      createPopper: yi,
      createPopperBase: bi,
      createPopperLite: vi,
      detectOverflow: si,
      end: Gt,
      eventListeners: Ve,
      flip: ri,
      hide: ci,
      left: Qt,
      main: le,
      modifierPhases: fe,
      offset: hi,
      placements: ne,
      popper: te,
      popperGenerator: _i,
      popperOffsets: di,
      preventOverflow: ui,
      read: oe,
      reference: ee,
      right: Kt,
      start: Ut,
      top: qt,
      variationPlacements: ie,
      viewport: Zt,
      write: de
    }, Symbol.toStringTag, {
      value: "Module"
    })),
    Ai = "dropdown",
    Ei = ".bs.dropdown",
    Ti = ".data-api",
    Ci = "ArrowUp",
    Oi = "ArrowDown",
    xi = `hide${Ei}`,
    ki = `hidden${Ei}`,
    Li = `show${Ei}`,
    Si = `shown${Ei}`,
    Di = `click${Ei}${Ti}`,
    $i = `keydown${Ei}${Ti}`,
    Ii = `keyup${Ei}${Ti}`,
    Ni = "show",
    Pi = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',
    ji = `${Pi}.${Ni}`,
    Mi = ".dropdown-menu",
    Fi = p() ? "top-end" : "top-start",
    Hi = p() ? "top-start" : "top-end",
    Wi = p() ? "bottom-end" : "bottom-start",
    Bi = p() ? "bottom-start" : "bottom-end",
    zi = p() ? "left-start" : "right-start",
    Ri = p() ? "right-start" : "left-start",
    qi = {
      autoClose: !0,
      boundary: "clippingParents",
      display: "dynamic",
      offset: [0, 2],
      popperConfig: null,
      reference: "toggle"
    },
    Vi = {
      autoClose: "(boolean|string)",
      boundary: "(string|element)",
      display: "string",
      offset: "(array|string|function)",
      popperConfig: "(null|object|function)",
      reference: "(string|element|object)"
    };
  class Ki extends W {
    constructor(t, e) {
      super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = z.next(this._element, Mi)[0] || z.prev(this._element, Mi)[0] || z.findOne(Mi, this._parent), this._inNavbar = this._detectNavbar();
    }
    static get Default() {
      return qi;
    }
    static get DefaultType() {
      return Vi;
    }
    static get NAME() {
      return Ai;
    }
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (l(this._element) || this._isShown()) return;
      const t = {
        relatedTarget: this._element
      };
      if (!N.trigger(this._element, Li, t).defaultPrevented) {
        if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (const t of [].concat(...document.body.children)) N.on(t, "mouseover", h);
        this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Ni), this._element.classList.add(Ni), N.trigger(this._element, Si, t);
      }
    }
    hide() {
      if (l(this._element) || !this._isShown()) return;
      const t = {
        relatedTarget: this._element
      };
      this._completeHide(t);
    }
    dispose() {
      this._popper && this._popper.destroy(), super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
    }
    _completeHide(t) {
      if (!N.trigger(this._element, xi, t).defaultPrevented) {
        if ("ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) N.off(t, "mouseover", h);
        this._popper && this._popper.destroy(), this._menu.classList.remove(Ni), this._element.classList.remove(Ni), this._element.setAttribute("aria-expanded", "false"), F.removeDataAttribute(this._menu, "popper"), N.trigger(this._element, ki, t), this._element.focus();
      }
    }
    _getConfig(t) {
      if ("object" == typeof (t = super._getConfig(t)).reference && !o(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError(`${Ai.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      return t;
    }
    _createPopper() {
      if (void 0 === wi) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org/docs/v2/)");
      let t = this._element;
      "parent" === this._config.reference ? t = this._parent : o(this._config.reference) ? t = r(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference);
      const e = this._getPopperConfig();
      this._popper = yi(t, this._menu, e);
    }
    _isShown() {
      return this._menu.classList.contains(Ni);
    }
    _getPlacement() {
      const t = this._parent;
      if (t.classList.contains("dropend")) return zi;
      if (t.classList.contains("dropstart")) return Ri;
      if (t.classList.contains("dropup-center")) return "top";
      if (t.classList.contains("dropdown-center")) return "bottom";
      const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
      return t.classList.contains("dropup") ? e ? Hi : Fi : e ? Bi : Wi;
    }
    _detectNavbar() {
      return null !== this._element.closest(".navbar");
    }
    _getOffset() {
      const {
        offset: t
      } = this._config;
      return "string" == typeof t ? t.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof t ? e => t(e, this._element) : t;
    }
    _getPopperConfig() {
      const t = {
        placement: this._getPlacement(),
        modifiers: [{
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }]
      };
      return (this._inNavbar || "static" === this._config.display) && (F.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [{
        name: "applyStyles",
        enabled: !1
      }]), {
        ...t,
        ...g(this._config.popperConfig, [void 0, t])
      };
    }
    _selectMenuItem({
      key: t,
      target: e
    }) {
      const i = z.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(t => a(t));
      i.length && b(i, e, t === Oi, !i.includes(e)).focus();
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Ki.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
    static clearMenus(t) {
      if (2 === t.button || "keyup" === t.type && "Tab" !== t.key) return;
      const e = z.find(ji);
      for (const i of e) {
        const e = Ki.getInstance(i);
        if (!e || !1 === e._config.autoClose) continue;
        const n = t.composedPath(),
          s = n.includes(e._menu);
        if (n.includes(e._element) || "inside" === e._config.autoClose && !s || "outside" === e._config.autoClose && s) continue;
        if (e._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName))) continue;
        const o = {
          relatedTarget: e._element
        };
        "click" === t.type && (o.clickEvent = t), e._completeHide(o);
      }
    }
    static dataApiKeydownHandler(t) {
      const e = /input|textarea/i.test(t.target.tagName),
        i = "Escape" === t.key,
        n = [Ci, Oi].includes(t.key);
      if (!n && !i) return;
      if (e && !i) return;
      t.preventDefault();
      const s = this.matches(Pi) ? this : z.prev(this, Pi)[0] || z.next(this, Pi)[0] || z.findOne(Pi, t.delegateTarget.parentNode),
        o = Ki.getOrCreateInstance(s);
      if (n) return t.stopPropagation(), o.show(), void o._selectMenuItem(t);
      o._isShown() && (t.stopPropagation(), o.hide(), s.focus());
    }
  }
  N.on(document, $i, Pi, Ki.dataApiKeydownHandler), N.on(document, $i, Mi, Ki.dataApiKeydownHandler), N.on(document, Di, Ki.clearMenus), N.on(document, Ii, Ki.clearMenus), N.on(document, Di, Pi, function (t) {
    t.preventDefault(), Ki.getOrCreateInstance(this).toggle();
  }), m(Ki);
  const Qi = "backdrop",
    Xi = "show",
    Yi = `mousedown.bs.${Qi}`,
    Ui = {
      className: "modal-backdrop",
      clickCallback: null,
      isAnimated: !1,
      isVisible: !0,
      rootElement: "body"
    },
    Gi = {
      className: "string",
      clickCallback: "(function|null)",
      isAnimated: "boolean",
      isVisible: "boolean",
      rootElement: "(element|string)"
    };
  class Ji extends H {
    constructor(t) {
      super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null;
    }
    static get Default() {
      return Ui;
    }
    static get DefaultType() {
      return Gi;
    }
    static get NAME() {
      return Qi;
    }
    show(t) {
      if (!this._config.isVisible) return void g(t);
      this._append();
      const e = this._getElement();
      this._config.isAnimated && d(e), e.classList.add(Xi), this._emulateAnimation(() => {
        g(t);
      });
    }
    hide(t) {
      this._config.isVisible ? (this._getElement().classList.remove(Xi), this._emulateAnimation(() => {
        this.dispose(), g(t);
      })) : g(t);
    }
    dispose() {
      this._isAppended && (N.off(this._element, Yi), this._element.remove(), this._isAppended = !1);
    }
    _getElement() {
      if (!this._element) {
        const t = document.createElement("div");
        t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t;
      }
      return this._element;
    }
    _configAfterMerge(t) {
      return t.rootElement = r(t.rootElement), t;
    }
    _append() {
      if (this._isAppended) return;
      const t = this._getElement();
      this._config.rootElement.append(t), N.on(t, Yi, () => {
        g(this._config.clickCallback);
      }), this._isAppended = !0;
    }
    _emulateAnimation(t) {
      _(t, this._getElement(), this._config.isAnimated);
    }
  }
  const Zi = ".bs.focustrap",
    tn = `focusin${Zi}`,
    en = `keydown.tab${Zi}`,
    nn = "backward",
    sn = {
      autofocus: !0,
      trapElement: null
    },
    on = {
      autofocus: "boolean",
      trapElement: "element"
    };
  class rn extends H {
    constructor(t) {
      super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null;
    }
    static get Default() {
      return sn;
    }
    static get DefaultType() {
      return on;
    }
    static get NAME() {
      return "focustrap";
    }
    activate() {
      this._isActive || (this._config.autofocus && this._config.trapElement.focus(), N.off(document, Zi), N.on(document, tn, t => this._handleFocusin(t)), N.on(document, en, t => this._handleKeydown(t)), this._isActive = !0);
    }
    deactivate() {
      this._isActive && (this._isActive = !1, N.off(document, Zi));
    }
    _handleFocusin(t) {
      const {
        trapElement: e
      } = this._config;
      if (t.target === document || t.target === e || e.contains(t.target)) return;
      const i = z.focusableChildren(e);
      0 === i.length ? e.focus() : this._lastTabNavDirection === nn ? i[i.length - 1].focus() : i[0].focus();
    }
    _handleKeydown(t) {
      "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? nn : "forward");
    }
  }
  const an = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
    ln = ".sticky-top",
    cn = "padding-right",
    hn = "margin-right";
  class dn {
    constructor() {
      this._element = document.body;
    }
    getWidth() {
      const t = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - t);
    }
    hide() {
      const t = this.getWidth();
      this._disableOverFlow(), this._setElementAttributes(this._element, cn, e => e + t), this._setElementAttributes(an, cn, e => e + t), this._setElementAttributes(ln, hn, e => e - t);
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, cn), this._resetElementAttributes(an, cn), this._resetElementAttributes(ln, hn);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
    }
    _setElementAttributes(t, e, i) {
      const n = this.getWidth();
      this._applyManipulationCallback(t, t => {
        if (t !== this._element && window.innerWidth > t.clientWidth + n) return;
        this._saveInitialAttribute(t, e);
        const s = window.getComputedStyle(t).getPropertyValue(e);
        t.style.setProperty(e, `${i(Number.parseFloat(s))}px`);
      });
    }
    _saveInitialAttribute(t, e) {
      const i = t.style.getPropertyValue(e);
      i && F.setDataAttribute(t, e, i);
    }
    _resetElementAttributes(t, e) {
      this._applyManipulationCallback(t, t => {
        const i = F.getDataAttribute(t, e);
        null !== i ? (F.removeDataAttribute(t, e), t.style.setProperty(e, i)) : t.style.removeProperty(e);
      });
    }
    _applyManipulationCallback(t, e) {
      if (o(t)) e(t);else for (const i of z.find(t, this._element)) e(i);
    }
  }
  const un = ".bs.modal",
    fn = `hide${un}`,
    pn = `hidePrevented${un}`,
    mn = `hidden${un}`,
    gn = `show${un}`,
    _n = `shown${un}`,
    bn = `resize${un}`,
    vn = `click.dismiss${un}`,
    yn = `mousedown.dismiss${un}`,
    wn = `keydown.dismiss${un}`,
    An = `click${un}.data-api`,
    En = "modal-open",
    Tn = "show",
    Cn = "modal-static",
    On = {
      backdrop: !0,
      focus: !0,
      keyboard: !0
    },
    xn = {
      backdrop: "(boolean|string)",
      focus: "boolean",
      keyboard: "boolean"
    };
  class kn extends W {
    constructor(t, e) {
      super(t, e), this._dialog = z.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new dn(), this._addEventListeners();
    }
    static get Default() {
      return On;
    }
    static get DefaultType() {
      return xn;
    }
    static get NAME() {
      return "modal";
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t);
    }
    show(t) {
      this._isShown || this._isTransitioning || N.trigger(this._element, gn, {
        relatedTarget: t
      }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(En), this._adjustDialog(), this._backdrop.show(() => this._showElement(t)));
    }
    hide() {
      this._isShown && !this._isTransitioning && (N.trigger(this._element, fn).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(Tn), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())));
    }
    dispose() {
      N.off(window, un), N.off(this._dialog, un), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }
    _initializeBackDrop() {
      return new Ji({
        isVisible: Boolean(this._config.backdrop),
        isAnimated: this._isAnimated()
      });
    }
    _initializeFocusTrap() {
      return new rn({
        trapElement: this._element
      });
    }
    _showElement(t) {
      document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
      const e = z.findOne(".modal-body", this._dialog);
      e && (e.scrollTop = 0), d(this._element), this._element.classList.add(Tn), this._queueCallback(() => {
        this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, N.trigger(this._element, _n, {
          relatedTarget: t
        });
      }, this._dialog, this._isAnimated());
    }
    _addEventListeners() {
      N.on(this._element, wn, t => {
        "Escape" === t.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition());
      }), N.on(window, bn, () => {
        this._isShown && !this._isTransitioning && this._adjustDialog();
      }), N.on(this._element, yn, t => {
        N.one(this._element, vn, e => {
          this._element === t.target && this._element === e.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition());
        });
      });
    }
    _hideModal() {
      this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
        document.body.classList.remove(En), this._resetAdjustments(), this._scrollBar.reset(), N.trigger(this._element, mn);
      });
    }
    _isAnimated() {
      return this._element.classList.contains("fade");
    }
    _triggerBackdropTransition() {
      if (N.trigger(this._element, pn).defaultPrevented) return;
      const t = this._element.scrollHeight > document.documentElement.clientHeight,
        e = this._element.style.overflowY;
      "hidden" === e || this._element.classList.contains(Cn) || (t || (this._element.style.overflowY = "hidden"), this._element.classList.add(Cn), this._queueCallback(() => {
        this._element.classList.remove(Cn), this._queueCallback(() => {
          this._element.style.overflowY = e;
        }, this._dialog);
      }, this._dialog), this._element.focus());
    }
    _adjustDialog() {
      const t = this._element.scrollHeight > document.documentElement.clientHeight,
        e = this._scrollBar.getWidth(),
        i = e > 0;
      if (i && !t) {
        const t = p() ? "paddingLeft" : "paddingRight";
        this._element.style[t] = `${e}px`;
      }
      if (!i && t) {
        const t = p() ? "paddingRight" : "paddingLeft";
        this._element.style[t] = `${e}px`;
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
    }
    static jQueryInterface(t, e) {
      return this.each(function () {
        const i = kn.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
          i[t](e);
        }
      });
    }
  }
  N.on(document, An, '[data-bs-toggle="modal"]', function (t) {
    const e = z.getElementFromSelector(this);
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), N.one(e, gn, t => {
      t.defaultPrevented || N.one(e, mn, () => {
        a(this) && this.focus();
      });
    });
    const i = z.findOne(".modal.show");
    i && kn.getInstance(i).hide(), kn.getOrCreateInstance(e).toggle(this);
  }), R(kn), m(kn);
  const Ln = ".bs.offcanvas",
    Sn = ".data-api",
    Dn = `load${Ln}${Sn}`,
    $n = "show",
    In = "showing",
    Nn = "hiding",
    Pn = ".offcanvas.show",
    jn = `show${Ln}`,
    Mn = `shown${Ln}`,
    Fn = `hide${Ln}`,
    Hn = `hidePrevented${Ln}`,
    Wn = `hidden${Ln}`,
    Bn = `resize${Ln}`,
    zn = `click${Ln}${Sn}`,
    Rn = `keydown.dismiss${Ln}`,
    qn = {
      backdrop: !0,
      keyboard: !0,
      scroll: !1
    },
    Vn = {
      backdrop: "(boolean|string)",
      keyboard: "boolean",
      scroll: "boolean"
    };
  class Kn extends W {
    constructor(t, e) {
      super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
    }
    static get Default() {
      return qn;
    }
    static get DefaultType() {
      return Vn;
    }
    static get NAME() {
      return "offcanvas";
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t);
    }
    show(t) {
      this._isShown || N.trigger(this._element, jn, {
        relatedTarget: t
      }).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || new dn().hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(In), this._queueCallback(() => {
        this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add($n), this._element.classList.remove(In), N.trigger(this._element, Mn, {
          relatedTarget: t
        });
      }, this._element, !0));
    }
    hide() {
      this._isShown && (N.trigger(this._element, Fn).defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(Nn), this._backdrop.hide(), this._queueCallback(() => {
        this._element.classList.remove($n, Nn), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new dn().reset(), N.trigger(this._element, Wn);
      }, this._element, !0)));
    }
    dispose() {
      this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
    }
    _initializeBackDrop() {
      const t = Boolean(this._config.backdrop);
      return new Ji({
        className: "offcanvas-backdrop",
        isVisible: t,
        isAnimated: !0,
        rootElement: this._element.parentNode,
        clickCallback: t ? () => {
          "static" !== this._config.backdrop ? this.hide() : N.trigger(this._element, Hn);
        } : null
      });
    }
    _initializeFocusTrap() {
      return new rn({
        trapElement: this._element
      });
    }
    _addEventListeners() {
      N.on(this._element, Rn, t => {
        "Escape" === t.key && (this._config.keyboard ? this.hide() : N.trigger(this._element, Hn));
      });
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Kn.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  N.on(document, zn, '[data-bs-toggle="offcanvas"]', function (t) {
    const e = z.getElementFromSelector(this);
    if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), l(this)) return;
    N.one(e, Wn, () => {
      a(this) && this.focus();
    });
    const i = z.findOne(Pn);
    i && i !== e && Kn.getInstance(i).hide(), Kn.getOrCreateInstance(e).toggle(this);
  }), N.on(window, Dn, () => {
    for (const t of z.find(Pn)) Kn.getOrCreateInstance(t).show();
  }), N.on(window, Bn, () => {
    for (const t of z.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(t).position && Kn.getOrCreateInstance(t).hide();
  }), R(Kn), m(Kn);
  const Qn = {
      "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
      a: ["target", "href", "title", "rel"],
      area: [],
      b: [],
      br: [],
      col: [],
      code: [],
      dd: [],
      div: [],
      dl: [],
      dt: [],
      em: [],
      hr: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      i: [],
      img: ["src", "srcset", "alt", "title", "width", "height"],
      li: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      small: [],
      span: [],
      sub: [],
      sup: [],
      strong: [],
      u: [],
      ul: []
    },
    Xn = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
    Yn = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i,
    Un = (t, e) => {
      const i = t.nodeName.toLowerCase();
      return e.includes(i) ? !Xn.has(i) || Boolean(Yn.test(t.nodeValue)) : e.filter(t => t instanceof RegExp).some(t => t.test(i));
    },
    Gn = {
      allowList: Qn,
      content: {},
      extraClass: "",
      html: !1,
      sanitize: !0,
      sanitizeFn: null,
      template: "<div></div>"
    },
    Jn = {
      allowList: "object",
      content: "object",
      extraClass: "(string|function)",
      html: "boolean",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      template: "string"
    },
    Zn = {
      entry: "(string|element|function|null)",
      selector: "(string|element)"
    };
  class ts extends H {
    constructor(t) {
      super(), this._config = this._getConfig(t);
    }
    static get Default() {
      return Gn;
    }
    static get DefaultType() {
      return Jn;
    }
    static get NAME() {
      return "TemplateFactory";
    }
    getContent() {
      return Object.values(this._config.content).map(t => this._resolvePossibleFunction(t)).filter(Boolean);
    }
    hasContent() {
      return this.getContent().length > 0;
    }
    changeContent(t) {
      return this._checkContent(t), this._config.content = {
        ...this._config.content,
        ...t
      }, this;
    }
    toHtml() {
      const t = document.createElement("div");
      t.innerHTML = this._maybeSanitize(this._config.template);
      for (const [e, i] of Object.entries(this._config.content)) this._setContent(t, i, e);
      const e = t.children[0],
        i = this._resolvePossibleFunction(this._config.extraClass);
      return i && e.classList.add(...i.split(" ")), e;
    }
    _typeCheckConfig(t) {
      super._typeCheckConfig(t), this._checkContent(t.content);
    }
    _checkContent(t) {
      for (const [e, i] of Object.entries(t)) super._typeCheckConfig({
        selector: e,
        entry: i
      }, Zn);
    }
    _setContent(t, e, i) {
      const n = z.findOne(i, t);
      n && ((e = this._resolvePossibleFunction(e)) ? o(e) ? this._putElementInTemplate(r(e), n) : this._config.html ? n.innerHTML = this._maybeSanitize(e) : n.textContent = e : n.remove());
    }
    _maybeSanitize(t) {
      return this._config.sanitize ? function (t, e, i) {
        if (!t.length) return t;
        if (i && "function" == typeof i) return i(t);
        const n = new window.DOMParser().parseFromString(t, "text/html"),
          s = [].concat(...n.body.querySelectorAll("*"));
        for (const t of s) {
          const i = t.nodeName.toLowerCase();
          if (!Object.keys(e).includes(i)) {
            t.remove();
            continue;
          }
          const n = [].concat(...t.attributes),
            s = [].concat(e["*"] || [], e[i] || []);
          for (const e of n) Un(e, s) || t.removeAttribute(e.nodeName);
        }
        return n.body.innerHTML;
      }(t, this._config.allowList, this._config.sanitizeFn) : t;
    }
    _resolvePossibleFunction(t) {
      return g(t, [void 0, this]);
    }
    _putElementInTemplate(t, e) {
      if (this._config.html) return e.innerHTML = "", void e.append(t);
      e.textContent = t.textContent;
    }
  }
  const es = new Set(["sanitize", "allowList", "sanitizeFn"]),
    is = "fade",
    ns = "show",
    ss = ".tooltip-inner",
    os = ".modal",
    rs = "hide.bs.modal",
    as = "hover",
    ls = "focus",
    cs = "click",
    hs = {
      AUTO: "auto",
      TOP: "top",
      RIGHT: p() ? "left" : "right",
      BOTTOM: "bottom",
      LEFT: p() ? "right" : "left"
    },
    ds = {
      allowList: Qn,
      animation: !0,
      boundary: "clippingParents",
      container: !1,
      customClass: "",
      delay: 0,
      fallbackPlacements: ["top", "right", "bottom", "left"],
      html: !1,
      offset: [0, 6],
      placement: "top",
      popperConfig: null,
      sanitize: !0,
      sanitizeFn: null,
      selector: !1,
      template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
      title: "",
      trigger: "hover focus"
    },
    us = {
      allowList: "object",
      animation: "boolean",
      boundary: "(string|element)",
      container: "(string|element|boolean)",
      customClass: "(string|function)",
      delay: "(number|object)",
      fallbackPlacements: "array",
      html: "boolean",
      offset: "(array|string|function)",
      placement: "(string|function)",
      popperConfig: "(null|object|function)",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      selector: "(string|boolean)",
      template: "string",
      title: "(string|element|function)",
      trigger: "string"
    };
  class fs extends W {
    constructor(t, e) {
      if (void 0 === wi) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org/docs/v2/)");
      super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle();
    }
    static get Default() {
      return ds;
    }
    static get DefaultType() {
      return us;
    }
    static get NAME() {
      return "tooltip";
    }
    enable() {
      this._isEnabled = !0;
    }
    disable() {
      this._isEnabled = !1;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle() {
      this._isEnabled && (this._isShown() ? this._leave() : this._enter());
    }
    dispose() {
      clearTimeout(this._timeout), N.off(this._element.closest(os), rs, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose();
    }
    show() {
      if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
      if (!this._isWithContent() || !this._isEnabled) return;
      const t = N.trigger(this._element, this.constructor.eventName("show")),
        e = (c(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
      if (t.defaultPrevented || !e) return;
      this._disposePopper();
      const i = this._getTipElement();
      this._element.setAttribute("aria-describedby", i.getAttribute("id"));
      const {
        container: n
      } = this._config;
      if (this._element.ownerDocument.documentElement.contains(this.tip) || (n.append(i), N.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i), i.classList.add(ns), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) N.on(t, "mouseover", h);
      this._queueCallback(() => {
        N.trigger(this._element, this.constructor.eventName("shown")), !1 === this._isHovered && this._leave(), this._isHovered = !1;
      }, this.tip, this._isAnimated());
    }
    hide() {
      if (this._isShown() && !N.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
        if (this._getTipElement().classList.remove(ns), "ontouchstart" in document.documentElement) for (const t of [].concat(...document.body.children)) N.off(t, "mouseover", h);
        this._activeTrigger[cs] = !1, this._activeTrigger[ls] = !1, this._activeTrigger[as] = !1, this._isHovered = null, this._queueCallback(() => {
          this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), N.trigger(this._element, this.constructor.eventName("hidden")));
        }, this.tip, this._isAnimated());
      }
    }
    update() {
      this._popper && this._popper.update();
    }
    _isWithContent() {
      return Boolean(this._getTitle());
    }
    _getTipElement() {
      return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
    }
    _createTipElement(t) {
      const e = this._getTemplateFactory(t).toHtml();
      if (!e) return null;
      e.classList.remove(is, ns), e.classList.add(`bs-${this.constructor.NAME}-auto`);
      const i = (t => {
        do {
          t += Math.floor(1e6 * Math.random());
        } while (document.getElementById(t));
        return t;
      })(this.constructor.NAME).toString();
      return e.setAttribute("id", i), this._isAnimated() && e.classList.add(is), e;
    }
    setContent(t) {
      this._newContent = t, this._isShown() && (this._disposePopper(), this.show());
    }
    _getTemplateFactory(t) {
      return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new ts({
        ...this._config,
        content: t,
        extraClass: this._resolvePossibleFunction(this._config.customClass)
      }), this._templateFactory;
    }
    _getContentForTemplate() {
      return {
        [ss]: this._getTitle()
      };
    }
    _getTitle() {
      return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
    }
    _initializeOnDelegatedTarget(t) {
      return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig());
    }
    _isAnimated() {
      return this._config.animation || this.tip && this.tip.classList.contains(is);
    }
    _isShown() {
      return this.tip && this.tip.classList.contains(ns);
    }
    _createPopper(t) {
      const e = g(this._config.placement, [this, t, this._element]),
        i = hs[e.toUpperCase()];
      return yi(this._element, t, this._getPopperConfig(i));
    }
    _getOffset() {
      const {
        offset: t
      } = this._config;
      return "string" == typeof t ? t.split(",").map(t => Number.parseInt(t, 10)) : "function" == typeof t ? e => t(e, this._element) : t;
    }
    _resolvePossibleFunction(t) {
      return g(t, [this._element, this._element]);
    }
    _getPopperConfig(t) {
      const e = {
        placement: t,
        modifiers: [{
          name: "flip",
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: "offset",
          options: {
            offset: this._getOffset()
          }
        }, {
          name: "preventOverflow",
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: "arrow",
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: "preSetPlacement",
          enabled: !0,
          phase: "beforeMain",
          fn: t => {
            this._getTipElement().setAttribute("data-popper-placement", t.state.placement);
          }
        }]
      };
      return {
        ...e,
        ...g(this._config.popperConfig, [void 0, e])
      };
    }
    _setListeners() {
      const t = this._config.trigger.split(" ");
      for (const e of t) if ("click" === e) N.on(this._element, this.constructor.eventName("click"), this._config.selector, t => {
        const e = this._initializeOnDelegatedTarget(t);
        e._activeTrigger[cs] = !(e._isShown() && e._activeTrigger[cs]), e.toggle();
      });else if ("manual" !== e) {
        const t = e === as ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"),
          i = e === as ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
        N.on(this._element, t, this._config.selector, t => {
          const e = this._initializeOnDelegatedTarget(t);
          e._activeTrigger["focusin" === t.type ? ls : as] = !0, e._enter();
        }), N.on(this._element, i, this._config.selector, t => {
          const e = this._initializeOnDelegatedTarget(t);
          e._activeTrigger["focusout" === t.type ? ls : as] = e._element.contains(t.relatedTarget), e._leave();
        });
      }
      this._hideModalHandler = () => {
        this._element && this.hide();
      }, N.on(this._element.closest(os), rs, this._hideModalHandler);
    }
    _fixTitle() {
      const t = this._element.getAttribute("title");
      t && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t), this._element.setAttribute("data-bs-original-title", t), this._element.removeAttribute("title"));
    }
    _enter() {
      this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout(() => {
        this._isHovered && this.show();
      }, this._config.delay.show));
    }
    _leave() {
      this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => {
        this._isHovered || this.hide();
      }, this._config.delay.hide));
    }
    _setTimeout(t, e) {
      clearTimeout(this._timeout), this._timeout = setTimeout(t, e);
    }
    _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(!0);
    }
    _getConfig(t) {
      const e = F.getDataAttributes(this._element);
      for (const t of Object.keys(e)) es.has(t) && delete e[t];
      return t = {
        ...e,
        ...("object" == typeof t && t ? t : {})
      }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t;
    }
    _configAfterMerge(t) {
      return t.container = !1 === t.container ? document.body : r(t.container), "number" == typeof t.delay && (t.delay = {
        show: t.delay,
        hide: t.delay
      }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), t;
    }
    _getDelegateConfig() {
      const t = {};
      for (const [e, i] of Object.entries(this._config)) this.constructor.Default[e] !== i && (t[e] = i);
      return t.selector = !1, t.trigger = "manual", t;
    }
    _disposePopper() {
      this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null);
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = fs.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  m(fs);
  const ps = ".popover-header",
    ms = ".popover-body",
    gs = {
      ...fs.Default,
      content: "",
      offset: [0, 8],
      placement: "right",
      template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
      trigger: "click"
    },
    _s = {
      ...fs.DefaultType,
      content: "(null|string|element|function)"
    };
  class bs extends fs {
    static get Default() {
      return gs;
    }
    static get DefaultType() {
      return _s;
    }
    static get NAME() {
      return "popover";
    }
    _isWithContent() {
      return this._getTitle() || this._getContent();
    }
    _getContentForTemplate() {
      return {
        [ps]: this._getTitle(),
        [ms]: this._getContent()
      };
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = bs.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  m(bs);
  const vs = ".bs.scrollspy",
    ys = `activate${vs}`,
    ws = `click${vs}`,
    As = `load${vs}.data-api`,
    Es = "active",
    Ts = "[href]",
    Cs = ".nav-link",
    Os = `${Cs}, .nav-item > ${Cs}, .list-group-item`,
    xs = {
      offset: null,
      rootMargin: "0px 0px -25%",
      smoothScroll: !1,
      target: null,
      threshold: [.1, .5, 1]
    },
    ks = {
      offset: "(number|null)",
      rootMargin: "string",
      smoothScroll: "boolean",
      target: "element",
      threshold: "array"
    };
  class Ls extends W {
    constructor(t, e) {
      super(t, e), this._targetLinks = new Map(), this._observableSections = new Map(), this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
        visibleEntryTop: 0,
        parentScrollTop: 0
      }, this.refresh();
    }
    static get Default() {
      return xs;
    }
    static get DefaultType() {
      return ks;
    }
    static get NAME() {
      return "scrollspy";
    }
    refresh() {
      this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
      for (const t of this._observableSections.values()) this._observer.observe(t);
    }
    dispose() {
      this._observer.disconnect(), super.dispose();
    }
    _configAfterMerge(t) {
      return t.target = r(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, "string" == typeof t.threshold && (t.threshold = t.threshold.split(",").map(t => Number.parseFloat(t))), t;
    }
    _maybeEnableSmoothScroll() {
      this._config.smoothScroll && (N.off(this._config.target, ws), N.on(this._config.target, ws, Ts, t => {
        const e = this._observableSections.get(t.target.hash);
        if (e) {
          t.preventDefault();
          const i = this._rootElement || window,
            n = e.offsetTop - this._element.offsetTop;
          if (i.scrollTo) return void i.scrollTo({
            top: n,
            behavior: "smooth"
          });
          i.scrollTop = n;
        }
      }));
    }
    _getNewObserver() {
      const t = {
        root: this._rootElement,
        threshold: this._config.threshold,
        rootMargin: this._config.rootMargin
      };
      return new IntersectionObserver(t => this._observerCallback(t), t);
    }
    _observerCallback(t) {
      const e = t => this._targetLinks.get(`#${t.target.id}`),
        i = t => {
          this._previousScrollData.visibleEntryTop = t.target.offsetTop, this._process(e(t));
        },
        n = (this._rootElement || document.documentElement).scrollTop,
        s = n >= this._previousScrollData.parentScrollTop;
      this._previousScrollData.parentScrollTop = n;
      for (const o of t) {
        if (!o.isIntersecting) {
          this._activeTarget = null, this._clearActiveClass(e(o));
          continue;
        }
        const t = o.target.offsetTop >= this._previousScrollData.visibleEntryTop;
        if (s && t) {
          if (i(o), !n) return;
        } else s || t || i(o);
      }
    }
    _initializeTargetsAndObservables() {
      this._targetLinks = new Map(), this._observableSections = new Map();
      const t = z.find(Ts, this._config.target);
      for (const e of t) {
        if (!e.hash || l(e)) continue;
        const t = z.findOne(decodeURI(e.hash), this._element);
        a(t) && (this._targetLinks.set(decodeURI(e.hash), e), this._observableSections.set(e.hash, t));
      }
    }
    _process(t) {
      this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(Es), this._activateParents(t), N.trigger(this._element, ys, {
        relatedTarget: t
      }));
    }
    _activateParents(t) {
      if (t.classList.contains("dropdown-item")) z.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(Es);else for (const e of z.parents(t, ".nav, .list-group")) for (const t of z.prev(e, Os)) t.classList.add(Es);
    }
    _clearActiveClass(t) {
      t.classList.remove(Es);
      const e = z.find(`${Ts}.${Es}`, t);
      for (const t of e) t.classList.remove(Es);
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Ls.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  N.on(window, As, () => {
    for (const t of z.find('[data-bs-spy="scroll"]')) Ls.getOrCreateInstance(t);
  }), m(Ls);
  const Ss = ".bs.tab",
    Ds = `hide${Ss}`,
    $s = `hidden${Ss}`,
    Is = `show${Ss}`,
    Ns = `shown${Ss}`,
    Ps = `click${Ss}`,
    js = `keydown${Ss}`,
    Ms = `load${Ss}`,
    Fs = "ArrowLeft",
    Hs = "ArrowRight",
    Ws = "ArrowUp",
    Bs = "ArrowDown",
    zs = "Home",
    Rs = "End",
    qs = "active",
    Vs = "fade",
    Ks = "show",
    Qs = ".dropdown-toggle",
    Xs = `:not(${Qs})`,
    Ys = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
    Us = `.nav-link${Xs}, .list-group-item${Xs}, [role="tab"]${Xs}, ${Ys}`,
    Gs = `.${qs}[data-bs-toggle="tab"], .${qs}[data-bs-toggle="pill"], .${qs}[data-bs-toggle="list"]`;
  class Js extends W {
    constructor(t) {
      super(t), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), N.on(this._element, js, t => this._keydown(t)));
    }
    static get NAME() {
      return "tab";
    }
    show() {
      const t = this._element;
      if (this._elemIsActive(t)) return;
      const e = this._getActiveElem(),
        i = e ? N.trigger(e, Ds, {
          relatedTarget: t
        }) : null;
      N.trigger(t, Is, {
        relatedTarget: e
      }).defaultPrevented || i && i.defaultPrevented || (this._deactivate(e, t), this._activate(t, e));
    }
    _activate(t, e) {
      t && (t.classList.add(qs), this._activate(z.getElementFromSelector(t)), this._queueCallback(() => {
        "tab" === t.getAttribute("role") ? (t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), N.trigger(t, Ns, {
          relatedTarget: e
        })) : t.classList.add(Ks);
      }, t, t.classList.contains(Vs)));
    }
    _deactivate(t, e) {
      t && (t.classList.remove(qs), t.blur(), this._deactivate(z.getElementFromSelector(t)), this._queueCallback(() => {
        "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), N.trigger(t, $s, {
          relatedTarget: e
        })) : t.classList.remove(Ks);
      }, t, t.classList.contains(Vs)));
    }
    _keydown(t) {
      if (![Fs, Hs, Ws, Bs, zs, Rs].includes(t.key)) return;
      t.stopPropagation(), t.preventDefault();
      const e = this._getChildren().filter(t => !l(t));
      let i;
      if ([zs, Rs].includes(t.key)) i = e[t.key === zs ? 0 : e.length - 1];else {
        const n = [Hs, Bs].includes(t.key);
        i = b(e, t.target, n, !0);
      }
      i && (i.focus({
        preventScroll: !0
      }), Js.getOrCreateInstance(i).show());
    }
    _getChildren() {
      return z.find(Us, this._parent);
    }
    _getActiveElem() {
      return this._getChildren().find(t => this._elemIsActive(t)) || null;
    }
    _setInitialAttributes(t, e) {
      this._setAttributeIfNotExists(t, "role", "tablist");
      for (const t of e) this._setInitialAttributesOnChild(t);
    }
    _setInitialAttributesOnChild(t) {
      t = this._getInnerElement(t);
      const e = this._elemIsActive(t),
        i = this._getOuterElement(t);
      t.setAttribute("aria-selected", e), i !== t && this._setAttributeIfNotExists(i, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t);
    }
    _setInitialAttributesOnTargetPanel(t) {
      const e = z.getElementFromSelector(t);
      e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `${t.id}`));
    }
    _toggleDropDown(t, e) {
      const i = this._getOuterElement(t);
      if (!i.classList.contains("dropdown")) return;
      const n = (t, n) => {
        const s = z.findOne(t, i);
        s && s.classList.toggle(n, e);
      };
      n(Qs, qs), n(".dropdown-menu", Ks), i.setAttribute("aria-expanded", e);
    }
    _setAttributeIfNotExists(t, e, i) {
      t.hasAttribute(e) || t.setAttribute(e, i);
    }
    _elemIsActive(t) {
      return t.classList.contains(qs);
    }
    _getInnerElement(t) {
      return t.matches(Us) ? t : z.findOne(Us, t);
    }
    _getOuterElement(t) {
      return t.closest(".nav-item, .list-group-item") || t;
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = Js.getOrCreateInstance(this);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  N.on(document, Ps, Ys, function (t) {
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(), l(this) || Js.getOrCreateInstance(this).show();
  }), N.on(window, Ms, () => {
    for (const t of z.find(Gs)) Js.getOrCreateInstance(t);
  }), m(Js);
  const Zs = ".bs.toast",
    to = `mouseover${Zs}`,
    eo = `mouseout${Zs}`,
    io = `focusin${Zs}`,
    no = `focusout${Zs}`,
    so = `hide${Zs}`,
    oo = `hidden${Zs}`,
    ro = `show${Zs}`,
    ao = `shown${Zs}`,
    lo = "hide",
    co = "show",
    ho = "showing",
    uo = {
      animation: "boolean",
      autohide: "boolean",
      delay: "number"
    },
    fo = {
      animation: !0,
      autohide: !0,
      delay: 5e3
    };
  class po extends W {
    constructor(t, e) {
      super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners();
    }
    static get Default() {
      return fo;
    }
    static get DefaultType() {
      return uo;
    }
    static get NAME() {
      return "toast";
    }
    show() {
      N.trigger(this._element, ro).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(lo), d(this._element), this._element.classList.add(co, ho), this._queueCallback(() => {
        this._element.classList.remove(ho), N.trigger(this._element, ao), this._maybeScheduleHide();
      }, this._element, this._config.animation));
    }
    hide() {
      this.isShown() && (N.trigger(this._element, so).defaultPrevented || (this._element.classList.add(ho), this._queueCallback(() => {
        this._element.classList.add(lo), this._element.classList.remove(ho, co), N.trigger(this._element, oo);
      }, this._element, this._config.animation)));
    }
    dispose() {
      this._clearTimeout(), this.isShown() && this._element.classList.remove(co), super.dispose();
    }
    isShown() {
      return this._element.classList.contains(co);
    }
    _maybeScheduleHide() {
      this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
        this.hide();
      }, this._config.delay)));
    }
    _onInteraction(t, e) {
      switch (t.type) {
        case "mouseover":
        case "mouseout":
          this._hasMouseInteraction = e;
          break;
        case "focusin":
        case "focusout":
          this._hasKeyboardInteraction = e;
      }
      if (e) return void this._clearTimeout();
      const i = t.relatedTarget;
      this._element === i || this._element.contains(i) || this._maybeScheduleHide();
    }
    _setListeners() {
      N.on(this._element, to, t => this._onInteraction(t, !0)), N.on(this._element, eo, t => this._onInteraction(t, !1)), N.on(this._element, io, t => this._onInteraction(t, !0)), N.on(this._element, no, t => this._onInteraction(t, !1));
    }
    _clearTimeout() {
      clearTimeout(this._timeout), this._timeout = null;
    }
    static jQueryInterface(t) {
      return this.each(function () {
        const e = po.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  return R(po), m(po), {
    Alert: Q,
    Button: Y,
    Carousel: Lt,
    Collapse: Rt,
    Dropdown: Ki,
    Modal: kn,
    Offcanvas: Kn,
    Popover: bs,
    ScrollSpy: Ls,
    Tab: Js,
    Toast: po,
    Tooltip: fs
  };
});
!function (e, t) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e || self).autosize = t();
}(this, function () {
  var e = new Map();
  function t(t) {
    var o = e.get(t);
    o && o.destroy();
  }
  function o(t) {
    var o = e.get(t);
    o && o.update();
  }
  var r = null;
  return "undefined" == typeof window ? ((r = function (e) {
    return e;
  }).destroy = function (e) {
    return e;
  }, r.update = function (e) {
    return e;
  }) : ((r = function (t, o) {
    return t && Array.prototype.forEach.call(t.length ? t : [t], function (t) {
      return function (t) {
        if (t && t.nodeName && "TEXTAREA" === t.nodeName && !e.has(t)) {
          var o,
            r = null,
            n = window.getComputedStyle(t),
            i = (o = t.value, function () {
              s({
                testForHeightReduction: "" === o || !t.value.startsWith(o),
                restoreTextAlign: null
              }), o = t.value;
            }),
            l = function (o) {
              t.removeEventListener("autosize:destroy", l), t.removeEventListener("autosize:update", a), t.removeEventListener("input", i), window.removeEventListener("resize", a), Object.keys(o).forEach(function (e) {
                return t.style[e] = o[e];
              }), e.delete(t);
            }.bind(t, {
              height: t.style.height,
              resize: t.style.resize,
              textAlign: t.style.textAlign,
              overflowY: t.style.overflowY,
              overflowX: t.style.overflowX,
              wordWrap: t.style.wordWrap
            });
          t.addEventListener("autosize:destroy", l), t.addEventListener("autosize:update", a), t.addEventListener("input", i), window.addEventListener("resize", a), t.style.overflowX = "hidden", t.style.wordWrap = "break-word", e.set(t, {
            destroy: l,
            update: a
          }), a();
        }
        function s(e) {
          var o,
            i,
            l = e.restoreTextAlign,
            a = void 0 === l ? null : l,
            d = e.testForHeightReduction,
            u = void 0 === d || d,
            f = n.overflowY;
          if (0 !== t.scrollHeight && ("vertical" === n.resize ? t.style.resize = "none" : "both" === n.resize && (t.style.resize = "horizontal"), u && (o = function (e) {
            for (var t = []; e && e.parentNode && e.parentNode instanceof Element;) e.parentNode.scrollTop && t.push([e.parentNode, e.parentNode.scrollTop]), e = e.parentNode;
            return function () {
              return t.forEach(function (e) {
                var t = e[0],
                  o = e[1];
                t.style.scrollBehavior = "auto", t.scrollTop = o, t.style.scrollBehavior = null;
              });
            };
          }(t), t.style.height = ""), i = "content-box" === n.boxSizing ? t.scrollHeight - (parseFloat(n.paddingTop) + parseFloat(n.paddingBottom)) : t.scrollHeight + parseFloat(n.borderTopWidth) + parseFloat(n.borderBottomWidth), "none" !== n.maxHeight && i > parseFloat(n.maxHeight) ? ("hidden" === n.overflowY && (t.style.overflow = "scroll"), i = parseFloat(n.maxHeight)) : "hidden" !== n.overflowY && (t.style.overflow = "hidden"), t.style.height = i + "px", a && (t.style.textAlign = a), o && o(), r !== i && (t.dispatchEvent(new Event("autosize:resized", {
            bubbles: !0
          })), r = i), f !== n.overflow && !a)) {
            var c = n.textAlign;
            "hidden" === n.overflow && (t.style.textAlign = "start" === c ? "end" : "start"), s({
              restoreTextAlign: c,
              testForHeightReduction: !0
            });
          }
        }
        function a() {
          s({
            testForHeightReduction: !0,
            restoreTextAlign: null
          });
        }
      }(t);
    }), t;
  }).destroy = function (e) {
    return e && Array.prototype.forEach.call(e.length ? e : [e], t), e;
  }, r.update = function (e) {
    return e && Array.prototype.forEach.call(e.length ? e : [e], o), e;
  }), r;
});
/*! choices.js v11.1.0 | © 2025 Josh Johnson | https://github.com/jshjohnson/Choices#readme */
!function (e, t) {
  "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Choices = t();
}(this, function () {
  "use strict";

  var e = function (t, i) {
    return e = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (e, t) {
      e.__proto__ = t;
    } || function (e, t) {
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }, e(t, i);
  };
  function t(t, i) {
    if ("function" != typeof i && null !== i) throw new TypeError("Class extends value " + String(i) + " is not a constructor or null");
    function n() {
      this.constructor = t;
    }
    e(t, i), t.prototype = null === i ? Object.create(i) : (n.prototype = i.prototype, new n());
  }
  var i = function () {
    return i = Object.assign || function (e) {
      for (var t, i = 1, n = arguments.length; i < n; i++) for (var s in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
      return e;
    }, i.apply(this, arguments);
  };
  function n(e, t, i) {
    if (i || 2 === arguments.length) for (var n, s = 0, o = t.length; s < o; s++) !n && s in t || (n || (n = Array.prototype.slice.call(t, 0, s)), n[s] = t[s]);
    return e.concat(n || Array.prototype.slice.call(t));
  }
  "function" == typeof SuppressedError && SuppressedError;
  var s,
    o = "ADD_CHOICE",
    r = "REMOVE_CHOICE",
    c = "FILTER_CHOICES",
    a = "ACTIVATE_CHOICES",
    h = "CLEAR_CHOICES",
    l = "ADD_GROUP",
    u = "ADD_ITEM",
    d = "REMOVE_ITEM",
    p = "HIGHLIGHT_ITEM",
    f = "search",
    m = "removeItem",
    g = "highlightItem",
    v = ["fuseOptions", "classNames"],
    _ = "select-one",
    y = "select-multiple",
    b = function (e) {
      return {
        type: o,
        choice: e
      };
    },
    E = function (e) {
      return {
        type: u,
        item: e
      };
    },
    C = function (e) {
      return {
        type: d,
        item: e
      };
    },
    S = function (e, t) {
      return {
        type: p,
        item: e,
        highlighted: t
      };
    },
    w = function (e) {
      return Array.from({
        length: e
      }, function () {
        return Math.floor(36 * Math.random() + 0).toString(36);
      }).join("");
    },
    I = function (e) {
      if ("string" != typeof e) {
        if (null == e) return "";
        if ("object" == typeof e) {
          if ("raw" in e) return I(e.raw);
          if ("trusted" in e) return e.trusted;
        }
        return e;
      }
      return e.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/'/g, "&#039;").replace(/"/g, "&quot;");
    },
    A = (s = document.createElement("div"), function (e) {
      s.innerHTML = e.trim();
      for (var t = s.children[0]; s.firstChild;) s.removeChild(s.firstChild);
      return t;
    }),
    x = function (e, t) {
      return "function" == typeof e ? e(I(t), t) : e;
    },
    O = function (e) {
      return "function" == typeof e ? e() : e;
    },
    L = function (e) {
      if ("string" == typeof e) return e;
      if ("object" == typeof e) {
        if ("trusted" in e) return e.trusted;
        if ("raw" in e) return e.raw;
      }
      return "";
    },
    M = function (e) {
      if ("string" == typeof e) return e;
      if ("object" == typeof e) {
        if ("escaped" in e) return e.escaped;
        if ("trusted" in e) return e.trusted;
      }
      return "";
    },
    T = function (e, t) {
      return e ? M(t) : I(t);
    },
    N = function (e, t, i) {
      e.innerHTML = T(t, i);
    },
    k = function (e, t) {
      return e.rank - t.rank;
    },
    F = function (e) {
      return Array.isArray(e) ? e : [e];
    },
    D = function (e) {
      return e && Array.isArray(e) ? e.map(function (e) {
        return ".".concat(e);
      }).join("") : ".".concat(e);
    },
    P = function (e, t) {
      var i;
      (i = e.classList).add.apply(i, F(t));
    },
    j = function (e, t) {
      var i;
      (i = e.classList).remove.apply(i, F(t));
    },
    R = function (e) {
      if (void 0 !== e) try {
        return JSON.parse(e);
      } catch (t) {
        return e;
      }
      return {};
    },
    K = function () {
      function e(e) {
        var t = e.type,
          i = e.classNames;
        this.element = e.element, this.classNames = i, this.type = t, this.isActive = !1;
      }
      return e.prototype.show = function () {
        return P(this.element, this.classNames.activeState), this.element.setAttribute("aria-expanded", "true"), this.isActive = !0, this;
      }, e.prototype.hide = function () {
        return j(this.element, this.classNames.activeState), this.element.setAttribute("aria-expanded", "false"), this.isActive = !1, this;
      }, e;
    }(),
    V = function () {
      function e(e) {
        var t = e.type,
          i = e.classNames,
          n = e.position;
        this.element = e.element, this.classNames = i, this.type = t, this.position = n, this.isOpen = !1, this.isFlipped = !1, this.isDisabled = !1, this.isLoading = !1;
      }
      return e.prototype.shouldFlip = function (e, t) {
        var i = !1;
        return "auto" === this.position ? i = this.element.getBoundingClientRect().top - t >= 0 && !window.matchMedia("(min-height: ".concat(e + 1, "px)")).matches : "top" === this.position && (i = !0), i;
      }, e.prototype.setActiveDescendant = function (e) {
        this.element.setAttribute("aria-activedescendant", e);
      }, e.prototype.removeActiveDescendant = function () {
        this.element.removeAttribute("aria-activedescendant");
      }, e.prototype.open = function (e, t) {
        P(this.element, this.classNames.openState), this.element.setAttribute("aria-expanded", "true"), this.isOpen = !0, this.shouldFlip(e, t) && (P(this.element, this.classNames.flippedState), this.isFlipped = !0);
      }, e.prototype.close = function () {
        j(this.element, this.classNames.openState), this.element.setAttribute("aria-expanded", "false"), this.removeActiveDescendant(), this.isOpen = !1, this.isFlipped && (j(this.element, this.classNames.flippedState), this.isFlipped = !1);
      }, e.prototype.addFocusState = function () {
        P(this.element, this.classNames.focusState);
      }, e.prototype.removeFocusState = function () {
        j(this.element, this.classNames.focusState);
      }, e.prototype.enable = function () {
        j(this.element, this.classNames.disabledState), this.element.removeAttribute("aria-disabled"), this.type === _ && this.element.setAttribute("tabindex", "0"), this.isDisabled = !1;
      }, e.prototype.disable = function () {
        P(this.element, this.classNames.disabledState), this.element.setAttribute("aria-disabled", "true"), this.type === _ && this.element.setAttribute("tabindex", "-1"), this.isDisabled = !0;
      }, e.prototype.wrap = function (e) {
        var t = this.element,
          i = e.parentNode;
        i && (e.nextSibling ? i.insertBefore(t, e.nextSibling) : i.appendChild(t)), t.appendChild(e);
      }, e.prototype.unwrap = function (e) {
        var t = this.element,
          i = t.parentNode;
        i && (i.insertBefore(e, t), i.removeChild(t));
      }, e.prototype.addLoadingState = function () {
        P(this.element, this.classNames.loadingState), this.element.setAttribute("aria-busy", "true"), this.isLoading = !0;
      }, e.prototype.removeLoadingState = function () {
        j(this.element, this.classNames.loadingState), this.element.removeAttribute("aria-busy"), this.isLoading = !1;
      }, e;
    }(),
    B = function () {
      function e(e) {
        var t = e.element,
          i = e.type,
          n = e.classNames,
          s = e.preventPaste;
        this.element = t, this.type = i, this.classNames = n, this.preventPaste = s, this.isFocussed = this.element.isEqualNode(document.activeElement), this.isDisabled = t.disabled, this._onPaste = this._onPaste.bind(this), this._onInput = this._onInput.bind(this), this._onFocus = this._onFocus.bind(this), this._onBlur = this._onBlur.bind(this);
      }
      return Object.defineProperty(e.prototype, "placeholder", {
        set: function (e) {
          this.element.placeholder = e;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "value", {
        get: function () {
          return this.element.value;
        },
        set: function (e) {
          this.element.value = e;
        },
        enumerable: !1,
        configurable: !0
      }), e.prototype.addEventListeners = function () {
        var e = this.element;
        e.addEventListener("paste", this._onPaste), e.addEventListener("input", this._onInput, {
          passive: !0
        }), e.addEventListener("focus", this._onFocus, {
          passive: !0
        }), e.addEventListener("blur", this._onBlur, {
          passive: !0
        });
      }, e.prototype.removeEventListeners = function () {
        var e = this.element;
        e.removeEventListener("input", this._onInput), e.removeEventListener("paste", this._onPaste), e.removeEventListener("focus", this._onFocus), e.removeEventListener("blur", this._onBlur);
      }, e.prototype.enable = function () {
        this.element.removeAttribute("disabled"), this.isDisabled = !1;
      }, e.prototype.disable = function () {
        this.element.setAttribute("disabled", ""), this.isDisabled = !0;
      }, e.prototype.focus = function () {
        this.isFocussed || this.element.focus();
      }, e.prototype.blur = function () {
        this.isFocussed && this.element.blur();
      }, e.prototype.clear = function (e) {
        return void 0 === e && (e = !0), this.element.value = "", e && this.setWidth(), this;
      }, e.prototype.setWidth = function () {
        var e = this.element;
        e.style.minWidth = "".concat(e.placeholder.length + 1, "ch"), e.style.width = "".concat(e.value.length + 1, "ch");
      }, e.prototype.setActiveDescendant = function (e) {
        this.element.setAttribute("aria-activedescendant", e);
      }, e.prototype.removeActiveDescendant = function () {
        this.element.removeAttribute("aria-activedescendant");
      }, e.prototype._onInput = function () {
        this.type !== _ && this.setWidth();
      }, e.prototype._onPaste = function (e) {
        this.preventPaste && e.preventDefault();
      }, e.prototype._onFocus = function () {
        this.isFocussed = !0;
      }, e.prototype._onBlur = function () {
        this.isFocussed = !1;
      }, e;
    }(),
    H = function () {
      function e(e) {
        this.element = e.element, this.scrollPos = this.element.scrollTop, this.height = this.element.offsetHeight;
      }
      return e.prototype.prepend = function (e) {
        var t = this.element.firstElementChild;
        t ? this.element.insertBefore(e, t) : this.element.append(e);
      }, e.prototype.scrollToTop = function () {
        this.element.scrollTop = 0;
      }, e.prototype.scrollToChildElement = function (e, t) {
        var i = this;
        if (e) {
          var n = t > 0 ? this.element.scrollTop + (e.offsetTop + e.offsetHeight) - (this.element.scrollTop + this.element.offsetHeight) : e.offsetTop;
          requestAnimationFrame(function () {
            i._animateScroll(n, t);
          });
        }
      }, e.prototype._scrollDown = function (e, t, i) {
        var n = (i - e) / t;
        this.element.scrollTop = e + (n > 1 ? n : 1);
      }, e.prototype._scrollUp = function (e, t, i) {
        var n = (e - i) / t;
        this.element.scrollTop = e - (n > 1 ? n : 1);
      }, e.prototype._animateScroll = function (e, t) {
        var i = this,
          n = this.element.scrollTop,
          s = !1;
        t > 0 ? (this._scrollDown(n, 4, e), n < e && (s = !0)) : (this._scrollUp(n, 4, e), n > e && (s = !0)), s && requestAnimationFrame(function () {
          i._animateScroll(e, t);
        });
      }, e;
    }(),
    $ = function () {
      function e(e) {
        var t = e.classNames;
        this.element = e.element, this.classNames = t, this.isDisabled = !1;
      }
      return Object.defineProperty(e.prototype, "isActive", {
        get: function () {
          return "active" === this.element.dataset.choice;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "dir", {
        get: function () {
          return this.element.dir;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "value", {
        get: function () {
          return this.element.value;
        },
        set: function (e) {
          this.element.setAttribute("value", e), this.element.value = e;
        },
        enumerable: !1,
        configurable: !0
      }), e.prototype.conceal = function () {
        var e = this.element;
        P(e, this.classNames.input), e.hidden = !0, e.tabIndex = -1;
        var t = e.getAttribute("style");
        t && e.setAttribute("data-choice-orig-style", t), e.setAttribute("data-choice", "active");
      }, e.prototype.reveal = function () {
        var e = this.element;
        j(e, this.classNames.input), e.hidden = !1, e.removeAttribute("tabindex");
        var t = e.getAttribute("data-choice-orig-style");
        t ? (e.removeAttribute("data-choice-orig-style"), e.setAttribute("style", t)) : e.removeAttribute("style"), e.removeAttribute("data-choice");
      }, e.prototype.enable = function () {
        this.element.removeAttribute("disabled"), this.element.disabled = !1, this.isDisabled = !1;
      }, e.prototype.disable = function () {
        this.element.setAttribute("disabled", ""), this.element.disabled = !0, this.isDisabled = !0;
      }, e.prototype.triggerEvent = function (e, t) {
        var i;
        void 0 === (i = t || {}) && (i = null), this.element.dispatchEvent(new CustomEvent(e, {
          detail: i,
          bubbles: !0,
          cancelable: !0
        }));
      }, e;
    }(),
    q = function (e) {
      function i() {
        return null !== e && e.apply(this, arguments) || this;
      }
      return t(i, e), i;
    }($),
    W = function (e, t) {
      return void 0 === t && (t = !0), void 0 === e ? t : !!e;
    },
    U = function (e) {
      if ("string" == typeof e && (e = e.split(" ").filter(function (e) {
        return e.length;
      })), Array.isArray(e) && e.length) return e;
    },
    G = function (e, t, i) {
      if (void 0 === i && (i = !0), "string" == typeof e) {
        var n = I(e);
        return G({
          value: e,
          label: i || n === e ? e : {
            escaped: n,
            raw: e
          },
          selected: !0
        }, !1);
      }
      var s = e;
      if ("choices" in s) {
        if (!t) throw new TypeError("optGroup is not allowed");
        var o = s,
          r = o.choices.map(function (e) {
            return G(e, !1);
          });
        return {
          id: 0,
          label: L(o.label) || o.value,
          active: !!r.length,
          disabled: !!o.disabled,
          choices: r
        };
      }
      var c = s;
      return {
        id: 0,
        group: null,
        score: 0,
        rank: 0,
        value: c.value,
        label: c.label || c.value,
        active: W(c.active),
        selected: W(c.selected, !1),
        disabled: W(c.disabled, !1),
        placeholder: W(c.placeholder, !1),
        highlighted: !1,
        labelClass: U(c.labelClass),
        labelDescription: c.labelDescription,
        customProperties: c.customProperties
      };
    },
    z = function (e) {
      return "SELECT" === e.tagName;
    },
    J = function (e) {
      function i(t) {
        var i = t.template,
          n = t.extractPlaceholder,
          s = e.call(this, {
            element: t.element,
            classNames: t.classNames
          }) || this;
        return s.template = i, s.extractPlaceholder = n, s;
      }
      return t(i, e), Object.defineProperty(i.prototype, "placeholderOption", {
        get: function () {
          return this.element.querySelector('option[value=""]') || this.element.querySelector("option[placeholder]");
        },
        enumerable: !1,
        configurable: !0
      }), i.prototype.addOptions = function (e) {
        var t = this,
          i = document.createDocumentFragment();
        e.forEach(function (e) {
          var n = e;
          if (!n.element) {
            var s = t.template(n);
            i.appendChild(s), n.element = s;
          }
        }), this.element.appendChild(i);
      }, i.prototype.optionsAsChoices = function () {
        var e = this,
          t = [];
        return this.element.querySelectorAll(":scope > option, :scope > optgroup").forEach(function (i) {
          !function (e) {
            return "OPTION" === e.tagName;
          }(i) ? function (e) {
            return "OPTGROUP" === e.tagName;
          }(i) && t.push(e._optgroupToChoice(i)) : t.push(e._optionToChoice(i));
        }), t;
      }, i.prototype._optionToChoice = function (e) {
        return !e.hasAttribute("value") && e.hasAttribute("placeholder") && (e.setAttribute("value", ""), e.value = ""), {
          id: 0,
          group: null,
          score: 0,
          rank: 0,
          value: e.value,
          label: e.label,
          element: e,
          active: !0,
          selected: this.extractPlaceholder ? e.selected : e.hasAttribute("selected"),
          disabled: e.disabled,
          highlighted: !1,
          placeholder: this.extractPlaceholder && (!e.value || e.hasAttribute("placeholder")),
          labelClass: void 0 !== e.dataset.labelClass ? U(e.dataset.labelClass) : void 0,
          labelDescription: void 0 !== e.dataset.labelDescription ? e.dataset.labelDescription : void 0,
          customProperties: R(e.dataset.customProperties)
        };
      }, i.prototype._optgroupToChoice = function (e) {
        var t = this,
          i = e.querySelectorAll("option"),
          n = Array.from(i).map(function (e) {
            return t._optionToChoice(e);
          });
        return {
          id: 0,
          label: e.label || "",
          element: e,
          active: !!n.length,
          disabled: e.disabled,
          choices: n
        };
      }, i;
    }($),
    X = {
      items: [],
      choices: [],
      silent: !1,
      renderChoiceLimit: -1,
      maxItemCount: -1,
      closeDropdownOnSelect: "auto",
      singleModeForMultiSelect: !1,
      addChoices: !1,
      addItems: !0,
      addItemFilter: function (e) {
        return !!e && "" !== e;
      },
      removeItems: !0,
      removeItemButton: !1,
      removeItemButtonAlignLeft: !1,
      editItems: !1,
      allowHTML: !1,
      allowHtmlUserInput: !1,
      duplicateItemsAllowed: !0,
      delimiter: ",",
      paste: !0,
      searchEnabled: !0,
      searchChoices: !0,
      searchFloor: 1,
      searchResultLimit: 4,
      searchFields: ["label", "value"],
      position: "auto",
      resetScrollPosition: !0,
      shouldSort: !0,
      shouldSortItems: !1,
      sorter: function (e, t) {
        var i = e.label,
          n = t.label,
          s = void 0 === n ? t.value : n;
        return L(void 0 === i ? e.value : i).localeCompare(L(s), [], {
          sensitivity: "base",
          ignorePunctuation: !0,
          numeric: !0
        });
      },
      shadowRoot: null,
      placeholder: !0,
      placeholderValue: null,
      searchPlaceholderValue: null,
      prependValue: null,
      appendValue: null,
      renderSelectedChoices: "auto",
      loadingText: "Loading...",
      noResultsText: "No results found",
      noChoicesText: "No choices to choose from",
      itemSelectText: "Press to select",
      uniqueItemText: "Only unique values can be added",
      customAddItemText: "Only values matching specific conditions can be added",
      addItemText: function (e) {
        return 'Press Enter to add <b>"'.concat(e, '"</b>');
      },
      removeItemIconText: function () {
        return "Remove item";
      },
      removeItemLabelText: function (e) {
        return "Remove item: ".concat(e);
      },
      maxItemText: function (e) {
        return "Only ".concat(e, " values can be added");
      },
      valueComparer: function (e, t) {
        return e === t;
      },
      fuseOptions: {
        includeScore: !0
      },
      labelId: "",
      callbackOnInit: null,
      callbackOnCreateTemplates: null,
      classNames: {
        containerOuter: ["choices"],
        containerInner: ["choices__inner"],
        input: ["choices__input"],
        inputCloned: ["choices__input--cloned"],
        list: ["choices__list"],
        listItems: ["choices__list--multiple"],
        listSingle: ["choices__list--single"],
        listDropdown: ["choices__list--dropdown"],
        item: ["choices__item"],
        itemSelectable: ["choices__item--selectable"],
        itemDisabled: ["choices__item--disabled"],
        itemChoice: ["choices__item--choice"],
        description: ["choices__description"],
        placeholder: ["choices__placeholder"],
        group: ["choices__group"],
        groupHeading: ["choices__heading"],
        button: ["choices__button"],
        activeState: ["is-active"],
        focusState: ["is-focused"],
        openState: ["is-open"],
        disabledState: ["is-disabled"],
        highlightedState: ["is-highlighted"],
        selectedState: ["is-selected"],
        flippedState: ["is-flipped"],
        loadingState: ["is-loading"],
        notice: ["choices__notice"],
        addChoice: ["choices__item--selectable", "add-choice"],
        noResults: ["has-no-results"],
        noChoices: ["has-no-choices"]
      },
      appendGroupInSearch: !1
    },
    Q = function (e) {
      var t = e.itemEl;
      t && (t.remove(), e.itemEl = void 0);
    },
    Y = {
      groups: function (e, t) {
        var i = e,
          n = !0;
        switch (t.type) {
          case l:
            i.push(t.group);
            break;
          case h:
            i = [];
            break;
          default:
            n = !1;
        }
        return {
          state: i,
          update: n
        };
      },
      items: function (e, t, i) {
        var n = e,
          s = !0;
        switch (t.type) {
          case u:
            t.item.selected = !0, (o = t.item.element) && (o.selected = !0, o.setAttribute("selected", "")), n.push(t.item);
            break;
          case d:
            var o;
            if (t.item.selected = !1, o = t.item.element) {
              o.selected = !1, o.removeAttribute("selected");
              var c = o.parentElement;
              c && z(c) && c.type === _ && (c.value = "");
            }
            Q(t.item), n = n.filter(function (e) {
              return e.id !== t.item.id;
            });
            break;
          case r:
            Q(t.choice), n = n.filter(function (e) {
              return e.id !== t.choice.id;
            });
            break;
          case p:
            var a = t.highlighted,
              h = n.find(function (e) {
                return e.id === t.item.id;
              });
            h && h.highlighted !== a && (h.highlighted = a, i && function (e, t, i) {
              var n = e.itemEl;
              n && (j(n, i), P(n, t));
            }(h, a ? i.classNames.highlightedState : i.classNames.selectedState, a ? i.classNames.selectedState : i.classNames.highlightedState));
            break;
          default:
            s = !1;
        }
        return {
          state: n,
          update: s
        };
      },
      choices: function (e, t, i) {
        var n = e,
          s = !0;
        switch (t.type) {
          case o:
            n.push(t.choice);
            break;
          case r:
            t.choice.choiceEl = void 0, t.choice.group && (t.choice.group.choices = t.choice.group.choices.filter(function (e) {
              return e.id !== t.choice.id;
            })), n = n.filter(function (e) {
              return e.id !== t.choice.id;
            });
            break;
          case u:
          case d:
            t.item.choiceEl = void 0;
            break;
          case c:
            var l = [];
            t.results.forEach(function (e) {
              l[e.item.id] = e;
            }), n.forEach(function (e) {
              var t = l[e.id];
              void 0 !== t ? (e.score = t.score, e.rank = t.rank, e.active = !0) : (e.score = 0, e.rank = 0, e.active = !1), i && i.appendGroupInSearch && (e.choiceEl = void 0);
            });
            break;
          case a:
            n.forEach(function (e) {
              e.active = t.active, i && i.appendGroupInSearch && (e.choiceEl = void 0);
            });
            break;
          case h:
            n = [];
            break;
          default:
            s = !1;
        }
        return {
          state: n,
          update: s
        };
      }
    },
    Z = function () {
      function e(e) {
        this._state = this.defaultState, this._listeners = [], this._txn = 0, this._context = e;
      }
      return Object.defineProperty(e.prototype, "defaultState", {
        get: function () {
          return {
            groups: [],
            items: [],
            choices: []
          };
        },
        enumerable: !1,
        configurable: !0
      }), e.prototype.changeSet = function (e) {
        return {
          groups: e,
          items: e,
          choices: e
        };
      }, e.prototype.reset = function () {
        this._state = this.defaultState;
        var e = this.changeSet(!0);
        this._txn ? this._changeSet = e : this._listeners.forEach(function (t) {
          return t(e);
        });
      }, e.prototype.subscribe = function (e) {
        return this._listeners.push(e), this;
      }, e.prototype.dispatch = function (e) {
        var t = this,
          i = this._state,
          n = !1,
          s = this._changeSet || this.changeSet(!1);
        Object.keys(Y).forEach(function (o) {
          var r = Y[o](i[o], e, t._context);
          r.update && (n = !0, s[o] = !0, i[o] = r.state);
        }), n && (this._txn ? this._changeSet = s : this._listeners.forEach(function (e) {
          return e(s);
        }));
      }, e.prototype.withTxn = function (e) {
        this._txn++;
        try {
          e();
        } finally {
          if (this._txn = Math.max(0, this._txn - 1), !this._txn) {
            var t = this._changeSet;
            t && (this._changeSet = void 0, this._listeners.forEach(function (e) {
              return e(t);
            }));
          }
        }
      }, Object.defineProperty(e.prototype, "state", {
        get: function () {
          return this._state;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "items", {
        get: function () {
          return this.state.items;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "highlightedActiveItems", {
        get: function () {
          return this.items.filter(function (e) {
            return e.active && e.highlighted;
          });
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "choices", {
        get: function () {
          return this.state.choices;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "activeChoices", {
        get: function () {
          return this.choices.filter(function (e) {
            return e.active;
          });
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "searchableChoices", {
        get: function () {
          return this.choices.filter(function (e) {
            return !e.disabled && !e.placeholder;
          });
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "groups", {
        get: function () {
          return this.state.groups;
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "activeGroups", {
        get: function () {
          var e = this;
          return this.state.groups.filter(function (t) {
            var i = t.active && !t.disabled,
              n = e.state.choices.some(function (e) {
                return e.active && !e.disabled;
              });
            return i && n;
          }, []);
        },
        enumerable: !1,
        configurable: !0
      }), e.prototype.inTxn = function () {
        return this._txn > 0;
      }, e.prototype.getChoiceById = function (e) {
        return this.activeChoices.find(function (t) {
          return t.id === e;
        });
      }, e.prototype.getGroupById = function (e) {
        return this.groups.find(function (t) {
          return t.id === e;
        });
      }, e;
    }(),
    ee = "no-choices",
    te = "no-results",
    ie = "add-choice";
  function ne(e, t, i) {
    return (t = function (e) {
      var t = function (e) {
        if ("object" != typeof e || !e) return e;
        var t = e[Symbol.toPrimitive];
        if (void 0 !== t) {
          var i = t.call(e, "string");
          if ("object" != typeof i) return i;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return String(e);
      }(e);
      return "symbol" == typeof t ? t : t + "";
    }(t)) in e ? Object.defineProperty(e, t, {
      value: i,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[t] = i, e;
  }
  function se(e, t) {
    var i = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t && (n = n.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable;
      })), i.push.apply(i, n);
    }
    return i;
  }
  function oe(e) {
    for (var t = 1; t < arguments.length; t++) {
      var i = null != arguments[t] ? arguments[t] : {};
      t % 2 ? se(Object(i), !0).forEach(function (t) {
        ne(e, t, i[t]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : se(Object(i)).forEach(function (t) {
        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t));
      });
    }
    return e;
  }
  function re(e) {
    return Array.isArray ? Array.isArray(e) : "[object Array]" === de(e);
  }
  function ce(e) {
    return "string" == typeof e;
  }
  function ae(e) {
    return "number" == typeof e;
  }
  function he(e) {
    return "object" == typeof e;
  }
  function le(e) {
    return null != e;
  }
  function ue(e) {
    return !e.trim().length;
  }
  function de(e) {
    return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e);
  }
  const pe = e => `Missing ${e} property in key`,
    fe = e => `Property 'weight' in key '${e}' must be a positive integer`,
    me = Object.prototype.hasOwnProperty;
  class ge {
    constructor(e) {
      this._keys = [], this._keyMap = {};
      let t = 0;
      e.forEach(e => {
        let i = ve(e);
        this._keys.push(i), this._keyMap[i.id] = i, t += i.weight;
      }), this._keys.forEach(e => {
        e.weight /= t;
      });
    }
    get(e) {
      return this._keyMap[e];
    }
    keys() {
      return this._keys;
    }
    toJSON() {
      return JSON.stringify(this._keys);
    }
  }
  function ve(e) {
    let t = null,
      i = null,
      n = null,
      s = 1,
      o = null;
    if (ce(e) || re(e)) n = e, t = _e(e), i = ye(e);else {
      if (!me.call(e, "name")) throw new Error(pe("name"));
      const r = e.name;
      if (n = r, me.call(e, "weight") && (s = e.weight, s <= 0)) throw new Error(fe(r));
      t = _e(r), i = ye(r), o = e.getFn;
    }
    return {
      path: t,
      id: i,
      weight: s,
      src: n,
      getFn: o
    };
  }
  function _e(e) {
    return re(e) ? e : e.split(".");
  }
  function ye(e) {
    return re(e) ? e.join(".") : e;
  }
  const be = {
    useExtendedSearch: !1,
    getFn: function (e, t) {
      let i = [],
        n = !1;
      const s = (e, t, o) => {
        if (le(e)) if (t[o]) {
          const r = e[t[o]];
          if (!le(r)) return;
          if (o === t.length - 1 && (ce(r) || ae(r) || function (e) {
            return !0 === e || !1 === e || function (e) {
              return he(e) && null !== e;
            }(e) && "[object Boolean]" == de(e);
          }(r))) i.push(function (e) {
            return null == e ? "" : function (e) {
              if ("string" == typeof e) return e;
              let t = e + "";
              return "0" == t && 1 / e == -1 / 0 ? "-0" : t;
            }(e);
          }(r));else if (re(r)) {
            n = !0;
            for (let e = 0, i = r.length; e < i; e += 1) s(r[e], t, o + 1);
          } else t.length && s(r, t, o + 1);
        } else i.push(e);
      };
      return s(e, ce(t) ? t.split(".") : t, 0), n ? i : i[0];
    },
    ignoreLocation: !1,
    ignoreFieldNorm: !1,
    fieldNormWeight: 1
  };
  var Ee = oe(oe(oe(oe({}, {
    isCaseSensitive: !1,
    includeScore: !1,
    keys: [],
    shouldSort: !0,
    sortFn: (e, t) => e.score === t.score ? e.idx < t.idx ? -1 : 1 : e.score < t.score ? -1 : 1
  }), {
    includeMatches: !1,
    findAllMatches: !1,
    minMatchCharLength: 1
  }), {
    location: 0,
    threshold: .6,
    distance: 100
  }), be);
  const Ce = /[^ ]+/g;
  class Se {
    constructor({
      getFn: e = Ee.getFn,
      fieldNormWeight: t = Ee.fieldNormWeight
    } = {}) {
      this.norm = function (e = 1, t = 3) {
        const i = new Map(),
          n = Math.pow(10, t);
        return {
          get(t) {
            const s = t.match(Ce).length;
            if (i.has(s)) return i.get(s);
            const o = 1 / Math.pow(s, .5 * e),
              r = parseFloat(Math.round(o * n) / n);
            return i.set(s, r), r;
          },
          clear() {
            i.clear();
          }
        };
      }(t, 3), this.getFn = e, this.isCreated = !1, this.setIndexRecords();
    }
    setSources(e = []) {
      this.docs = e;
    }
    setIndexRecords(e = []) {
      this.records = e;
    }
    setKeys(e = []) {
      this.keys = e, this._keysMap = {}, e.forEach((e, t) => {
        this._keysMap[e.id] = t;
      });
    }
    create() {
      !this.isCreated && this.docs.length && (this.isCreated = !0, ce(this.docs[0]) ? this.docs.forEach((e, t) => {
        this._addString(e, t);
      }) : this.docs.forEach((e, t) => {
        this._addObject(e, t);
      }), this.norm.clear());
    }
    add(e) {
      const t = this.size();
      ce(e) ? this._addString(e, t) : this._addObject(e, t);
    }
    removeAt(e) {
      this.records.splice(e, 1);
      for (let t = e, i = this.size(); t < i; t += 1) this.records[t].i -= 1;
    }
    getValueForItemAtKeyId(e, t) {
      return e[this._keysMap[t]];
    }
    size() {
      return this.records.length;
    }
    _addString(e, t) {
      if (!le(e) || ue(e)) return;
      let i = {
        v: e,
        i: t,
        n: this.norm.get(e)
      };
      this.records.push(i);
    }
    _addObject(e, t) {
      let i = {
        i: t,
        $: {}
      };
      this.keys.forEach((t, n) => {
        let s = t.getFn ? t.getFn(e) : this.getFn(e, t.path);
        if (le(s)) if (re(s)) {
          let e = [];
          const t = [{
            nestedArrIndex: -1,
            value: s
          }];
          for (; t.length;) {
            const {
              nestedArrIndex: i,
              value: n
            } = t.pop();
            if (le(n)) if (ce(n) && !ue(n)) {
              let t = {
                v: n,
                i: i,
                n: this.norm.get(n)
              };
              e.push(t);
            } else re(n) && n.forEach((e, i) => {
              t.push({
                nestedArrIndex: i,
                value: e
              });
            });
          }
          i.$[n] = e;
        } else if (ce(s) && !ue(s)) {
          let e = {
            v: s,
            n: this.norm.get(s)
          };
          i.$[n] = e;
        }
      }), this.records.push(i);
    }
    toJSON() {
      return {
        keys: this.keys,
        records: this.records
      };
    }
  }
  function we(e, t, {
    getFn: i = Ee.getFn,
    fieldNormWeight: n = Ee.fieldNormWeight
  } = {}) {
    const s = new Se({
      getFn: i,
      fieldNormWeight: n
    });
    return s.setKeys(e.map(ve)), s.setSources(t), s.create(), s;
  }
  function Ie(e, {
    errors: t = 0,
    currentLocation: i = 0,
    expectedLocation: n = 0,
    distance: s = Ee.distance,
    ignoreLocation: o = Ee.ignoreLocation
  } = {}) {
    const r = t / e.length;
    if (o) return r;
    const c = Math.abs(n - i);
    return s ? r + c / s : c ? 1 : r;
  }
  const Ae = 32;
  function xe(e) {
    let t = {};
    for (let i = 0, n = e.length; i < n; i += 1) {
      const s = e.charAt(i);
      t[s] = (t[s] || 0) | 1 << n - i - 1;
    }
    return t;
  }
  class Oe {
    constructor(e, {
      location: t = Ee.location,
      threshold: i = Ee.threshold,
      distance: n = Ee.distance,
      includeMatches: s = Ee.includeMatches,
      findAllMatches: o = Ee.findAllMatches,
      minMatchCharLength: r = Ee.minMatchCharLength,
      isCaseSensitive: c = Ee.isCaseSensitive,
      ignoreLocation: a = Ee.ignoreLocation
    } = {}) {
      if (this.options = {
        location: t,
        threshold: i,
        distance: n,
        includeMatches: s,
        findAllMatches: o,
        minMatchCharLength: r,
        isCaseSensitive: c,
        ignoreLocation: a
      }, this.pattern = c ? e : e.toLowerCase(), this.chunks = [], !this.pattern.length) return;
      const h = (e, t) => {
          this.chunks.push({
            pattern: e,
            alphabet: xe(e),
            startIndex: t
          });
        },
        l = this.pattern.length;
      if (l > Ae) {
        let e = 0;
        const t = l % Ae,
          i = l - t;
        for (; e < i;) h(this.pattern.substr(e, Ae), e), e += Ae;
        if (t) {
          const e = l - Ae;
          h(this.pattern.substr(e), e);
        }
      } else h(this.pattern, 0);
    }
    searchIn(e) {
      const {
        isCaseSensitive: t,
        includeMatches: i
      } = this.options;
      if (t || (e = e.toLowerCase()), this.pattern === e) {
        let t = {
          isMatch: !0,
          score: 0
        };
        return i && (t.indices = [[0, e.length - 1]]), t;
      }
      const {
        location: n,
        distance: s,
        threshold: o,
        findAllMatches: r,
        minMatchCharLength: c,
        ignoreLocation: a
      } = this.options;
      let h = [],
        l = 0,
        u = !1;
      this.chunks.forEach(({
        pattern: t,
        alphabet: d,
        startIndex: p
      }) => {
        const {
          isMatch: f,
          score: m,
          indices: g
        } = function (e, t, i, {
          location: n = Ee.location,
          distance: s = Ee.distance,
          threshold: o = Ee.threshold,
          findAllMatches: r = Ee.findAllMatches,
          minMatchCharLength: c = Ee.minMatchCharLength,
          includeMatches: a = Ee.includeMatches,
          ignoreLocation: h = Ee.ignoreLocation
        } = {}) {
          if (t.length > Ae) throw new Error("Pattern length exceeds max of 32.");
          const l = t.length,
            u = e.length,
            d = Math.max(0, Math.min(n, u));
          let p = o,
            f = d;
          const m = c > 1 || a,
            g = m ? Array(u) : [];
          let v;
          for (; (v = e.indexOf(t, f)) > -1;) {
            let e = Ie(t, {
              currentLocation: v,
              expectedLocation: d,
              distance: s,
              ignoreLocation: h
            });
            if (p = Math.min(e, p), f = v + l, m) {
              let e = 0;
              for (; e < l;) g[v + e] = 1, e += 1;
            }
          }
          f = -1;
          let _ = [],
            y = 1,
            b = l + u;
          const E = 1 << l - 1;
          for (let n = 0; n < l; n += 1) {
            let o = 0,
              c = b;
            for (; o < c;) Ie(t, {
              errors: n,
              currentLocation: d + c,
              expectedLocation: d,
              distance: s,
              ignoreLocation: h
            }) <= p ? o = c : b = c, c = Math.floor((b - o) / 2 + o);
            b = c;
            let a = Math.max(1, d - c + 1),
              v = r ? u : Math.min(d + c, u) + l,
              C = Array(v + 2);
            C[v + 1] = (1 << n) - 1;
            for (let o = v; o >= a; o -= 1) {
              let r = o - 1,
                c = i[e.charAt(r)];
              if (m && (g[r] = +!!c), C[o] = (C[o + 1] << 1 | 1) & c, n && (C[o] |= (_[o + 1] | _[o]) << 1 | 1 | _[o + 1]), C[o] & E && (y = Ie(t, {
                errors: n,
                currentLocation: r,
                expectedLocation: d,
                distance: s,
                ignoreLocation: h
              }), y <= p)) {
                if (p = y, f = r, f <= d) break;
                a = Math.max(1, 2 * d - f);
              }
            }
            if (Ie(t, {
              errors: n + 1,
              currentLocation: d,
              expectedLocation: d,
              distance: s,
              ignoreLocation: h
            }) > p) break;
            _ = C;
          }
          const C = {
            isMatch: f >= 0,
            score: Math.max(.001, y)
          };
          if (m) {
            const e = function (e = [], t = Ee.minMatchCharLength) {
              let i = [],
                n = -1,
                s = -1,
                o = 0;
              for (let r = e.length; o < r; o += 1) {
                let r = e[o];
                r && -1 === n ? n = o : r || -1 === n || (s = o - 1, s - n + 1 >= t && i.push([n, s]), n = -1);
              }
              return e[o - 1] && o - n >= t && i.push([n, o - 1]), i;
            }(g, c);
            e.length ? a && (C.indices = e) : C.isMatch = !1;
          }
          return C;
        }(e, t, d, {
          location: n + p,
          distance: s,
          threshold: o,
          findAllMatches: r,
          minMatchCharLength: c,
          includeMatches: i,
          ignoreLocation: a
        });
        f && (u = !0), l += m, f && g && (h = [...h, ...g]);
      });
      let d = {
        isMatch: u,
        score: u ? l / this.chunks.length : 1
      };
      return u && i && (d.indices = h), d;
    }
  }
  class Le {
    constructor(e) {
      this.pattern = e;
    }
    static isMultiMatch(e) {
      return Me(e, this.multiRegex);
    }
    static isSingleMatch(e) {
      return Me(e, this.singleRegex);
    }
    search() {}
  }
  function Me(e, t) {
    const i = e.match(t);
    return i ? i[1] : null;
  }
  class Te extends Le {
    constructor(e, {
      location: t = Ee.location,
      threshold: i = Ee.threshold,
      distance: n = Ee.distance,
      includeMatches: s = Ee.includeMatches,
      findAllMatches: o = Ee.findAllMatches,
      minMatchCharLength: r = Ee.minMatchCharLength,
      isCaseSensitive: c = Ee.isCaseSensitive,
      ignoreLocation: a = Ee.ignoreLocation
    } = {}) {
      super(e), this._bitapSearch = new Oe(e, {
        location: t,
        threshold: i,
        distance: n,
        includeMatches: s,
        findAllMatches: o,
        minMatchCharLength: r,
        isCaseSensitive: c,
        ignoreLocation: a
      });
    }
    static get type() {
      return "fuzzy";
    }
    static get multiRegex() {
      return /^"(.*)"$/;
    }
    static get singleRegex() {
      return /^(.*)$/;
    }
    search(e) {
      return this._bitapSearch.searchIn(e);
    }
  }
  class Ne extends Le {
    constructor(e) {
      super(e);
    }
    static get type() {
      return "include";
    }
    static get multiRegex() {
      return /^'"(.*)"$/;
    }
    static get singleRegex() {
      return /^'(.*)$/;
    }
    search(e) {
      let t,
        i = 0;
      const n = [],
        s = this.pattern.length;
      for (; (t = e.indexOf(this.pattern, i)) > -1;) i = t + s, n.push([t, i - 1]);
      const o = !!n.length;
      return {
        isMatch: o,
        score: o ? 0 : 1,
        indices: n
      };
    }
  }
  const ke = [class extends Le {
      constructor(e) {
        super(e);
      }
      static get type() {
        return "exact";
      }
      static get multiRegex() {
        return /^="(.*)"$/;
      }
      static get singleRegex() {
        return /^=(.*)$/;
      }
      search(e) {
        const t = e === this.pattern;
        return {
          isMatch: t,
          score: t ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        };
      }
    }, Ne, class extends Le {
      constructor(e) {
        super(e);
      }
      static get type() {
        return "prefix-exact";
      }
      static get multiRegex() {
        return /^\^"(.*)"$/;
      }
      static get singleRegex() {
        return /^\^(.*)$/;
      }
      search(e) {
        const t = e.startsWith(this.pattern);
        return {
          isMatch: t,
          score: t ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        };
      }
    }, class extends Le {
      constructor(e) {
        super(e);
      }
      static get type() {
        return "inverse-prefix-exact";
      }
      static get multiRegex() {
        return /^!\^"(.*)"$/;
      }
      static get singleRegex() {
        return /^!\^(.*)$/;
      }
      search(e) {
        const t = !e.startsWith(this.pattern);
        return {
          isMatch: t,
          score: t ? 0 : 1,
          indices: [0, e.length - 1]
        };
      }
    }, class extends Le {
      constructor(e) {
        super(e);
      }
      static get type() {
        return "inverse-suffix-exact";
      }
      static get multiRegex() {
        return /^!"(.*)"\$$/;
      }
      static get singleRegex() {
        return /^!(.*)\$$/;
      }
      search(e) {
        const t = !e.endsWith(this.pattern);
        return {
          isMatch: t,
          score: t ? 0 : 1,
          indices: [0, e.length - 1]
        };
      }
    }, class extends Le {
      constructor(e) {
        super(e);
      }
      static get type() {
        return "suffix-exact";
      }
      static get multiRegex() {
        return /^"(.*)"\$$/;
      }
      static get singleRegex() {
        return /^(.*)\$$/;
      }
      search(e) {
        const t = e.endsWith(this.pattern);
        return {
          isMatch: t,
          score: t ? 0 : 1,
          indices: [e.length - this.pattern.length, e.length - 1]
        };
      }
    }, class extends Le {
      constructor(e) {
        super(e);
      }
      static get type() {
        return "inverse-exact";
      }
      static get multiRegex() {
        return /^!"(.*)"$/;
      }
      static get singleRegex() {
        return /^!(.*)$/;
      }
      search(e) {
        const t = -1 === e.indexOf(this.pattern);
        return {
          isMatch: t,
          score: t ? 0 : 1,
          indices: [0, e.length - 1]
        };
      }
    }, Te],
    Fe = ke.length,
    De = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,
    Pe = new Set([Te.type, Ne.type]);
  const je = [];
  function Re(e, t) {
    for (let i = 0, n = je.length; i < n; i += 1) {
      let n = je[i];
      if (n.condition(e, t)) return new n(e, t);
    }
    return new Oe(e, t);
  }
  const Ke = "$and",
    Ve = "$path",
    Be = e => !(!e[Ke] && !e.$or),
    He = e => ({
      [Ke]: Object.keys(e).map(t => ({
        [t]: e[t]
      }))
    });
  function $e(e, t, {
    auto: i = !0
  } = {}) {
    const n = e => {
      let s = Object.keys(e);
      const o = (e => !!e[Ve])(e);
      if (!o && s.length > 1 && !Be(e)) return n(He(e));
      if ((e => !re(e) && he(e) && !Be(e))(e)) {
        const n = o ? e[Ve] : s[0],
          r = o ? e.$val : e[n];
        if (!ce(r)) throw new Error((e => `Invalid value for key ${e}`)(n));
        const c = {
          keyId: ye(n),
          pattern: r
        };
        return i && (c.searcher = Re(r, t)), c;
      }
      let r = {
        children: [],
        operator: s[0]
      };
      return s.forEach(t => {
        const i = e[t];
        re(i) && i.forEach(e => {
          r.children.push(n(e));
        });
      }), r;
    };
    return Be(e) || (e = He(e)), n(e);
  }
  function qe(e, t) {
    const i = e.matches;
    t.matches = [], le(i) && i.forEach(e => {
      if (!le(e.indices) || !e.indices.length) return;
      const {
        indices: i,
        value: n
      } = e;
      let s = {
        indices: i,
        value: n
      };
      e.key && (s.key = e.key.src), e.idx > -1 && (s.refIndex = e.idx), t.matches.push(s);
    });
  }
  function We(e, t) {
    t.score = e.score;
  }
  class Ue {
    constructor(e, t = {}, i) {
      this.options = oe(oe({}, Ee), t), this._keyStore = new ge(this.options.keys), this.setCollection(e, i);
    }
    setCollection(e, t) {
      if (this._docs = e, t && !(t instanceof Se)) throw new Error("Incorrect 'index' type");
      this._myIndex = t || we(this.options.keys, this._docs, {
        getFn: this.options.getFn,
        fieldNormWeight: this.options.fieldNormWeight
      });
    }
    add(e) {
      le(e) && (this._docs.push(e), this._myIndex.add(e));
    }
    remove(e = () => !1) {
      const t = [];
      for (let i = 0, n = this._docs.length; i < n; i += 1) {
        const s = this._docs[i];
        e(s, i) && (this.removeAt(i), i -= 1, n -= 1, t.push(s));
      }
      return t;
    }
    removeAt(e) {
      this._docs.splice(e, 1), this._myIndex.removeAt(e);
    }
    getIndex() {
      return this._myIndex;
    }
    search(e, {
      limit: t = -1
    } = {}) {
      const {
        includeMatches: i,
        includeScore: n,
        shouldSort: s,
        sortFn: o,
        ignoreFieldNorm: r
      } = this.options;
      let c = ce(e) ? ce(this._docs[0]) ? this._searchStringList(e) : this._searchObjectList(e) : this._searchLogical(e);
      return function (e, {
        ignoreFieldNorm: t = Ee.ignoreFieldNorm
      }) {
        e.forEach(e => {
          let i = 1;
          e.matches.forEach(({
            key: e,
            norm: n,
            score: s
          }) => {
            const o = e ? e.weight : null;
            i *= Math.pow(0 === s && o ? Number.EPSILON : s, (o || 1) * (t ? 1 : n));
          }), e.score = i;
        });
      }(c, {
        ignoreFieldNorm: r
      }), s && c.sort(o), ae(t) && t > -1 && (c = c.slice(0, t)), function (e, t, {
        includeMatches: i = Ee.includeMatches,
        includeScore: n = Ee.includeScore
      } = {}) {
        const s = [];
        return i && s.push(qe), n && s.push(We), e.map(e => {
          const {
              idx: i
            } = e,
            n = {
              item: t[i],
              refIndex: i
            };
          return s.length && s.forEach(t => {
            t(e, n);
          }), n;
        });
      }(c, this._docs, {
        includeMatches: i,
        includeScore: n
      });
    }
    _searchStringList(e) {
      const t = Re(e, this.options),
        {
          records: i
        } = this._myIndex,
        n = [];
      return i.forEach(({
        v: e,
        i: i,
        n: s
      }) => {
        if (!le(e)) return;
        const {
          isMatch: o,
          score: r,
          indices: c
        } = t.searchIn(e);
        o && n.push({
          item: e,
          idx: i,
          matches: [{
            score: r,
            value: e,
            norm: s,
            indices: c
          }]
        });
      }), n;
    }
    _searchLogical(e) {
      const t = $e(e, this.options),
        i = (e, t, n) => {
          if (!e.children) {
            const {
                keyId: i,
                searcher: s
              } = e,
              o = this._findMatches({
                key: this._keyStore.get(i),
                value: this._myIndex.getValueForItemAtKeyId(t, i),
                searcher: s
              });
            return o && o.length ? [{
              idx: n,
              item: t,
              matches: o
            }] : [];
          }
          const s = [];
          for (let o = 0, r = e.children.length; o < r; o += 1) {
            const r = i(e.children[o], t, n);
            if (r.length) s.push(...r);else if (e.operator === Ke) return [];
          }
          return s;
        },
        n = {},
        s = [];
      return this._myIndex.records.forEach(({
        $: e,
        i: o
      }) => {
        if (le(e)) {
          let r = i(t, e, o);
          r.length && (n[o] || (n[o] = {
            idx: o,
            item: e,
            matches: []
          }, s.push(n[o])), r.forEach(({
            matches: e
          }) => {
            n[o].matches.push(...e);
          }));
        }
      }), s;
    }
    _searchObjectList(e) {
      const t = Re(e, this.options),
        {
          keys: i,
          records: n
        } = this._myIndex,
        s = [];
      return n.forEach(({
        $: e,
        i: n
      }) => {
        if (!le(e)) return;
        let o = [];
        i.forEach((i, n) => {
          o.push(...this._findMatches({
            key: i,
            value: e[n],
            searcher: t
          }));
        }), o.length && s.push({
          idx: n,
          item: e,
          matches: o
        });
      }), s;
    }
    _findMatches({
      key: e,
      value: t,
      searcher: i
    }) {
      if (!le(t)) return [];
      let n = [];
      if (re(t)) t.forEach(({
        v: t,
        i: s,
        n: o
      }) => {
        if (!le(t)) return;
        const {
          isMatch: r,
          score: c,
          indices: a
        } = i.searchIn(t);
        r && n.push({
          score: c,
          key: e,
          value: t,
          idx: s,
          norm: o,
          indices: a
        });
      });else {
        const {
            v: s,
            n: o
          } = t,
          {
            isMatch: r,
            score: c,
            indices: a
          } = i.searchIn(s);
        r && n.push({
          score: c,
          key: e,
          value: s,
          norm: o,
          indices: a
        });
      }
      return n;
    }
  }
  Ue.version = "7.0.0", Ue.createIndex = we, Ue.parseIndex = function (e, {
    getFn: t = Ee.getFn,
    fieldNormWeight: i = Ee.fieldNormWeight
  } = {}) {
    const {
        keys: n,
        records: s
      } = e,
      o = new Se({
        getFn: t,
        fieldNormWeight: i
      });
    return o.setKeys(n), o.setIndexRecords(s), o;
  }, Ue.config = Ee, Ue.parseQuery = $e, function (...e) {
    je.push(...e);
  }(class {
    constructor(e, {
      isCaseSensitive: t = Ee.isCaseSensitive,
      includeMatches: i = Ee.includeMatches,
      minMatchCharLength: n = Ee.minMatchCharLength,
      ignoreLocation: s = Ee.ignoreLocation,
      findAllMatches: o = Ee.findAllMatches,
      location: r = Ee.location,
      threshold: c = Ee.threshold,
      distance: a = Ee.distance
    } = {}) {
      this.query = null, this.options = {
        isCaseSensitive: t,
        includeMatches: i,
        minMatchCharLength: n,
        findAllMatches: o,
        ignoreLocation: s,
        location: r,
        threshold: c,
        distance: a
      }, this.pattern = t ? e : e.toLowerCase(), this.query = function (e, t = {}) {
        return e.split("|").map(e => {
          let i = e.trim().split(De).filter(e => e && !!e.trim()),
            n = [];
          for (let e = 0, s = i.length; e < s; e += 1) {
            const s = i[e];
            let o = !1,
              r = -1;
            for (; !o && ++r < Fe;) {
              const e = ke[r];
              let i = e.isMultiMatch(s);
              i && (n.push(new e(i, t)), o = !0);
            }
            if (!o) for (r = -1; ++r < Fe;) {
              const e = ke[r];
              let i = e.isSingleMatch(s);
              if (i) {
                n.push(new e(i, t));
                break;
              }
            }
          }
          return n;
        });
      }(this.pattern, this.options);
    }
    static condition(e, t) {
      return t.useExtendedSearch;
    }
    searchIn(e) {
      const t = this.query;
      if (!t) return {
        isMatch: !1,
        score: 1
      };
      const {
        includeMatches: i,
        isCaseSensitive: n
      } = this.options;
      e = n ? e : e.toLowerCase();
      let s = 0,
        o = [],
        r = 0;
      for (let n = 0, c = t.length; n < c; n += 1) {
        const c = t[n];
        o.length = 0, s = 0;
        for (let t = 0, n = c.length; t < n; t += 1) {
          const n = c[t],
            {
              isMatch: a,
              indices: h,
              score: l
            } = n.search(e);
          if (!a) {
            r = 0, s = 0, o.length = 0;
            break;
          }
          s += 1, r += l, i && (Pe.has(n.constructor.type) ? o = [...o, ...h] : o.push(h));
        }
        if (s) {
          let e = {
            isMatch: !0,
            score: r / s
          };
          return i && (e.indices = o), e;
        }
      }
      return {
        isMatch: !1,
        score: 1
      };
    }
  });
  var Ge = function () {
      function e(e) {
        this._haystack = [], this._fuseOptions = i(i({}, e.fuseOptions), {
          keys: n([], e.searchFields, !0),
          includeMatches: !0
        });
      }
      return e.prototype.index = function (e) {
        this._haystack = e, this._fuse && this._fuse.setCollection(e);
      }, e.prototype.reset = function () {
        this._haystack = [], this._fuse = void 0;
      }, e.prototype.isEmptyIndex = function () {
        return !this._haystack.length;
      }, e.prototype.search = function (e) {
        return this._fuse || (this._fuse = new Ue(this._haystack, this._fuseOptions)), this._fuse.search(e).map(function (e, t) {
          return {
            item: e.item,
            score: e.score || 0,
            rank: t + 1
          };
        });
      }, e;
    }(),
    ze = function (e, t, i) {
      var n = e.dataset,
        s = t.customProperties,
        o = t.labelClass,
        r = t.labelDescription;
      o && (n.labelClass = F(o).join(" ")), r && (n.labelDescription = r), i && s && ("string" == typeof s ? n.customProperties = s : "object" != typeof s || function (e) {
        for (var t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !1;
        return !0;
      }(s) || (n.customProperties = JSON.stringify(s)));
    },
    Je = function (e, t, i) {
      var n = t && e.querySelector("label[for='".concat(t, "']")),
        s = n && n.innerText;
      s && i.setAttribute("aria-label", s);
    },
    Xe = {
      containerOuter: function (e, t, i, n, s, o, r) {
        var c = e.classNames.containerOuter,
          a = document.createElement("div");
        return P(a, c), a.dataset.type = o, t && (a.dir = t), n && (a.tabIndex = 0), i && (a.setAttribute("role", s ? "combobox" : "listbox"), s ? a.setAttribute("aria-autocomplete", "list") : r || Je(this._docRoot, this.passedElement.element.id, a), a.setAttribute("aria-haspopup", "true"), a.setAttribute("aria-expanded", "false")), r && a.setAttribute("aria-labelledby", r), a;
      },
      containerInner: function (e) {
        var t = e.classNames.containerInner,
          i = document.createElement("div");
        return P(i, t), i;
      },
      itemList: function (e, t) {
        var i = e.searchEnabled,
          n = e.classNames,
          s = n.list,
          o = n.listSingle,
          r = n.listItems,
          c = document.createElement("div");
        return P(c, s), P(c, t ? o : r), this._isSelectElement && i && c.setAttribute("role", "listbox"), c;
      },
      placeholder: function (e, t) {
        var i = e.allowHTML,
          n = e.classNames.placeholder,
          s = document.createElement("div");
        return P(s, n), N(s, i, t), s;
      },
      item: function (e, t, i) {
        var n = e.allowHTML,
          s = e.removeItemButtonAlignLeft,
          o = e.removeItemIconText,
          r = e.removeItemLabelText,
          c = e.classNames,
          a = c.item,
          h = c.button,
          l = c.highlightedState,
          u = c.itemSelectable,
          d = c.placeholder,
          p = L(t.value),
          f = document.createElement("div");
        if (P(f, a), t.labelClass) {
          var m = document.createElement("span");
          N(m, n, t.label), P(m, t.labelClass), f.appendChild(m);
        } else N(f, n, t.label);
        if (f.dataset.item = "", f.dataset.id = t.id, f.dataset.value = p, ze(f, t, !0), (t.disabled || this.containerOuter.isDisabled) && f.setAttribute("aria-disabled", "true"), this._isSelectElement && (f.setAttribute("aria-selected", "true"), f.setAttribute("role", "option")), t.placeholder && (P(f, d), f.dataset.placeholder = ""), P(f, t.highlighted ? l : u), i) {
          t.disabled && j(f, u), f.dataset.deletable = "";
          var g = document.createElement("button");
          g.type = "button", P(g, h), N(g, !0, x(o, t.value));
          var v = x(r, t.value);
          v && g.setAttribute("aria-label", v), g.dataset.button = "", s ? f.insertAdjacentElement("afterbegin", g) : f.appendChild(g);
        }
        return f;
      },
      choiceList: function (e, t) {
        var i = e.classNames.list,
          n = document.createElement("div");
        return P(n, i), t || n.setAttribute("aria-multiselectable", "true"), n.setAttribute("role", "listbox"), n;
      },
      choiceGroup: function (e, t) {
        var i = e.allowHTML,
          n = e.classNames,
          s = n.group,
          o = n.groupHeading,
          r = n.itemDisabled,
          c = t.id,
          a = t.label,
          h = t.disabled,
          l = L(a),
          u = document.createElement("div");
        P(u, s), h && P(u, r), u.setAttribute("role", "group"), u.dataset.group = "", u.dataset.id = c, u.dataset.value = l, h && u.setAttribute("aria-disabled", "true");
        var d = document.createElement("div");
        return P(d, o), N(d, i, a || ""), u.appendChild(d), u;
      },
      choice: function (e, t, i, n) {
        var s = e.allowHTML,
          o = e.classNames,
          r = o.item,
          c = o.itemChoice,
          a = o.itemSelectable,
          h = o.selectedState,
          l = o.itemDisabled,
          u = o.description,
          d = o.placeholder,
          p = t.label,
          f = L(t.value),
          m = document.createElement("div");
        m.id = t.elementId, P(m, r), P(m, c), n && "string" == typeof p && (p = T(s, p), p = {
          trusted: p += " (".concat(n, ")")
        });
        var g = m;
        if (t.labelClass) {
          var v = document.createElement("span");
          N(v, s, p), P(v, t.labelClass), g = v, m.appendChild(v);
        } else N(m, s, p);
        if (t.labelDescription) {
          var _ = "".concat(t.elementId, "-description");
          g.setAttribute("aria-describedby", _);
          var y = document.createElement("span");
          N(y, s, t.labelDescription), y.id = _, P(y, u), m.appendChild(y);
        }
        return t.selected && P(m, h), t.placeholder && P(m, d), m.setAttribute("role", t.group ? "treeitem" : "option"), m.dataset.choice = "", m.dataset.id = t.id, m.dataset.value = f, i && (m.dataset.selectText = i), t.group && (m.dataset.groupId = "".concat(t.group.id)), ze(m, t, !1), t.disabled ? (P(m, l), m.dataset.choiceDisabled = "", m.setAttribute("aria-disabled", "true")) : (P(m, a), m.dataset.choiceSelectable = ""), m;
      },
      input: function (e, t) {
        var i = e.classNames,
          n = i.input,
          s = i.inputCloned,
          o = e.labelId,
          r = document.createElement("input");
        return r.type = "search", P(r, n), P(r, s), r.autocomplete = "off", r.autocapitalize = "off", r.spellcheck = !1, r.setAttribute("aria-autocomplete", "list"), t ? r.setAttribute("aria-label", t) : o || Je(this._docRoot, this.passedElement.element.id, r), r;
      },
      dropdown: function (e) {
        var t = e.classNames,
          i = t.list,
          n = t.listDropdown,
          s = document.createElement("div");
        return P(s, i), P(s, n), s.setAttribute("aria-expanded", "false"), s;
      },
      notice: function (e, t, i) {
        var n = e.classNames,
          s = n.item,
          o = n.itemChoice,
          r = n.addChoice,
          c = n.noResults,
          a = n.noChoices,
          h = n.notice;
        void 0 === i && (i = "");
        var l = document.createElement("div");
        switch (N(l, !0, t), P(l, s), P(l, o), P(l, h), i) {
          case ie:
            P(l, r);
            break;
          case te:
            P(l, c);
            break;
          case ee:
            P(l, a);
        }
        return i === ie && (l.dataset.choiceSelectable = "", l.dataset.choice = ""), l;
      },
      option: function (e) {
        var t = L(e.label),
          i = new Option(t, e.value, !1, e.selected);
        return ze(i, e, !0), i.disabled = e.disabled, e.selected && i.setAttribute("selected", ""), i;
      }
    },
    Qe = "-ms-scroll-limit" in document.documentElement.style && "-ms-ime-align" in document.documentElement.style,
    Ye = {},
    Ze = function (e) {
      if (e) return e.dataset.id ? parseInt(e.dataset.id, 10) : void 0;
    },
    et = "[data-choice-selectable]";
  return function () {
    function e(t, n) {
      void 0 === t && (t = "[data-choice]"), void 0 === n && (n = {});
      var s = this;
      this.initialisedOK = void 0, this._hasNonChoicePlaceholder = !1, this._lastAddedChoiceId = 0, this._lastAddedGroupId = 0;
      var o = e.defaults;
      this.config = i(i(i({}, o.allOptions), o.options), n), v.forEach(function (e) {
        s.config[e] = i(i(i({}, o.allOptions[e]), o.options[e]), n[e]);
      });
      var r = this.config;
      r.silent || this._validateConfig();
      var c = r.shadowRoot || document.documentElement;
      this._docRoot = c;
      var a = "string" == typeof t ? c.querySelector(t) : t;
      if (!a || "object" != typeof a || "INPUT" !== a.tagName && !z(a)) {
        if (!a && "string" == typeof t) throw TypeError("Selector ".concat(t, " failed to find an element"));
        throw TypeError("Expected one of the following types text|select-one|select-multiple");
      }
      var h = a.type,
        l = "text" === h;
      (l || 1 !== r.maxItemCount) && (r.singleModeForMultiSelect = !1), r.singleModeForMultiSelect && (h = y);
      var u = h === _,
        d = h === y,
        p = u || d;
      if (this._elementType = h, this._isTextElement = l, this._isSelectOneElement = u, this._isSelectMultipleElement = d, this._isSelectElement = u || d, this._canAddUserChoices = l && r.addItems || p && r.addChoices, "boolean" != typeof r.renderSelectedChoices && (r.renderSelectedChoices = "always" === r.renderSelectedChoices || u), r.closeDropdownOnSelect = "auto" === r.closeDropdownOnSelect ? l || u || r.singleModeForMultiSelect : W(r.closeDropdownOnSelect), r.placeholder && (r.placeholderValue ? this._hasNonChoicePlaceholder = !0 : a.dataset.placeholder && (this._hasNonChoicePlaceholder = !0, r.placeholderValue = a.dataset.placeholder)), n.addItemFilter && "function" != typeof n.addItemFilter) {
        var f = n.addItemFilter instanceof RegExp ? n.addItemFilter : new RegExp(n.addItemFilter);
        r.addItemFilter = f.test.bind(f);
      }
      if (this.passedElement = this._isTextElement ? new q({
        element: a,
        classNames: r.classNames
      }) : new J({
        element: a,
        classNames: r.classNames,
        template: function (e) {
          return s._templates.option(e);
        },
        extractPlaceholder: r.placeholder && !this._hasNonChoicePlaceholder
      }), this.initialised = !1, this._store = new Z(r), this._currentValue = "", r.searchEnabled = !l && r.searchEnabled || d, this._canSearch = r.searchEnabled, this._isScrollingOnIe = !1, this._highlightPosition = 0, this._wasTap = !0, this._placeholderValue = this._generatePlaceholderValue(), this._baseId = function (e) {
        var t = e.id || e.name && "".concat(e.name, "-").concat(w(2)) || w(4);
        return t = t.replace(/(:|\.|\[|\]|,)/g, ""), "".concat("choices-", "-").concat(t);
      }(a), this._direction = a.dir, !this._direction) {
        var m = window.getComputedStyle(a).direction;
        m !== window.getComputedStyle(document.documentElement).direction && (this._direction = m);
      }
      if (this._idNames = {
        itemChoice: "item-choice"
      }, this._templates = o.templates, this._render = this._render.bind(this), this._onFocus = this._onFocus.bind(this), this._onBlur = this._onBlur.bind(this), this._onKeyUp = this._onKeyUp.bind(this), this._onKeyDown = this._onKeyDown.bind(this), this._onInput = this._onInput.bind(this), this._onClick = this._onClick.bind(this), this._onTouchMove = this._onTouchMove.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._onMouseDown = this._onMouseDown.bind(this), this._onMouseOver = this._onMouseOver.bind(this), this._onFormReset = this._onFormReset.bind(this), this._onSelectKey = this._onSelectKey.bind(this), this._onEnterKey = this._onEnterKey.bind(this), this._onEscapeKey = this._onEscapeKey.bind(this), this._onDirectionKey = this._onDirectionKey.bind(this), this._onDeleteKey = this._onDeleteKey.bind(this), this.passedElement.isActive) return r.silent || console.warn("Trying to initialise Choices on element already initialised", {
        element: t
      }), this.initialised = !0, void (this.initialisedOK = !1);
      this.init(), this._initialItems = this._store.items.map(function (e) {
        return e.value;
      });
    }
    return Object.defineProperty(e, "defaults", {
      get: function () {
        return Object.preventExtensions({
          get options() {
            return Ye;
          },
          get allOptions() {
            return X;
          },
          get templates() {
            return Xe;
          }
        });
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.init = function () {
      if (!this.initialised && void 0 === this.initialisedOK) {
        this._searcher = new Ge(this.config), this._loadChoices(), this._createTemplates(), this._createElements(), this._createStructure(), this._isTextElement && !this.config.addItems || this.passedElement.element.hasAttribute("disabled") || this.passedElement.element.closest("fieldset:disabled") ? this.disable() : (this.enable(), this._addEventListeners()), this._initStore(), this.initialised = !0, this.initialisedOK = !0;
        var e = this.config.callbackOnInit;
        "function" == typeof e && e.call(this);
      }
    }, e.prototype.destroy = function () {
      this.initialised && (this._removeEventListeners(), this.passedElement.reveal(), this.containerOuter.unwrap(this.passedElement.element), this._store._listeners = [], this.clearStore(!1), this._stopSearch(), this._templates = e.defaults.templates, this.initialised = !1, this.initialisedOK = void 0);
    }, e.prototype.enable = function () {
      return this.passedElement.isDisabled && this.passedElement.enable(), this.containerOuter.isDisabled && (this._addEventListeners(), this.input.enable(), this.containerOuter.enable()), this;
    }, e.prototype.disable = function () {
      return this.passedElement.isDisabled || this.passedElement.disable(), this.containerOuter.isDisabled || (this._removeEventListeners(), this.input.disable(), this.containerOuter.disable()), this;
    }, e.prototype.highlightItem = function (e, t) {
      if (void 0 === t && (t = !0), !e || !e.id) return this;
      var i = this._store.items.find(function (t) {
        return t.id === e.id;
      });
      return !i || i.highlighted || (this._store.dispatch(S(i, !0)), t && this.passedElement.triggerEvent(g, this._getChoiceForOutput(i))), this;
    }, e.prototype.unhighlightItem = function (e, t) {
      if (void 0 === t && (t = !0), !e || !e.id) return this;
      var i = this._store.items.find(function (t) {
        return t.id === e.id;
      });
      return i && i.highlighted ? (this._store.dispatch(S(i, !1)), t && this.passedElement.triggerEvent("unhighlightItem", this._getChoiceForOutput(i)), this) : this;
    }, e.prototype.highlightAll = function () {
      var e = this;
      return this._store.withTxn(function () {
        e._store.items.forEach(function (t) {
          t.highlighted || (e._store.dispatch(S(t, !0)), e.passedElement.triggerEvent(g, e._getChoiceForOutput(t)));
        });
      }), this;
    }, e.prototype.unhighlightAll = function () {
      var e = this;
      return this._store.withTxn(function () {
        e._store.items.forEach(function (t) {
          t.highlighted && (e._store.dispatch(S(t, !1)), e.passedElement.triggerEvent(g, e._getChoiceForOutput(t)));
        });
      }), this;
    }, e.prototype.removeActiveItemsByValue = function (e) {
      var t = this;
      return this._store.withTxn(function () {
        t._store.items.filter(function (t) {
          return t.value === e;
        }).forEach(function (e) {
          return t._removeItem(e);
        });
      }), this;
    }, e.prototype.removeActiveItems = function (e) {
      var t = this;
      return this._store.withTxn(function () {
        t._store.items.filter(function (t) {
          return t.id !== e;
        }).forEach(function (e) {
          return t._removeItem(e);
        });
      }), this;
    }, e.prototype.removeHighlightedItems = function (e) {
      var t = this;
      return void 0 === e && (e = !1), this._store.withTxn(function () {
        t._store.highlightedActiveItems.forEach(function (i) {
          t._removeItem(i), e && t._triggerChange(i.value);
        });
      }), this;
    }, e.prototype.showDropdown = function (e) {
      var t = this;
      return this.dropdown.isActive || (void 0 === e && (e = !this._canSearch), requestAnimationFrame(function () {
        t.dropdown.show();
        var i = t.dropdown.element.getBoundingClientRect();
        t.containerOuter.open(i.bottom, i.height), e || t.input.focus(), t.passedElement.triggerEvent("showDropdown");
      })), this;
    }, e.prototype.hideDropdown = function (e) {
      var t = this;
      return this.dropdown.isActive ? (requestAnimationFrame(function () {
        t.dropdown.hide(), t.containerOuter.close(), !e && t._canSearch && (t.input.removeActiveDescendant(), t.input.blur()), t.passedElement.triggerEvent("hideDropdown");
      }), this) : this;
    }, e.prototype.getValue = function (e) {
      var t = this,
        i = this._store.items.map(function (i) {
          return e ? i.value : t._getChoiceForOutput(i);
        });
      return this._isSelectOneElement || this.config.singleModeForMultiSelect ? i[0] : i;
    }, e.prototype.setValue = function (e) {
      var t = this;
      return this.initialisedOK ? (this._store.withTxn(function () {
        e.forEach(function (e) {
          e && t._addChoice(G(e, !1));
        });
      }), this._searcher.reset(), this) : (this._warnChoicesInitFailed("setValue"), this);
    }, e.prototype.setChoiceByValue = function (e) {
      var t = this;
      return this.initialisedOK ? (this._isTextElement || (this._store.withTxn(function () {
        (Array.isArray(e) ? e : [e]).forEach(function (e) {
          return t._findAndSelectChoiceByValue(e);
        }), t.unhighlightAll();
      }), this._searcher.reset()), this) : (this._warnChoicesInitFailed("setChoiceByValue"), this);
    }, e.prototype.setChoices = function (e, t, n, s, o, r) {
      var c = this;
      if (void 0 === e && (e = []), void 0 === t && (t = "value"), void 0 === n && (n = "label"), void 0 === s && (s = !1), void 0 === o && (o = !0), void 0 === r && (r = !1), !this.initialisedOK) return this._warnChoicesInitFailed("setChoices"), this;
      if (!this._isSelectElement) throw new TypeError("setChoices can't be used with INPUT based Choices");
      if ("string" != typeof t || !t) throw new TypeError("value parameter must be a name of 'value' field in passed objects");
      if ("function" == typeof e) {
        var a = e(this);
        if ("function" == typeof Promise && a instanceof Promise) return new Promise(function (e) {
          return requestAnimationFrame(e);
        }).then(function () {
          return c._handleLoadingState(!0);
        }).then(function () {
          return a;
        }).then(function (e) {
          return c.setChoices(e, t, n, s, o, r);
        }).catch(function (e) {
          c.config.silent || console.error(e);
        }).then(function () {
          return c._handleLoadingState(!1);
        }).then(function () {
          return c;
        });
        if (!Array.isArray(a)) throw new TypeError(".setChoices first argument function must return either array of choices or Promise, got: ".concat(typeof a));
        return this.setChoices(a, t, n, !1);
      }
      if (!Array.isArray(e)) throw new TypeError(".setChoices must be called either with array of choices with a function resulting into Promise of array of choices");
      return this.containerOuter.removeLoadingState(), this._store.withTxn(function () {
        o && (c._isSearching = !1), s && c.clearChoices(!0, r);
        var a = "value" === t,
          h = "label" === n;
        e.forEach(function (e) {
          if ("choices" in e) {
            var s = e;
            h || (s = i(i({}, s), {
              label: s[n]
            })), c._addGroup(G(s, !0));
          } else {
            var o = e;
            h && a || (o = i(i({}, o), {
              value: o[t],
              label: o[n]
            }));
            var r = G(o, !1);
            c._addChoice(r), r.placeholder && !c._hasNonChoicePlaceholder && (c._placeholderValue = M(r.label));
          }
        }), c.unhighlightAll();
      }), this._searcher.reset(), this;
    }, e.prototype.refresh = function (e, t, i) {
      var n = this;
      return void 0 === e && (e = !1), void 0 === t && (t = !1), void 0 === i && (i = !1), this._isSelectElement ? (this._store.withTxn(function () {
        var s = n.passedElement.optionsAsChoices(),
          o = {};
        i || n._store.items.forEach(function (e) {
          e.id && e.active && e.selected && (o[e.value] = !0);
        }), n.clearStore(!1);
        var r = function (e) {
          i ? n._store.dispatch(C(e)) : o[e.value] && (e.selected = !0);
        };
        s.forEach(function (e) {
          "choices" in e ? e.choices.forEach(r) : r(e);
        }), n._addPredefinedChoices(s, t, e), n._isSearching && n._searchChoices(n.input.value);
      }), this) : (this.config.silent || console.warn("refresh method can only be used on choices backed by a <select> element"), this);
    }, e.prototype.removeChoice = function (e) {
      var t = this._store.choices.find(function (t) {
        return t.value === e;
      });
      return t ? (this._clearNotice(), this._store.dispatch(function (e) {
        return {
          type: r,
          choice: e
        };
      }(t)), this._searcher.reset(), t.selected && this.passedElement.triggerEvent(m, this._getChoiceForOutput(t)), this) : this;
    }, e.prototype.clearChoices = function (e, t) {
      var i = this;
      return void 0 === e && (e = !0), void 0 === t && (t = !1), e && (t ? this.passedElement.element.replaceChildren("") : this.passedElement.element.querySelectorAll(":not([selected])").forEach(function (e) {
        e.remove();
      })), this.itemList.element.replaceChildren(""), this.choiceList.element.replaceChildren(""), this._clearNotice(), this._store.withTxn(function () {
        var e = t ? [] : i._store.items;
        i._store.reset(), e.forEach(function (e) {
          i._store.dispatch(b(e)), i._store.dispatch(E(e));
        });
      }), this._searcher.reset(), this;
    }, e.prototype.clearStore = function (e) {
      return void 0 === e && (e = !0), this.clearChoices(e, !0), this._stopSearch(), this._lastAddedChoiceId = 0, this._lastAddedGroupId = 0, this;
    }, e.prototype.clearInput = function () {
      return this.input.clear(!this._isSelectOneElement), this._stopSearch(), this;
    }, e.prototype._validateConfig = function () {
      var e,
        t,
        i,
        n = this.config,
        s = (e = X, t = Object.keys(n).sort(), i = Object.keys(e).sort(), t.filter(function (e) {
          return i.indexOf(e) < 0;
        }));
      s.length && console.warn("Unknown config option(s) passed", s.join(", ")), n.allowHTML && n.allowHtmlUserInput && (n.addItems && console.warn("Warning: allowHTML/allowHtmlUserInput/addItems all being true is strongly not recommended and may lead to XSS attacks"), n.addChoices && console.warn("Warning: allowHTML/allowHtmlUserInput/addChoices all being true is strongly not recommended and may lead to XSS attacks"));
    }, e.prototype._render = function (e) {
      void 0 === e && (e = {
        choices: !0,
        groups: !0,
        items: !0
      }), this._store.inTxn() || (this._isSelectElement && (e.choices || e.groups) && this._renderChoices(), e.items && this._renderItems());
    }, e.prototype._renderChoices = function () {
      var e = this;
      if (this._canAddItems()) {
        var t = this.config,
          i = this._isSearching,
          n = this._store,
          s = n.activeGroups,
          o = n.activeChoices,
          r = 0;
        if (i && t.searchResultLimit > 0 ? r = t.searchResultLimit : t.renderChoiceLimit > 0 && (r = t.renderChoiceLimit), this._isSelectElement) {
          var c = o.filter(function (e) {
            return !e.element;
          });
          c.length && this.passedElement.addOptions(c);
        }
        var a = document.createDocumentFragment(),
          h = function (e) {
            return e.filter(function (e) {
              return !e.placeholder && (i ? !!e.rank : t.renderSelectedChoices || !e.selected);
            });
          },
          l = !1,
          u = function (n, s, o) {
            i ? n.sort(k) : t.shouldSort && n.sort(t.sorter);
            var c = n.length;
            c = !s && r && c > r ? r : c, c--, n.every(function (n, s) {
              var r = n.choiceEl || e._templates.choice(t, n, t.itemSelectText, o);
              return n.choiceEl = r, a.appendChild(r), !i && n.selected || (l = !0), s < c;
            });
          };
        o.length && (t.resetScrollPosition && requestAnimationFrame(function () {
          return e.choiceList.scrollToTop();
        }), this._hasNonChoicePlaceholder || i || !this._isSelectOneElement || u(o.filter(function (e) {
          return e.placeholder && !e.group;
        }), !1, void 0), s.length && !i ? (t.shouldSort && s.sort(t.sorter), u(o.filter(function (e) {
          return !e.placeholder && !e.group;
        }), !1, void 0), s.forEach(function (n) {
          var s = h(n.choices);
          if (s.length) {
            if (n.label) {
              var o = n.groupEl || e._templates.choiceGroup(e.config, n);
              n.groupEl = o, o.remove(), a.appendChild(o);
            }
            u(s, !0, t.appendGroupInSearch && i ? n.label : void 0);
          }
        })) : u(h(o), !1, void 0)), l || !i && a.children.length && t.renderSelectedChoices || (this._notice || (this._notice = {
          text: O(i ? t.noResultsText : t.noChoicesText),
          type: i ? te : ee
        }), a.replaceChildren("")), this._renderNotice(a), this.choiceList.element.replaceChildren(a), l && this._highlightChoice();
      }
    }, e.prototype._renderItems = function () {
      var e = this,
        t = this._store.items || [],
        i = this.itemList.element,
        n = this.config,
        s = document.createDocumentFragment(),
        o = function (e) {
          return i.querySelector('[data-item][data-id="'.concat(e.id, '"]'));
        },
        r = function (t) {
          var i = t.itemEl;
          i && i.parentElement || (i = o(t) || e._templates.item(n, t, n.removeItemButton), t.itemEl = i, s.appendChild(i));
        };
      t.forEach(r);
      var c = !!s.childNodes.length;
      if (this._isSelectOneElement) {
        var a = i.children.length;
        if (c || a > 1) {
          var h = i.querySelector(D(n.classNames.placeholder));
          h && h.remove();
        } else c || a || !this._placeholderValue || (c = !0, r(G({
          selected: !0,
          value: "",
          label: this._placeholderValue,
          placeholder: !0
        }, !1)));
      }
      c && (i.append(s), n.shouldSortItems && !this._isSelectOneElement && (t.sort(n.sorter), t.forEach(function (e) {
        var t = o(e);
        t && (t.remove(), s.append(t));
      }), i.append(s))), this._isTextElement && (this.passedElement.value = t.map(function (e) {
        return e.value;
      }).join(n.delimiter));
    }, e.prototype._displayNotice = function (e, t, i) {
      void 0 === i && (i = !0);
      var n = this._notice;
      n && (n.type === t && n.text === e || n.type === ie && (t === te || t === ee)) ? i && this.showDropdown(!0) : (this._clearNotice(), this._notice = e ? {
        text: e,
        type: t
      } : void 0, this._renderNotice(), i && e && this.showDropdown(!0));
    }, e.prototype._clearNotice = function () {
      if (this._notice) {
        var e = this.choiceList.element.querySelector(D(this.config.classNames.notice));
        e && e.remove(), this._notice = void 0;
      }
    }, e.prototype._renderNotice = function (e) {
      var t = this._notice;
      if (t) {
        var i = this._templates.notice(this.config, t.text, t.type);
        e ? e.append(i) : this.choiceList.prepend(i);
      }
    }, e.prototype._getChoiceForOutput = function (e, t) {
      return {
        id: e.id,
        highlighted: e.highlighted,
        labelClass: e.labelClass,
        labelDescription: e.labelDescription,
        customProperties: e.customProperties,
        disabled: e.disabled,
        active: e.active,
        label: e.label,
        placeholder: e.placeholder,
        value: e.value,
        groupValue: e.group ? e.group.label : void 0,
        element: e.element,
        keyCode: t
      };
    }, e.prototype._triggerChange = function (e) {
      null != e && this.passedElement.triggerEvent("change", {
        value: e
      });
    }, e.prototype._handleButtonAction = function (e) {
      var t = this,
        i = this._store.items;
      if (i.length && this.config.removeItems && this.config.removeItemButton) {
        var n = e && Ze(e.parentElement),
          s = n && i.find(function (e) {
            return e.id === n;
          });
        s && this._store.withTxn(function () {
          if (t._removeItem(s), t._triggerChange(s.value), t._isSelectOneElement && !t._hasNonChoicePlaceholder) {
            var e = (t.config.shouldSort ? t._store.choices.reverse() : t._store.choices).find(function (e) {
              return e.placeholder;
            });
            e && (t._addItem(e), t.unhighlightAll(), e.value && t._triggerChange(e.value));
          }
        });
      }
    }, e.prototype._handleItemAction = function (e, t) {
      var i = this;
      void 0 === t && (t = !1);
      var n = this._store.items;
      if (n.length && this.config.removeItems && !this._isSelectOneElement) {
        var s = Ze(e);
        s && (n.forEach(function (e) {
          e.id !== s || e.highlighted ? !t && e.highlighted && i.unhighlightItem(e) : i.highlightItem(e);
        }), this.input.focus());
      }
    }, e.prototype._handleChoiceAction = function (e) {
      var t = this,
        i = Ze(e),
        n = i && this._store.getChoiceById(i);
      if (!n || n.disabled) return !1;
      var s = this.dropdown.isActive;
      if (!n.selected) {
        if (!this._canAddItems()) return !0;
        this._store.withTxn(function () {
          t._addItem(n, !0, !0), t.clearInput(), t.unhighlightAll();
        }), this._triggerChange(n.value);
      }
      return s && this.config.closeDropdownOnSelect && (this.hideDropdown(!0), this.containerOuter.element.focus()), !0;
    }, e.prototype._handleBackspace = function (e) {
      var t = this.config;
      if (t.removeItems && e.length) {
        var i = e[e.length - 1],
          n = e.some(function (e) {
            return e.highlighted;
          });
        t.editItems && !n && i ? (this.input.value = i.value, this.input.setWidth(), this._removeItem(i), this._triggerChange(i.value)) : (n || this.highlightItem(i, !1), this.removeHighlightedItems(!0));
      }
    }, e.prototype._loadChoices = function () {
      var e,
        t = this,
        i = this.config;
      if (this._isTextElement) {
        if (this._presetChoices = i.items.map(function (e) {
          return G(e, !1);
        }), this.passedElement.value) {
          var n = this.passedElement.value.split(i.delimiter).map(function (e) {
            return G(e, !1, t.config.allowHtmlUserInput);
          });
          this._presetChoices = this._presetChoices.concat(n);
        }
        this._presetChoices.forEach(function (e) {
          e.selected = !0;
        });
      } else if (this._isSelectElement) {
        this._presetChoices = i.choices.map(function (e) {
          return G(e, !0);
        });
        var s = this.passedElement.optionsAsChoices();
        s && (e = this._presetChoices).push.apply(e, s);
      }
    }, e.prototype._handleLoadingState = function (e) {
      void 0 === e && (e = !0);
      var t = this.itemList.element;
      e ? (this.disable(), this.containerOuter.addLoadingState(), this._isSelectOneElement ? t.replaceChildren(this._templates.placeholder(this.config, this.config.loadingText)) : this.input.placeholder = this.config.loadingText) : (this.enable(), this.containerOuter.removeLoadingState(), this._isSelectOneElement ? (t.replaceChildren(""), this._render()) : this.input.placeholder = this._placeholderValue || "");
    }, e.prototype._handleSearch = function (e) {
      if (this.input.isFocussed) if (null != e && e.length >= this.config.searchFloor) {
        var t = this.config.searchChoices ? this._searchChoices(e) : 0;
        null !== t && this.passedElement.triggerEvent(f, {
          value: e,
          resultCount: t
        });
      } else this._store.choices.some(function (e) {
        return !e.active;
      }) && this._stopSearch();
    }, e.prototype._canAddItems = function () {
      var e = this.config,
        t = e.maxItemCount,
        i = e.maxItemText;
      return !e.singleModeForMultiSelect && t > 0 && t <= this._store.items.length ? (this.choiceList.element.replaceChildren(""), this._notice = void 0, this._displayNotice("function" == typeof i ? i(t) : i, ie), !1) : (this._notice && this._notice.type === ie && this._clearNotice(), !0);
    }, e.prototype._canCreateItem = function (e) {
      var t = this.config,
        i = !0,
        n = "";
      if (i && "function" == typeof t.addItemFilter && !t.addItemFilter(e) && (i = !1, n = x(t.customAddItemText, e)), i && this._store.choices.find(function (i) {
        return t.valueComparer(i.value, e);
      })) {
        if (this._isSelectElement) return this._displayNotice("", ie), !1;
        t.duplicateItemsAllowed || (i = !1, n = x(t.uniqueItemText, e));
      }
      return i && (n = x(t.addItemText, e)), n && this._displayNotice(n, ie), i;
    }, e.prototype._searchChoices = function (e) {
      var t = e.trim().replace(/\s{2,}/, " ");
      if (!t.length || t === this._currentValue) return null;
      var i = this._searcher;
      i.isEmptyIndex() && i.index(this._store.searchableChoices);
      var n = i.search(t);
      this._currentValue = t, this._highlightPosition = 0, this._isSearching = !0;
      var s = this._notice;
      return (s && s.type) !== ie && (n.length ? this._clearNotice() : this._displayNotice(O(this.config.noResultsText), te)), this._store.dispatch(function (e) {
        return {
          type: c,
          results: e
        };
      }(n)), n.length;
    }, e.prototype._stopSearch = function () {
      this._isSearching && (this._currentValue = "", this._isSearching = !1, this._clearNotice(), this._store.dispatch({
        type: a,
        active: !0
      }), this.passedElement.triggerEvent(f, {
        value: "",
        resultCount: 0
      }));
    }, e.prototype._addEventListeners = function () {
      var e = this._docRoot,
        t = this.containerOuter.element,
        i = this.input.element;
      e.addEventListener("touchend", this._onTouchEnd, !0), t.addEventListener("keydown", this._onKeyDown, !0), t.addEventListener("mousedown", this._onMouseDown, !0), e.addEventListener("click", this._onClick, {
        passive: !0
      }), e.addEventListener("touchmove", this._onTouchMove, {
        passive: !0
      }), this.dropdown.element.addEventListener("mouseover", this._onMouseOver, {
        passive: !0
      }), this._isSelectOneElement && (t.addEventListener("focus", this._onFocus, {
        passive: !0
      }), t.addEventListener("blur", this._onBlur, {
        passive: !0
      })), i.addEventListener("keyup", this._onKeyUp, {
        passive: !0
      }), i.addEventListener("input", this._onInput, {
        passive: !0
      }), i.addEventListener("focus", this._onFocus, {
        passive: !0
      }), i.addEventListener("blur", this._onBlur, {
        passive: !0
      }), i.form && i.form.addEventListener("reset", this._onFormReset, {
        passive: !0
      }), this.input.addEventListeners();
    }, e.prototype._removeEventListeners = function () {
      var e = this._docRoot,
        t = this.containerOuter.element,
        i = this.input.element;
      e.removeEventListener("touchend", this._onTouchEnd, !0), t.removeEventListener("keydown", this._onKeyDown, !0), t.removeEventListener("mousedown", this._onMouseDown, !0), e.removeEventListener("click", this._onClick), e.removeEventListener("touchmove", this._onTouchMove), this.dropdown.element.removeEventListener("mouseover", this._onMouseOver), this._isSelectOneElement && (t.removeEventListener("focus", this._onFocus), t.removeEventListener("blur", this._onBlur)), i.removeEventListener("keyup", this._onKeyUp), i.removeEventListener("input", this._onInput), i.removeEventListener("focus", this._onFocus), i.removeEventListener("blur", this._onBlur), i.form && i.form.removeEventListener("reset", this._onFormReset), this.input.removeEventListeners();
    }, e.prototype._onKeyDown = function (e) {
      var t = e.keyCode,
        i = this.dropdown.isActive,
        n = 1 === e.key.length || 2 === e.key.length && e.key.charCodeAt(0) >= 55296 || "Unidentified" === e.key;
      switch (this._isTextElement || i || 27 === t || 9 === t || 16 === t || (this.showDropdown(), !this.input.isFocussed && n && (this.input.value += e.key, " " === e.key && e.preventDefault())), t) {
        case 65:
          return this._onSelectKey(e, this.itemList.element.hasChildNodes());
        case 13:
          return this._onEnterKey(e, i);
        case 27:
          return this._onEscapeKey(e, i);
        case 38:
        case 33:
        case 40:
        case 34:
          return this._onDirectionKey(e, i);
        case 8:
        case 46:
          return this._onDeleteKey(e, this._store.items, this.input.isFocussed);
      }
    }, e.prototype._onKeyUp = function () {
      this._canSearch = this.config.searchEnabled;
    }, e.prototype._onInput = function () {
      var e = this.input.value;
      e ? this._canAddItems() && (this._canSearch && this._handleSearch(e), this._canAddUserChoices && (this._canCreateItem(e), this._isSelectElement && (this._highlightPosition = 0, this._highlightChoice()))) : this._isTextElement ? this.hideDropdown(!0) : this._stopSearch();
    }, e.prototype._onSelectKey = function (e, t) {
      (e.ctrlKey || e.metaKey) && t && (this._canSearch = !1, this.config.removeItems && !this.input.value && this.input.element === document.activeElement && this.highlightAll());
    }, e.prototype._onEnterKey = function (e, t) {
      var i = this,
        n = this.input.value,
        s = e.target;
      if (e.preventDefault(), s && s.hasAttribute("data-button")) this._handleButtonAction(s);else if (t) {
        var o = this.dropdown.element.querySelector(D(this.config.classNames.highlightedState));
        if (!o || !this._handleChoiceAction(o)) if (s && n) {
          if (this._canAddItems()) {
            var r = !1;
            this._store.withTxn(function () {
              if (!(r = i._findAndSelectChoiceByValue(n, !0))) {
                if (!i._canAddUserChoices) return;
                if (!i._canCreateItem(n)) return;
                i._addChoice(G(n, !1, i.config.allowHtmlUserInput), !0, !0), r = !0;
              }
              i.clearInput(), i.unhighlightAll();
            }), r && (this._triggerChange(n), this.config.closeDropdownOnSelect && this.hideDropdown(!0));
          }
        } else this.hideDropdown(!0);
      } else (this._isSelectElement || this._notice) && this.showDropdown();
    }, e.prototype._onEscapeKey = function (e, t) {
      t && (e.stopPropagation(), this.hideDropdown(!0), this._stopSearch(), this.containerOuter.element.focus());
    }, e.prototype._onDirectionKey = function (e, t) {
      var i,
        n,
        s,
        o = e.keyCode;
      if (t || this._isSelectOneElement) {
        this.showDropdown(), this._canSearch = !1;
        var r = 40 === o || 34 === o ? 1 : -1,
          c = void 0;
        if (e.metaKey || 34 === o || 33 === o) c = this.dropdown.element.querySelector(r > 0 ? "".concat(et, ":last-of-type") : et);else {
          var a = this.dropdown.element.querySelector(D(this.config.classNames.highlightedState));
          c = a ? function (e, t, i) {
            void 0 === i && (i = 1);
            for (var n = "".concat(i > 0 ? "next" : "previous", "ElementSibling"), s = e[n]; s;) {
              if (s.matches(t)) return s;
              s = s[n];
            }
            return null;
          }(a, et, r) : this.dropdown.element.querySelector(et);
        }
        c && (i = c, n = this.choiceList.element, void 0 === (s = r) && (s = 1), (s > 0 ? n.scrollTop + n.offsetHeight >= i.offsetTop + i.offsetHeight : i.offsetTop >= n.scrollTop) || this.choiceList.scrollToChildElement(c, r), this._highlightChoice(c)), e.preventDefault();
      }
    }, e.prototype._onDeleteKey = function (e, t, i) {
      this._isSelectOneElement || e.target.value || !i || (this._handleBackspace(t), e.preventDefault());
    }, e.prototype._onTouchMove = function () {
      this._wasTap && (this._wasTap = !1);
    }, e.prototype._onTouchEnd = function (e) {
      var t = (e || e.touches[0]).target;
      this._wasTap && this.containerOuter.element.contains(t) && ((t === this.containerOuter.element || t === this.containerInner.element) && (this._isTextElement ? this.input.focus() : this._isSelectMultipleElement && this.showDropdown()), e.stopPropagation()), this._wasTap = !0;
    }, e.prototype._onMouseDown = function (e) {
      var t = e.target;
      if (t instanceof HTMLElement) {
        if (Qe && this.choiceList.element.contains(t)) {
          var i = this.choiceList.element.firstElementChild;
          this._isScrollingOnIe = "ltr" === this._direction ? e.offsetX >= i.offsetWidth : e.offsetX < i.offsetLeft;
        }
        if (t !== this.input.element) {
          var n = t.closest("[data-button],[data-item],[data-choice]");
          n instanceof HTMLElement && ("button" in n.dataset ? this._handleButtonAction(n) : "item" in n.dataset ? this._handleItemAction(n, e.shiftKey) : "choice" in n.dataset && this._handleChoiceAction(n)), e.preventDefault();
        }
      }
    }, e.prototype._onMouseOver = function (e) {
      var t = e.target;
      t instanceof HTMLElement && "choice" in t.dataset && this._highlightChoice(t);
    }, e.prototype._onClick = function (e) {
      var t = e.target,
        i = this.containerOuter;
      i.element.contains(t) ? this.dropdown.isActive || i.isDisabled ? this._isSelectOneElement && t !== this.input.element && !this.dropdown.element.contains(t) && this.hideDropdown() : this._isTextElement ? document.activeElement !== this.input.element && this.input.focus() : (this.showDropdown(), i.element.focus()) : (i.removeFocusState(), this.hideDropdown(!0), this.unhighlightAll());
    }, e.prototype._onFocus = function (e) {
      var t = e.target,
        i = this.containerOuter;
      if (t && i.element.contains(t)) {
        var n = t === this.input.element;
        this._isTextElement ? n && i.addFocusState() : this._isSelectMultipleElement ? n && (this.showDropdown(!0), i.addFocusState()) : (i.addFocusState(), n && this.showDropdown(!0));
      }
    }, e.prototype._onBlur = function (e) {
      var t = e.target,
        i = this.containerOuter;
      t && i.element.contains(t) && !this._isScrollingOnIe ? t === this.input.element ? (i.removeFocusState(), this.hideDropdown(!0), (this._isTextElement || this._isSelectMultipleElement) && this.unhighlightAll()) : t === this.containerOuter.element && (i.removeFocusState(), this._canSearch || this.hideDropdown(!0)) : (this._isScrollingOnIe = !1, this.input.element.focus());
    }, e.prototype._onFormReset = function () {
      var e = this;
      this._store.withTxn(function () {
        e.clearInput(), e.hideDropdown(), e.refresh(!1, !1, !0), e._initialItems.length && e.setChoiceByValue(e._initialItems);
      });
    }, e.prototype._highlightChoice = function (e) {
      void 0 === e && (e = null);
      var t = Array.from(this.dropdown.element.querySelectorAll(et));
      if (t.length) {
        var i = e,
          n = this.config.classNames.highlightedState;
        Array.from(this.dropdown.element.querySelectorAll(D(n))).forEach(function (e) {
          j(e, n), e.setAttribute("aria-selected", "false");
        }), i ? this._highlightPosition = t.indexOf(i) : (i = t.length > this._highlightPosition ? t[this._highlightPosition] : t[t.length - 1]) || (i = t[0]), P(i, n), i.setAttribute("aria-selected", "true"), this.passedElement.triggerEvent("highlightChoice", {
          el: i
        }), this.dropdown.isActive && (this.input.setActiveDescendant(i.id), this.containerOuter.setActiveDescendant(i.id));
      }
    }, e.prototype._addItem = function (e, t, i) {
      if (void 0 === t && (t = !0), void 0 === i && (i = !1), !e.id) throw new TypeError("item.id must be set before _addItem is called for a choice/item");
      (this.config.singleModeForMultiSelect || this._isSelectOneElement) && this.removeActiveItems(e.id), this._store.dispatch(E(e)), t && (this.passedElement.triggerEvent("addItem", this._getChoiceForOutput(e)), i && this.passedElement.triggerEvent("choice", this._getChoiceForOutput(e)));
    }, e.prototype._removeItem = function (e) {
      if (e.id) {
        this._store.dispatch(C(e));
        var t = this._notice;
        t && t.type === ee && this._clearNotice(), this.passedElement.triggerEvent(m, this._getChoiceForOutput(e));
      }
    }, e.prototype._addChoice = function (e, t, i) {
      if (void 0 === t && (t = !0), void 0 === i && (i = !1), e.id) throw new TypeError("Can not re-add a choice which has already been added");
      var n = this.config;
      if (n.duplicateItemsAllowed || !this._store.choices.find(function (t) {
        return n.valueComparer(t.value, e.value);
      })) {
        this._lastAddedChoiceId++, e.id = this._lastAddedChoiceId, e.elementId = "".concat(this._baseId, "-").concat(this._idNames.itemChoice, "-").concat(e.id);
        var s = n.prependValue,
          o = n.appendValue;
        s && (e.value = s + e.value), o && (e.value += o.toString()), (s || o) && e.element && (e.element.value = e.value), this._clearNotice(), this._store.dispatch(b(e)), e.selected && this._addItem(e, t, i);
      }
    }, e.prototype._addGroup = function (e, t) {
      var i = this;
      if (void 0 === t && (t = !0), e.id) throw new TypeError("Can not re-add a group which has already been added");
      this._store.dispatch(function (e) {
        return {
          type: l,
          group: e
        };
      }(e)), e.choices && (this._lastAddedGroupId++, e.id = this._lastAddedGroupId, e.choices.forEach(function (n) {
        n.group = e, e.disabled && (n.disabled = !0), i._addChoice(n, t);
      }));
    }, e.prototype._createTemplates = function () {
      var e = this,
        t = this.config.callbackOnCreateTemplates,
        i = {};
      "function" == typeof t && (i = t.call(this, A, T, F));
      var n = {};
      Object.keys(this._templates).forEach(function (t) {
        n[t] = t in i ? i[t].bind(e) : e._templates[t].bind(e);
      }), this._templates = n;
    }, e.prototype._createElements = function () {
      var e = this._templates,
        t = this.config,
        i = this._isSelectOneElement,
        n = t.position,
        s = t.classNames,
        o = this._elementType;
      this.containerOuter = new V({
        element: e.containerOuter(t, this._direction, this._isSelectElement, i, t.searchEnabled, o, t.labelId),
        classNames: s,
        type: o,
        position: n
      }), this.containerInner = new V({
        element: e.containerInner(t),
        classNames: s,
        type: o,
        position: n
      }), this.input = new B({
        element: e.input(t, this._placeholderValue),
        classNames: s,
        type: o,
        preventPaste: !t.paste
      }), this.choiceList = new H({
        element: e.choiceList(t, i)
      }), this.itemList = new H({
        element: e.itemList(t, i)
      }), this.dropdown = new K({
        element: e.dropdown(t),
        classNames: s,
        type: o
      });
    }, e.prototype._createStructure = function () {
      var e = this,
        t = e.containerInner,
        i = e.containerOuter,
        n = e.passedElement,
        s = this.dropdown.element;
      n.conceal(), t.wrap(n.element), i.wrap(t.element), this._isSelectOneElement ? this.input.placeholder = this.config.searchPlaceholderValue || "" : (this._placeholderValue && (this.input.placeholder = this._placeholderValue), this.input.setWidth()), i.element.appendChild(t.element), i.element.appendChild(s), t.element.appendChild(this.itemList.element), s.appendChild(this.choiceList.element), this._isSelectOneElement ? this.config.searchEnabled && s.insertBefore(this.input.element, s.firstChild) : t.element.appendChild(this.input.element), this._highlightPosition = 0, this._isSearching = !1;
    }, e.prototype._initStore = function () {
      var e = this;
      this._store.subscribe(this._render).withTxn(function () {
        e._addPredefinedChoices(e._presetChoices, e._isSelectOneElement && !e._hasNonChoicePlaceholder, !1);
      }), (!this._store.choices.length || this._isSelectOneElement && this._hasNonChoicePlaceholder) && this._render();
    }, e.prototype._addPredefinedChoices = function (e, t, i) {
      var n = this;
      void 0 === t && (t = !1), void 0 === i && (i = !0), t && -1 === e.findIndex(function (e) {
        return e.selected;
      }) && e.some(function (e) {
        return !e.disabled && !("choices" in e) && (e.selected = !0, !0);
      }), e.forEach(function (e) {
        "choices" in e ? n._isSelectElement && n._addGroup(e, i) : n._addChoice(e, i);
      });
    }, e.prototype._findAndSelectChoiceByValue = function (e, t) {
      var i = this;
      void 0 === t && (t = !1);
      var n = this._store.choices.find(function (t) {
        return i.config.valueComparer(t.value, e);
      });
      return !(!n || n.disabled || n.selected || (this._addItem(n, !0, t), 0));
    }, e.prototype._generatePlaceholderValue = function () {
      var e = this.config;
      if (!e.placeholder) return null;
      if (this._hasNonChoicePlaceholder) return e.placeholderValue;
      if (this._isSelectElement) {
        var t = this.passedElement.placeholderOption;
        return t ? t.text : null;
      }
      return null;
    }, e.prototype._warnChoicesInitFailed = function (e) {
      if (!this.config.silent) {
        if (!this.initialised) throw new TypeError("".concat(e, " called on a non-initialised instance of Choices"));
        if (!this.initialisedOK) throw new TypeError("".concat(e, " called for an element which has multiple instances of Choices initialised on it"));
      }
    }, e.version = "11.1.0", e;
  }();
});
/**
 * Swiper 11.2.10
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2025 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: June 28, 2025
 */

var Swiper = function () {
  "use strict";

  function e(e) {
    return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object;
  }
  function t(s, a) {
    void 0 === s && (s = {}), void 0 === a && (a = {});
    const i = ["__proto__", "constructor", "prototype"];
    Object.keys(a).filter(e => i.indexOf(e) < 0).forEach(i => {
      void 0 === s[i] ? s[i] = a[i] : e(a[i]) && e(s[i]) && Object.keys(a[i]).length > 0 && t(s[i], a[i]);
    });
  }
  const s = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
      blur() {},
      nodeName: ""
    },
    querySelector: () => null,
    querySelectorAll: () => [],
    getElementById: () => null,
    createEvent: () => ({
      initEvent() {}
    }),
    createElement: () => ({
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {},
      getElementsByTagName: () => []
    }),
    createElementNS: () => ({}),
    importNode: () => null,
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    }
  };
  function a() {
    const e = "undefined" != typeof document ? document : {};
    return t(e, s), e;
  }
  const i = {
    document: s,
    navigator: {
      userAgent: ""
    },
    location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
    },
    history: {
      replaceState() {},
      pushState() {},
      go() {},
      back() {}
    },
    CustomEvent: function () {
      return this;
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle: () => ({
      getPropertyValue: () => ""
    }),
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia: () => ({}),
    requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0),
    cancelAnimationFrame(e) {
      "undefined" != typeof setTimeout && clearTimeout(e);
    }
  };
  function r() {
    const e = "undefined" != typeof window ? window : {};
    return t(e, i), e;
  }
  function n(e) {
    return void 0 === e && (e = ""), e.trim().split(" ").filter(e => !!e.trim());
  }
  function l(e, t) {
    return void 0 === t && (t = 0), setTimeout(e, t);
  }
  function o() {
    return Date.now();
  }
  function d(e, t) {
    void 0 === t && (t = "x");
    const s = r();
    let a, i, n;
    const l = function (e) {
      const t = r();
      let s;
      return t.getComputedStyle && (s = t.getComputedStyle(e, null)), !s && e.currentStyle && (s = e.currentStyle), s || (s = e.style), s;
    }(e);
    return s.WebKitCSSMatrix ? (i = l.transform || l.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map(e => e.replace(",", ".")).join(", ")), n = new s.WebKitCSSMatrix("none" === i ? "" : i)) : (n = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), a = n.toString().split(",")), "x" === t && (i = s.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), "y" === t && (i = s.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), i || 0;
  }
  function c(e) {
    return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1);
  }
  function p() {
    const e = Object(arguments.length <= 0 ? void 0 : arguments[0]),
      t = ["__proto__", "constructor", "prototype"];
    for (let a = 1; a < arguments.length; a += 1) {
      const i = a < 0 || arguments.length <= a ? void 0 : arguments[a];
      if (null != i && (s = i, !("undefined" != typeof window && void 0 !== window.HTMLElement ? s instanceof HTMLElement : s && (1 === s.nodeType || 11 === s.nodeType)))) {
        const s = Object.keys(Object(i)).filter(e => t.indexOf(e) < 0);
        for (let t = 0, a = s.length; t < a; t += 1) {
          const a = s[t],
            r = Object.getOwnPropertyDescriptor(i, a);
          void 0 !== r && r.enumerable && (c(e[a]) && c(i[a]) ? i[a].__swiper__ ? e[a] = i[a] : p(e[a], i[a]) : !c(e[a]) && c(i[a]) ? (e[a] = {}, i[a].__swiper__ ? e[a] = i[a] : p(e[a], i[a])) : e[a] = i[a]);
        }
      }
    }
    var s;
    return e;
  }
  function u(e, t, s) {
    e.style.setProperty(t, s);
  }
  function m(e) {
    let {
      swiper: t,
      targetPosition: s,
      side: a
    } = e;
    const i = r(),
      n = -t.translate;
    let l,
      o = null;
    const d = t.params.speed;
    t.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(t.cssModeFrameID);
    const c = s > n ? "next" : "prev",
      p = (e, t) => "next" === c && e >= t || "prev" === c && e <= t,
      u = () => {
        l = new Date().getTime(), null === o && (o = l);
        const e = Math.max(Math.min((l - o) / d, 1), 0),
          r = .5 - Math.cos(e * Math.PI) / 2;
        let c = n + r * (s - n);
        if (p(c, s) && (c = s), t.wrapperEl.scrollTo({
          [a]: c
        }), p(c, s)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
          t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({
            [a]: c
          });
        }), void i.cancelAnimationFrame(t.cssModeFrameID);
        t.cssModeFrameID = i.requestAnimationFrame(u);
      };
    u();
  }
  function h(e) {
    return e.querySelector(".swiper-slide-transform") || e.shadowRoot && e.shadowRoot.querySelector(".swiper-slide-transform") || e;
  }
  function f(e, t) {
    void 0 === t && (t = "");
    const s = r(),
      a = [...e.children];
    return s.HTMLSlotElement && e instanceof HTMLSlotElement && a.push(...e.assignedElements()), t ? a.filter(e => e.matches(t)) : a;
  }
  function g(e) {
    try {
      return void console.warn(e);
    } catch (e) {}
  }
  function v(e, t) {
    void 0 === t && (t = []);
    const s = document.createElement(e);
    return s.classList.add(...(Array.isArray(t) ? t : n(t))), s;
  }
  function w(e) {
    const t = r(),
      s = a(),
      i = e.getBoundingClientRect(),
      n = s.body,
      l = e.clientTop || n.clientTop || 0,
      o = e.clientLeft || n.clientLeft || 0,
      d = e === t ? t.scrollY : e.scrollTop,
      c = e === t ? t.scrollX : e.scrollLeft;
    return {
      top: i.top + d - l,
      left: i.left + c - o
    };
  }
  function b(e, t) {
    return r().getComputedStyle(e, null).getPropertyValue(t);
  }
  function y(e) {
    let t,
      s = e;
    if (s) {
      for (t = 0; null !== (s = s.previousSibling);) 1 === s.nodeType && (t += 1);
      return t;
    }
  }
  function E(e, t) {
    const s = [];
    let a = e.parentElement;
    for (; a;) t ? a.matches(t) && s.push(a) : s.push(a), a = a.parentElement;
    return s;
  }
  function x(e, t) {
    t && e.addEventListener("transitionend", function s(a) {
      a.target === e && (t.call(e, a), e.removeEventListener("transitionend", s));
    });
  }
  function S(e, t, s) {
    const a = r();
    return s ? e["width" === t ? "offsetWidth" : "offsetHeight"] + parseFloat(a.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-right" : "margin-top")) + parseFloat(a.getComputedStyle(e, null).getPropertyValue("width" === t ? "margin-left" : "margin-bottom")) : e.offsetWidth;
  }
  function T(e) {
    return (Array.isArray(e) ? e : [e]).filter(e => !!e);
  }
  function M(e) {
    return t => Math.abs(t) > 0 && e.browser && e.browser.need3dFix && Math.abs(t) % 90 == 0 ? t + .001 : t;
  }
  function C(e, t) {
    void 0 === t && (t = ""), "undefined" != typeof trustedTypes ? e.innerHTML = trustedTypes.createPolicy("html", {
      createHTML: e => e
    }).createHTML(t) : e.innerHTML = t;
  }
  let P, L, I;
  function z() {
    return P || (P = function () {
      const e = r(),
        t = a();
      return {
        smoothScroll: t.documentElement && t.documentElement.style && "scrollBehavior" in t.documentElement.style,
        touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch)
      };
    }()), P;
  }
  function A(e) {
    return void 0 === e && (e = {}), L || (L = function (e) {
      let {
        userAgent: t
      } = void 0 === e ? {} : e;
      const s = z(),
        a = r(),
        i = a.navigator.platform,
        n = t || a.navigator.userAgent,
        l = {
          ios: !1,
          android: !1
        },
        o = a.screen.width,
        d = a.screen.height,
        c = n.match(/(Android);?[\s\/]+([\d.]+)?/);
      let p = n.match(/(iPad).*OS\s([\d_]+)/);
      const u = n.match(/(iPod)(.*OS\s([\d_]+))?/),
        m = !p && n.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
        h = "Win32" === i;
      let f = "MacIntel" === i;
      return !p && f && s.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${o}x${d}`) >= 0 && (p = n.match(/(Version)\/([\d.]+)/), p || (p = [0, 1, "13_0_0"]), f = !1), c && !h && (l.os = "android", l.android = !0), (p || m || u) && (l.os = "ios", l.ios = !0), l;
    }(e)), L;
  }
  function $() {
    return I || (I = function () {
      const e = r(),
        t = A();
      let s = !1;
      function a() {
        const t = e.navigator.userAgent.toLowerCase();
        return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0;
      }
      if (a()) {
        const t = String(e.navigator.userAgent);
        if (t.includes("Version/")) {
          const [e, a] = t.split("Version/")[1].split(" ")[0].split(".").map(e => Number(e));
          s = e < 16 || 16 === e && a < 2;
        }
      }
      const i = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent),
        n = a();
      return {
        isSafari: s || n,
        needPerspectiveFix: s,
        need3dFix: n || i && t.ios,
        isWebView: i
      };
    }()), I;
  }
  var k = {
    on(e, t, s) {
      const a = this;
      if (!a.eventsListeners || a.destroyed) return a;
      if ("function" != typeof t) return a;
      const i = s ? "unshift" : "push";
      return e.split(" ").forEach(e => {
        a.eventsListeners[e] || (a.eventsListeners[e] = []), a.eventsListeners[e][i](t);
      }), a;
    },
    once(e, t, s) {
      const a = this;
      if (!a.eventsListeners || a.destroyed) return a;
      if ("function" != typeof t) return a;
      function i() {
        a.off(e, i), i.__emitterProxy && delete i.__emitterProxy;
        for (var s = arguments.length, r = new Array(s), n = 0; n < s; n++) r[n] = arguments[n];
        t.apply(a, r);
      }
      return i.__emitterProxy = t, a.on(e, i, s);
    },
    onAny(e, t) {
      const s = this;
      if (!s.eventsListeners || s.destroyed) return s;
      if ("function" != typeof e) return s;
      const a = t ? "unshift" : "push";
      return s.eventsAnyListeners.indexOf(e) < 0 && s.eventsAnyListeners[a](e), s;
    },
    offAny(e) {
      const t = this;
      if (!t.eventsListeners || t.destroyed) return t;
      if (!t.eventsAnyListeners) return t;
      const s = t.eventsAnyListeners.indexOf(e);
      return s >= 0 && t.eventsAnyListeners.splice(s, 1), t;
    },
    off(e, t) {
      const s = this;
      return !s.eventsListeners || s.destroyed ? s : s.eventsListeners ? (e.split(" ").forEach(e => {
        void 0 === t ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach((a, i) => {
          (a === t || a.__emitterProxy && a.__emitterProxy === t) && s.eventsListeners[e].splice(i, 1);
        });
      }), s) : s;
    },
    emit() {
      const e = this;
      if (!e.eventsListeners || e.destroyed) return e;
      if (!e.eventsListeners) return e;
      let t, s, a;
      for (var i = arguments.length, r = new Array(i), n = 0; n < i; n++) r[n] = arguments[n];
      "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], s = r.slice(1, r.length), a = e) : (t = r[0].events, s = r[0].data, a = r[0].context || e), s.unshift(a);
      return (Array.isArray(t) ? t : t.split(" ")).forEach(t => {
        e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach(e => {
          e.apply(a, [t, ...s]);
        }), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach(e => {
          e.apply(a, s);
        });
      }), e;
    }
  };
  const O = (e, t, s) => {
    t && !e.classList.contains(s) ? e.classList.add(s) : !t && e.classList.contains(s) && e.classList.remove(s);
  };
  const D = (e, t, s) => {
    t && !e.classList.contains(s) ? e.classList.add(s) : !t && e.classList.contains(s) && e.classList.remove(s);
  };
  const G = (e, t) => {
      if (!e || e.destroyed || !e.params) return;
      const s = t.closest(e.isElement ? "swiper-slide" : `.${e.params.slideClass}`);
      if (s) {
        let t = s.querySelector(`.${e.params.lazyPreloaderClass}`);
        !t && e.isElement && (s.shadowRoot ? t = s.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`) : requestAnimationFrame(() => {
          s.shadowRoot && (t = s.shadowRoot.querySelector(`.${e.params.lazyPreloaderClass}`), t && t.remove());
        })), t && t.remove();
      }
    },
    X = (e, t) => {
      if (!e.slides[t]) return;
      const s = e.slides[t].querySelector('[loading="lazy"]');
      s && s.removeAttribute("loading");
    },
    Y = e => {
      if (!e || e.destroyed || !e.params) return;
      let t = e.params.lazyPreloadPrevNext;
      const s = e.slides.length;
      if (!s || !t || t < 0) return;
      t = Math.min(t, s);
      const a = "auto" === e.params.slidesPerView ? e.slidesPerViewDynamic() : Math.ceil(e.params.slidesPerView),
        i = e.activeIndex;
      if (e.params.grid && e.params.grid.rows > 1) {
        const s = i,
          r = [s - t];
        return r.push(...Array.from({
          length: t
        }).map((e, t) => s + a + t)), void e.slides.forEach((t, s) => {
          r.includes(t.column) && X(e, s);
        });
      }
      const r = i + a - 1;
      if (e.params.rewind || e.params.loop) for (let a = i - t; a <= r + t; a += 1) {
        const t = (a % s + s) % s;
        (t < i || t > r) && X(e, t);
      } else for (let a = Math.max(i - t, 0); a <= Math.min(r + t, s - 1); a += 1) a !== i && (a > r || a < i) && X(e, a);
    };
  var B = {
    updateSize: function () {
      const e = this;
      let t, s;
      const a = e.el;
      t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : a.clientWidth, s = void 0 !== e.params.height && null !== e.params.height ? e.params.height : a.clientHeight, 0 === t && e.isHorizontal() || 0 === s && e.isVertical() || (t = t - parseInt(b(a, "padding-left") || 0, 10) - parseInt(b(a, "padding-right") || 0, 10), s = s - parseInt(b(a, "padding-top") || 0, 10) - parseInt(b(a, "padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(s) && (s = 0), Object.assign(e, {
        width: t,
        height: s,
        size: e.isHorizontal() ? t : s
      }));
    },
    updateSlides: function () {
      const e = this;
      function t(t, s) {
        return parseFloat(t.getPropertyValue(e.getDirectionLabel(s)) || 0);
      }
      const s = e.params,
        {
          wrapperEl: a,
          slidesEl: i,
          size: r,
          rtlTranslate: n,
          wrongRTL: l
        } = e,
        o = e.virtual && s.virtual.enabled,
        d = o ? e.virtual.slides.length : e.slides.length,
        c = f(i, `.${e.params.slideClass}, swiper-slide`),
        p = o ? e.virtual.slides.length : c.length;
      let m = [];
      const h = [],
        g = [];
      let v = s.slidesOffsetBefore;
      "function" == typeof v && (v = s.slidesOffsetBefore.call(e));
      let w = s.slidesOffsetAfter;
      "function" == typeof w && (w = s.slidesOffsetAfter.call(e));
      const y = e.snapGrid.length,
        E = e.slidesGrid.length;
      let x = s.spaceBetween,
        T = -v,
        M = 0,
        C = 0;
      if (void 0 === r) return;
      "string" == typeof x && x.indexOf("%") >= 0 ? x = parseFloat(x.replace("%", "")) / 100 * r : "string" == typeof x && (x = parseFloat(x)), e.virtualSize = -x, c.forEach(e => {
        n ? e.style.marginLeft = "" : e.style.marginRight = "", e.style.marginBottom = "", e.style.marginTop = "";
      }), s.centeredSlides && s.cssMode && (u(a, "--swiper-centered-offset-before", ""), u(a, "--swiper-centered-offset-after", ""));
      const P = s.grid && s.grid.rows > 1 && e.grid;
      let L;
      P ? e.grid.initSlides(c) : e.grid && e.grid.unsetSlides();
      const I = "auto" === s.slidesPerView && s.breakpoints && Object.keys(s.breakpoints).filter(e => void 0 !== s.breakpoints[e].slidesPerView).length > 0;
      for (let a = 0; a < p; a += 1) {
        let i;
        if (L = 0, c[a] && (i = c[a]), P && e.grid.updateSlide(a, i, c), !c[a] || "none" !== b(i, "display")) {
          if ("auto" === s.slidesPerView) {
            I && (c[a].style[e.getDirectionLabel("width")] = "");
            const r = getComputedStyle(i),
              n = i.style.transform,
              l = i.style.webkitTransform;
            if (n && (i.style.transform = "none"), l && (i.style.webkitTransform = "none"), s.roundLengths) L = e.isHorizontal() ? S(i, "width", !0) : S(i, "height", !0);else {
              const e = t(r, "width"),
                s = t(r, "padding-left"),
                a = t(r, "padding-right"),
                n = t(r, "margin-left"),
                l = t(r, "margin-right"),
                o = r.getPropertyValue("box-sizing");
              if (o && "border-box" === o) L = e + n + l;else {
                const {
                  clientWidth: t,
                  offsetWidth: r
                } = i;
                L = e + s + a + n + l + (r - t);
              }
            }
            n && (i.style.transform = n), l && (i.style.webkitTransform = l), s.roundLengths && (L = Math.floor(L));
          } else L = (r - (s.slidesPerView - 1) * x) / s.slidesPerView, s.roundLengths && (L = Math.floor(L)), c[a] && (c[a].style[e.getDirectionLabel("width")] = `${L}px`);
          c[a] && (c[a].swiperSlideSize = L), g.push(L), s.centeredSlides ? (T = T + L / 2 + M / 2 + x, 0 === M && 0 !== a && (T = T - r / 2 - x), 0 === a && (T = T - r / 2 - x), Math.abs(T) < .001 && (T = 0), s.roundLengths && (T = Math.floor(T)), C % s.slidesPerGroup == 0 && m.push(T), h.push(T)) : (s.roundLengths && (T = Math.floor(T)), (C - Math.min(e.params.slidesPerGroupSkip, C)) % e.params.slidesPerGroup == 0 && m.push(T), h.push(T), T = T + L + x), e.virtualSize += L + x, M = L, C += 1;
        }
      }
      if (e.virtualSize = Math.max(e.virtualSize, r) + w, n && l && ("slide" === s.effect || "coverflow" === s.effect) && (a.style.width = `${e.virtualSize + x}px`), s.setWrapperSize && (a.style[e.getDirectionLabel("width")] = `${e.virtualSize + x}px`), P && e.grid.updateWrapperSize(L, m), !s.centeredSlides) {
        const t = [];
        for (let a = 0; a < m.length; a += 1) {
          let i = m[a];
          s.roundLengths && (i = Math.floor(i)), m[a] <= e.virtualSize - r && t.push(i);
        }
        m = t, Math.floor(e.virtualSize - r) - Math.floor(m[m.length - 1]) > 1 && m.push(e.virtualSize - r);
      }
      if (o && s.loop) {
        const t = g[0] + x;
        if (s.slidesPerGroup > 1) {
          const a = Math.ceil((e.virtual.slidesBefore + e.virtual.slidesAfter) / s.slidesPerGroup),
            i = t * s.slidesPerGroup;
          for (let e = 0; e < a; e += 1) m.push(m[m.length - 1] + i);
        }
        for (let a = 0; a < e.virtual.slidesBefore + e.virtual.slidesAfter; a += 1) 1 === s.slidesPerGroup && m.push(m[m.length - 1] + t), h.push(h[h.length - 1] + t), e.virtualSize += t;
      }
      if (0 === m.length && (m = [0]), 0 !== x) {
        const t = e.isHorizontal() && n ? "marginLeft" : e.getDirectionLabel("marginRight");
        c.filter((e, t) => !(s.cssMode && !s.loop) || t !== c.length - 1).forEach(e => {
          e.style[t] = `${x}px`;
        });
      }
      if (s.centeredSlides && s.centeredSlidesBounds) {
        let e = 0;
        g.forEach(t => {
          e += t + (x || 0);
        }), e -= x;
        const t = e > r ? e - r : 0;
        m = m.map(e => e <= 0 ? -v : e > t ? t + w : e);
      }
      if (s.centerInsufficientSlides) {
        let e = 0;
        g.forEach(t => {
          e += t + (x || 0);
        }), e -= x;
        const t = (s.slidesOffsetBefore || 0) + (s.slidesOffsetAfter || 0);
        if (e + t < r) {
          const s = (r - e - t) / 2;
          m.forEach((e, t) => {
            m[t] = e - s;
          }), h.forEach((e, t) => {
            h[t] = e + s;
          });
        }
      }
      if (Object.assign(e, {
        slides: c,
        snapGrid: m,
        slidesGrid: h,
        slidesSizesGrid: g
      }), s.centeredSlides && s.cssMode && !s.centeredSlidesBounds) {
        u(a, "--swiper-centered-offset-before", -m[0] + "px"), u(a, "--swiper-centered-offset-after", e.size / 2 - g[g.length - 1] / 2 + "px");
        const t = -e.snapGrid[0],
          s = -e.slidesGrid[0];
        e.snapGrid = e.snapGrid.map(e => e + t), e.slidesGrid = e.slidesGrid.map(e => e + s);
      }
      if (p !== d && e.emit("slidesLengthChange"), m.length !== y && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), h.length !== E && e.emit("slidesGridLengthChange"), s.watchSlidesProgress && e.updateSlidesOffset(), e.emit("slidesUpdated"), !(o || s.cssMode || "slide" !== s.effect && "fade" !== s.effect)) {
        const t = `${s.containerModifierClass}backface-hidden`,
          a = e.el.classList.contains(t);
        p <= s.maxBackfaceHiddenSlides ? a || e.el.classList.add(t) : a && e.el.classList.remove(t);
      }
    },
    updateAutoHeight: function (e) {
      const t = this,
        s = [],
        a = t.virtual && t.params.virtual.enabled;
      let i,
        r = 0;
      "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed);
      const n = e => a ? t.slides[t.getSlideIndexByData(e)] : t.slides[e];
      if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) {
        if (t.params.centeredSlides) (t.visibleSlides || []).forEach(e => {
          s.push(e);
        });else for (i = 0; i < Math.ceil(t.params.slidesPerView); i += 1) {
          const e = t.activeIndex + i;
          if (e > t.slides.length && !a) break;
          s.push(n(e));
        }
      } else s.push(n(t.activeIndex));
      for (i = 0; i < s.length; i += 1) if (void 0 !== s[i]) {
        const e = s[i].offsetHeight;
        r = e > r ? e : r;
      }
      (r || 0 === r) && (t.wrapperEl.style.height = `${r}px`);
    },
    updateSlidesOffset: function () {
      const e = this,
        t = e.slides,
        s = e.isElement ? e.isHorizontal() ? e.wrapperEl.offsetLeft : e.wrapperEl.offsetTop : 0;
      for (let a = 0; a < t.length; a += 1) t[a].swiperSlideOffset = (e.isHorizontal() ? t[a].offsetLeft : t[a].offsetTop) - s - e.cssOverflowAdjustment();
    },
    updateSlidesProgress: function (e) {
      void 0 === e && (e = this && this.translate || 0);
      const t = this,
        s = t.params,
        {
          slides: a,
          rtlTranslate: i,
          snapGrid: r
        } = t;
      if (0 === a.length) return;
      void 0 === a[0].swiperSlideOffset && t.updateSlidesOffset();
      let n = -e;
      i && (n = e), t.visibleSlidesIndexes = [], t.visibleSlides = [];
      let l = s.spaceBetween;
      "string" == typeof l && l.indexOf("%") >= 0 ? l = parseFloat(l.replace("%", "")) / 100 * t.size : "string" == typeof l && (l = parseFloat(l));
      for (let e = 0; e < a.length; e += 1) {
        const o = a[e];
        let d = o.swiperSlideOffset;
        s.cssMode && s.centeredSlides && (d -= a[0].swiperSlideOffset);
        const c = (n + (s.centeredSlides ? t.minTranslate() : 0) - d) / (o.swiperSlideSize + l),
          p = (n - r[0] + (s.centeredSlides ? t.minTranslate() : 0) - d) / (o.swiperSlideSize + l),
          u = -(n - d),
          m = u + t.slidesSizesGrid[e],
          h = u >= 0 && u <= t.size - t.slidesSizesGrid[e],
          f = u >= 0 && u < t.size - 1 || m > 1 && m <= t.size || u <= 0 && m >= t.size;
        f && (t.visibleSlides.push(o), t.visibleSlidesIndexes.push(e)), O(o, f, s.slideVisibleClass), O(o, h, s.slideFullyVisibleClass), o.progress = i ? -c : c, o.originalProgress = i ? -p : p;
      }
    },
    updateProgress: function (e) {
      const t = this;
      if (void 0 === e) {
        const s = t.rtlTranslate ? -1 : 1;
        e = t && t.translate && t.translate * s || 0;
      }
      const s = t.params,
        a = t.maxTranslate() - t.minTranslate();
      let {
        progress: i,
        isBeginning: r,
        isEnd: n,
        progressLoop: l
      } = t;
      const o = r,
        d = n;
      if (0 === a) i = 0, r = !0, n = !0;else {
        i = (e - t.minTranslate()) / a;
        const s = Math.abs(e - t.minTranslate()) < 1,
          l = Math.abs(e - t.maxTranslate()) < 1;
        r = s || i <= 0, n = l || i >= 1, s && (i = 0), l && (i = 1);
      }
      if (s.loop) {
        const s = t.getSlideIndexByData(0),
          a = t.getSlideIndexByData(t.slides.length - 1),
          i = t.slidesGrid[s],
          r = t.slidesGrid[a],
          n = t.slidesGrid[t.slidesGrid.length - 1],
          o = Math.abs(e);
        l = o >= i ? (o - i) / n : (o + n - r) / n, l > 1 && (l -= 1);
      }
      Object.assign(t, {
        progress: i,
        progressLoop: l,
        isBeginning: r,
        isEnd: n
      }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && t.updateSlidesProgress(e), r && !o && t.emit("reachBeginning toEdge"), n && !d && t.emit("reachEnd toEdge"), (o && !r || d && !n) && t.emit("fromEdge"), t.emit("progress", i);
    },
    updateSlidesClasses: function () {
      const e = this,
        {
          slides: t,
          params: s,
          slidesEl: a,
          activeIndex: i
        } = e,
        r = e.virtual && s.virtual.enabled,
        n = e.grid && s.grid && s.grid.rows > 1,
        l = e => f(a, `.${s.slideClass}${e}, swiper-slide${e}`)[0];
      let o, d, c;
      if (r) {
        if (s.loop) {
          let t = i - e.virtual.slidesBefore;
          t < 0 && (t = e.virtual.slides.length + t), t >= e.virtual.slides.length && (t -= e.virtual.slides.length), o = l(`[data-swiper-slide-index="${t}"]`);
        } else o = l(`[data-swiper-slide-index="${i}"]`);
      } else n ? (o = t.find(e => e.column === i), c = t.find(e => e.column === i + 1), d = t.find(e => e.column === i - 1)) : o = t[i];
      o && (n || (c = function (e, t) {
        const s = [];
        for (; e.nextElementSibling;) {
          const a = e.nextElementSibling;
          t ? a.matches(t) && s.push(a) : s.push(a), e = a;
        }
        return s;
      }(o, `.${s.slideClass}, swiper-slide`)[0], s.loop && !c && (c = t[0]), d = function (e, t) {
        const s = [];
        for (; e.previousElementSibling;) {
          const a = e.previousElementSibling;
          t ? a.matches(t) && s.push(a) : s.push(a), e = a;
        }
        return s;
      }(o, `.${s.slideClass}, swiper-slide`)[0], s.loop && 0 === !d && (d = t[t.length - 1]))), t.forEach(e => {
        D(e, e === o, s.slideActiveClass), D(e, e === c, s.slideNextClass), D(e, e === d, s.slidePrevClass);
      }), e.emitSlidesClasses();
    },
    updateActiveIndex: function (e) {
      const t = this,
        s = t.rtlTranslate ? t.translate : -t.translate,
        {
          snapGrid: a,
          params: i,
          activeIndex: r,
          realIndex: n,
          snapIndex: l
        } = t;
      let o,
        d = e;
      const c = e => {
        let s = e - t.virtual.slidesBefore;
        return s < 0 && (s = t.virtual.slides.length + s), s >= t.virtual.slides.length && (s -= t.virtual.slides.length), s;
      };
      if (void 0 === d && (d = function (e) {
        const {
            slidesGrid: t,
            params: s
          } = e,
          a = e.rtlTranslate ? e.translate : -e.translate;
        let i;
        for (let e = 0; e < t.length; e += 1) void 0 !== t[e + 1] ? a >= t[e] && a < t[e + 1] - (t[e + 1] - t[e]) / 2 ? i = e : a >= t[e] && a < t[e + 1] && (i = e + 1) : a >= t[e] && (i = e);
        return s.normalizeSlideIndex && (i < 0 || void 0 === i) && (i = 0), i;
      }(t)), a.indexOf(s) >= 0) o = a.indexOf(s);else {
        const e = Math.min(i.slidesPerGroupSkip, d);
        o = e + Math.floor((d - e) / i.slidesPerGroup);
      }
      if (o >= a.length && (o = a.length - 1), d === r && !t.params.loop) return void (o !== l && (t.snapIndex = o, t.emit("snapIndexChange")));
      if (d === r && t.params.loop && t.virtual && t.params.virtual.enabled) return void (t.realIndex = c(d));
      const p = t.grid && i.grid && i.grid.rows > 1;
      let u;
      if (t.virtual && i.virtual.enabled && i.loop) u = c(d);else if (p) {
        const e = t.slides.find(e => e.column === d);
        let s = parseInt(e.getAttribute("data-swiper-slide-index"), 10);
        Number.isNaN(s) && (s = Math.max(t.slides.indexOf(e), 0)), u = Math.floor(s / i.grid.rows);
      } else if (t.slides[d]) {
        const e = t.slides[d].getAttribute("data-swiper-slide-index");
        u = e ? parseInt(e, 10) : d;
      } else u = d;
      Object.assign(t, {
        previousSnapIndex: l,
        snapIndex: o,
        previousRealIndex: n,
        realIndex: u,
        previousIndex: r,
        activeIndex: d
      }), t.initialized && Y(t), t.emit("activeIndexChange"), t.emit("snapIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && (n !== u && t.emit("realIndexChange"), t.emit("slideChange"));
    },
    updateClickedSlide: function (e, t) {
      const s = this,
        a = s.params;
      let i = e.closest(`.${a.slideClass}, swiper-slide`);
      !i && s.isElement && t && t.length > 1 && t.includes(e) && [...t.slice(t.indexOf(e) + 1, t.length)].forEach(e => {
        !i && e.matches && e.matches(`.${a.slideClass}, swiper-slide`) && (i = e);
      });
      let r,
        n = !1;
      if (i) for (let e = 0; e < s.slides.length; e += 1) if (s.slides[e] === i) {
        n = !0, r = e;
        break;
      }
      if (!i || !n) return s.clickedSlide = void 0, void (s.clickedIndex = void 0);
      s.clickedSlide = i, s.virtual && s.params.virtual.enabled ? s.clickedIndex = parseInt(i.getAttribute("data-swiper-slide-index"), 10) : s.clickedIndex = r, a.slideToClickedSlide && void 0 !== s.clickedIndex && s.clickedIndex !== s.activeIndex && s.slideToClickedSlide();
    }
  };
  var H = {
    getTranslate: function (e) {
      void 0 === e && (e = this.isHorizontal() ? "x" : "y");
      const {
        params: t,
        rtlTranslate: s,
        translate: a,
        wrapperEl: i
      } = this;
      if (t.virtualTranslate) return s ? -a : a;
      if (t.cssMode) return a;
      let r = d(i, e);
      return r += this.cssOverflowAdjustment(), s && (r = -r), r || 0;
    },
    setTranslate: function (e, t) {
      const s = this,
        {
          rtlTranslate: a,
          params: i,
          wrapperEl: r,
          progress: n
        } = s;
      let l,
        o = 0,
        d = 0;
      s.isHorizontal() ? o = a ? -e : e : d = e, i.roundLengths && (o = Math.floor(o), d = Math.floor(d)), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? o : d, i.cssMode ? r[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -o : -d : i.virtualTranslate || (s.isHorizontal() ? o -= s.cssOverflowAdjustment() : d -= s.cssOverflowAdjustment(), r.style.transform = `translate3d(${o}px, ${d}px, 0px)`);
      const c = s.maxTranslate() - s.minTranslate();
      l = 0 === c ? 0 : (e - s.minTranslate()) / c, l !== n && s.updateProgress(e), s.emit("setTranslate", s.translate, t);
    },
    minTranslate: function () {
      return -this.snapGrid[0];
    },
    maxTranslate: function () {
      return -this.snapGrid[this.snapGrid.length - 1];
    },
    translateTo: function (e, t, s, a, i) {
      void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === s && (s = !0), void 0 === a && (a = !0);
      const r = this,
        {
          params: n,
          wrapperEl: l
        } = r;
      if (r.animating && n.preventInteractionOnTransition) return !1;
      const o = r.minTranslate(),
        d = r.maxTranslate();
      let c;
      if (c = a && e > o ? o : a && e < d ? d : e, r.updateProgress(c), n.cssMode) {
        const e = r.isHorizontal();
        if (0 === t) l[e ? "scrollLeft" : "scrollTop"] = -c;else {
          if (!r.support.smoothScroll) return m({
            swiper: r,
            targetPosition: -c,
            side: e ? "left" : "top"
          }), !0;
          l.scrollTo({
            [e ? "left" : "top"]: -c,
            behavior: "smooth"
          });
        }
        return !0;
      }
      return 0 === t ? (r.setTransition(0), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(c), s && (r.emit("beforeTransitionStart", t, i), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) {
        r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, r.animating = !1, s && r.emit("transitionEnd"));
      }), r.wrapperEl.addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd))), !0;
    }
  };
  function N(e) {
    let {
      swiper: t,
      runCallbacks: s,
      direction: a,
      step: i
    } = e;
    const {
      activeIndex: r,
      previousIndex: n
    } = t;
    let l = a;
    l || (l = r > n ? "next" : r < n ? "prev" : "reset"), t.emit(`transition${i}`), s && "reset" === l ? t.emit(`slideResetTransition${i}`) : s && r !== n && (t.emit(`slideChangeTransition${i}`), "next" === l ? t.emit(`slideNextTransition${i}`) : t.emit(`slidePrevTransition${i}`));
  }
  var R = {
    slideTo: function (e, t, s, a, i) {
      void 0 === e && (e = 0), void 0 === s && (s = !0), "string" == typeof e && (e = parseInt(e, 10));
      const r = this;
      let n = e;
      n < 0 && (n = 0);
      const {
        params: l,
        snapGrid: o,
        slidesGrid: d,
        previousIndex: c,
        activeIndex: p,
        rtlTranslate: u,
        wrapperEl: h,
        enabled: f
      } = r;
      if (!f && !a && !i || r.destroyed || r.animating && l.preventInteractionOnTransition) return !1;
      void 0 === t && (t = r.params.speed);
      const g = Math.min(r.params.slidesPerGroupSkip, n);
      let v = g + Math.floor((n - g) / r.params.slidesPerGroup);
      v >= o.length && (v = o.length - 1);
      const w = -o[v];
      if (l.normalizeSlideIndex) for (let e = 0; e < d.length; e += 1) {
        const t = -Math.floor(100 * w),
          s = Math.floor(100 * d[e]),
          a = Math.floor(100 * d[e + 1]);
        void 0 !== d[e + 1] ? t >= s && t < a - (a - s) / 2 ? n = e : t >= s && t < a && (n = e + 1) : t >= s && (n = e);
      }
      if (r.initialized && n !== p) {
        if (!r.allowSlideNext && (u ? w > r.translate && w > r.minTranslate() : w < r.translate && w < r.minTranslate())) return !1;
        if (!r.allowSlidePrev && w > r.translate && w > r.maxTranslate() && (p || 0) !== n) return !1;
      }
      let b;
      n !== (c || 0) && s && r.emit("beforeSlideChangeStart"), r.updateProgress(w), b = n > p ? "next" : n < p ? "prev" : "reset";
      const y = r.virtual && r.params.virtual.enabled;
      if (!(y && i) && (u && -w === r.translate || !u && w === r.translate)) return r.updateActiveIndex(n), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== l.effect && r.setTranslate(w), "reset" !== b && (r.transitionStart(s, b), r.transitionEnd(s, b)), !1;
      if (l.cssMode) {
        const e = r.isHorizontal(),
          s = u ? w : -w;
        if (0 === t) y && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), y && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => {
          h[e ? "scrollLeft" : "scrollTop"] = s;
        })) : h[e ? "scrollLeft" : "scrollTop"] = s, y && requestAnimationFrame(() => {
          r.wrapperEl.style.scrollSnapType = "", r._immediateVirtual = !1;
        });else {
          if (!r.support.smoothScroll) return m({
            swiper: r,
            targetPosition: s,
            side: e ? "left" : "top"
          }), !0;
          h.scrollTo({
            [e ? "left" : "top"]: s,
            behavior: "smooth"
          });
        }
        return !0;
      }
      const E = $().isSafari;
      return y && !i && E && r.isElement && r.virtual.update(!1, !1, n), r.setTransition(t), r.setTranslate(w), r.updateActiveIndex(n), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, a), r.transitionStart(s, b), 0 === t ? r.transitionEnd(s, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) {
        r && !r.destroyed && e.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(s, b));
      }), r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)), !0;
    },
    slideToLoop: function (e, t, s, a) {
      if (void 0 === e && (e = 0), void 0 === s && (s = !0), "string" == typeof e) {
        e = parseInt(e, 10);
      }
      const i = this;
      if (i.destroyed) return;
      void 0 === t && (t = i.params.speed);
      const r = i.grid && i.params.grid && i.params.grid.rows > 1;
      let n = e;
      if (i.params.loop) if (i.virtual && i.params.virtual.enabled) n += i.virtual.slidesBefore;else {
        let e;
        if (r) {
          const t = n * i.params.grid.rows;
          e = i.slides.find(e => 1 * e.getAttribute("data-swiper-slide-index") === t).column;
        } else e = i.getSlideIndexByData(n);
        const t = r ? Math.ceil(i.slides.length / i.params.grid.rows) : i.slides.length,
          {
            centeredSlides: s
          } = i.params;
        let l = i.params.slidesPerView;
        "auto" === l ? l = i.slidesPerViewDynamic() : (l = Math.ceil(parseFloat(i.params.slidesPerView, 10)), s && l % 2 == 0 && (l += 1));
        let o = t - e < l;
        if (s && (o = o || e < Math.ceil(l / 2)), a && s && "auto" !== i.params.slidesPerView && !r && (o = !1), o) {
          const a = s ? e < i.activeIndex ? "prev" : "next" : e - i.activeIndex - 1 < i.params.slidesPerView ? "next" : "prev";
          i.loopFix({
            direction: a,
            slideTo: !0,
            activeSlideIndex: "next" === a ? e + 1 : e - t + 1,
            slideRealIndex: "next" === a ? i.realIndex : void 0
          });
        }
        if (r) {
          const e = n * i.params.grid.rows;
          n = i.slides.find(t => 1 * t.getAttribute("data-swiper-slide-index") === e).column;
        } else n = i.getSlideIndexByData(n);
      }
      return requestAnimationFrame(() => {
        i.slideTo(n, t, s, a);
      }), i;
    },
    slideNext: function (e, t, s) {
      void 0 === t && (t = !0);
      const a = this,
        {
          enabled: i,
          params: r,
          animating: n
        } = a;
      if (!i || a.destroyed) return a;
      void 0 === e && (e = a.params.speed);
      let l = r.slidesPerGroup;
      "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (l = Math.max(a.slidesPerViewDynamic("current", !0), 1));
      const o = a.activeIndex < r.slidesPerGroupSkip ? 1 : l,
        d = a.virtual && r.virtual.enabled;
      if (r.loop) {
        if (n && !d && r.loopPreventsSliding) return !1;
        if (a.loopFix({
          direction: "next"
        }), a._clientLeft = a.wrapperEl.clientLeft, a.activeIndex === a.slides.length - 1 && r.cssMode) return requestAnimationFrame(() => {
          a.slideTo(a.activeIndex + o, e, t, s);
        }), !0;
      }
      return r.rewind && a.isEnd ? a.slideTo(0, e, t, s) : a.slideTo(a.activeIndex + o, e, t, s);
    },
    slidePrev: function (e, t, s) {
      void 0 === t && (t = !0);
      const a = this,
        {
          params: i,
          snapGrid: r,
          slidesGrid: n,
          rtlTranslate: l,
          enabled: o,
          animating: d
        } = a;
      if (!o || a.destroyed) return a;
      void 0 === e && (e = a.params.speed);
      const c = a.virtual && i.virtual.enabled;
      if (i.loop) {
        if (d && !c && i.loopPreventsSliding) return !1;
        a.loopFix({
          direction: "prev"
        }), a._clientLeft = a.wrapperEl.clientLeft;
      }
      function p(e) {
        return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e);
      }
      const u = p(l ? a.translate : -a.translate),
        m = r.map(e => p(e)),
        h = i.freeMode && i.freeMode.enabled;
      let f = r[m.indexOf(u) - 1];
      if (void 0 === f && (i.cssMode || h)) {
        let e;
        r.forEach((t, s) => {
          u >= t && (e = s);
        }), void 0 !== e && (f = h ? r[e] : r[e > 0 ? e - 1 : e]);
      }
      let g = 0;
      if (void 0 !== f && (g = n.indexOf(f), g < 0 && (g = a.activeIndex - 1), "auto" === i.slidesPerView && 1 === i.slidesPerGroup && i.slidesPerGroupAuto && (g = g - a.slidesPerViewDynamic("previous", !0) + 1, g = Math.max(g, 0))), i.rewind && a.isBeginning) {
        const i = a.params.virtual && a.params.virtual.enabled && a.virtual ? a.virtual.slides.length - 1 : a.slides.length - 1;
        return a.slideTo(i, e, t, s);
      }
      return i.loop && 0 === a.activeIndex && i.cssMode ? (requestAnimationFrame(() => {
        a.slideTo(g, e, t, s);
      }), !0) : a.slideTo(g, e, t, s);
    },
    slideReset: function (e, t, s) {
      void 0 === t && (t = !0);
      const a = this;
      if (!a.destroyed) return void 0 === e && (e = a.params.speed), a.slideTo(a.activeIndex, e, t, s);
    },
    slideToClosest: function (e, t, s, a) {
      void 0 === t && (t = !0), void 0 === a && (a = .5);
      const i = this;
      if (i.destroyed) return;
      void 0 === e && (e = i.params.speed);
      let r = i.activeIndex;
      const n = Math.min(i.params.slidesPerGroupSkip, r),
        l = n + Math.floor((r - n) / i.params.slidesPerGroup),
        o = i.rtlTranslate ? i.translate : -i.translate;
      if (o >= i.snapGrid[l]) {
        const e = i.snapGrid[l];
        o - e > (i.snapGrid[l + 1] - e) * a && (r += i.params.slidesPerGroup);
      } else {
        const e = i.snapGrid[l - 1];
        o - e <= (i.snapGrid[l] - e) * a && (r -= i.params.slidesPerGroup);
      }
      return r = Math.max(r, 0), r = Math.min(r, i.slidesGrid.length - 1), i.slideTo(r, e, t, s);
    },
    slideToClickedSlide: function () {
      const e = this;
      if (e.destroyed) return;
      const {
          params: t,
          slidesEl: s
        } = e,
        a = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
      let i,
        r = e.getSlideIndexWhenGrid(e.clickedIndex);
      const n = e.isElement ? "swiper-slide" : `.${t.slideClass}`,
        o = e.grid && e.params.grid && e.params.grid.rows > 1;
      if (t.loop) {
        if (e.animating) return;
        i = parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10), t.centeredSlides ? e.slideToLoop(i) : r > (o ? (e.slides.length - a) / 2 - (e.params.grid.rows - 1) : e.slides.length - a) ? (e.loopFix(), r = e.getSlideIndex(f(s, `${n}[data-swiper-slide-index="${i}"]`)[0]), l(() => {
          e.slideTo(r);
        })) : e.slideTo(r);
      } else e.slideTo(r);
    }
  };
  var _ = {
    loopCreate: function (e, t) {
      const s = this,
        {
          params: a,
          slidesEl: i
        } = s;
      if (!a.loop || s.virtual && s.params.virtual.enabled) return;
      const r = () => {
          f(i, `.${a.slideClass}, swiper-slide`).forEach((e, t) => {
            e.setAttribute("data-swiper-slide-index", t);
          });
        },
        n = s.grid && a.grid && a.grid.rows > 1;
      a.loopAddBlankSlides && (a.slidesPerGroup > 1 || n) && (() => {
        const e = f(i, `.${a.slideBlankClass}`);
        e.forEach(e => {
          e.remove();
        }), e.length > 0 && (s.recalcSlides(), s.updateSlides());
      })();
      const l = a.slidesPerGroup * (n ? a.grid.rows : 1),
        o = s.slides.length % l != 0,
        d = n && s.slides.length % a.grid.rows != 0,
        c = e => {
          for (let t = 0; t < e; t += 1) {
            const e = s.isElement ? v("swiper-slide", [a.slideBlankClass]) : v("div", [a.slideClass, a.slideBlankClass]);
            s.slidesEl.append(e);
          }
        };
      if (o) {
        if (a.loopAddBlankSlides) {
          c(l - s.slides.length % l), s.recalcSlides(), s.updateSlides();
        } else g("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        r();
      } else if (d) {
        if (a.loopAddBlankSlides) {
          c(a.grid.rows - s.slides.length % a.grid.rows), s.recalcSlides(), s.updateSlides();
        } else g("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        r();
      } else r();
      s.loopFix({
        slideRealIndex: e,
        direction: a.centeredSlides ? void 0 : "next",
        initial: t
      });
    },
    loopFix: function (e) {
      let {
        slideRealIndex: t,
        slideTo: s = !0,
        direction: a,
        setTranslate: i,
        activeSlideIndex: r,
        initial: n,
        byController: l,
        byMousewheel: o
      } = void 0 === e ? {} : e;
      const d = this;
      if (!d.params.loop) return;
      d.emit("beforeLoopFix");
      const {
          slides: c,
          allowSlidePrev: p,
          allowSlideNext: u,
          slidesEl: m,
          params: h
        } = d,
        {
          centeredSlides: f,
          initialSlide: v
        } = h;
      if (d.allowSlidePrev = !0, d.allowSlideNext = !0, d.virtual && h.virtual.enabled) return s && (h.centeredSlides || 0 !== d.snapIndex ? h.centeredSlides && d.snapIndex < h.slidesPerView ? d.slideTo(d.virtual.slides.length + d.snapIndex, 0, !1, !0) : d.snapIndex === d.snapGrid.length - 1 && d.slideTo(d.virtual.slidesBefore, 0, !1, !0) : d.slideTo(d.virtual.slides.length, 0, !1, !0)), d.allowSlidePrev = p, d.allowSlideNext = u, void d.emit("loopFix");
      let w = h.slidesPerView;
      "auto" === w ? w = d.slidesPerViewDynamic() : (w = Math.ceil(parseFloat(h.slidesPerView, 10)), f && w % 2 == 0 && (w += 1));
      const b = h.slidesPerGroupAuto ? w : h.slidesPerGroup;
      let y = f ? Math.max(b, Math.ceil(w / 2)) : b;
      y % b != 0 && (y += b - y % b), y += h.loopAdditionalSlides, d.loopedSlides = y;
      const E = d.grid && h.grid && h.grid.rows > 1;
      c.length < w + y || "cards" === d.params.effect && c.length < w + 2 * y ? g("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled or not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : E && "row" === h.grid.fill && g("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
      const x = [],
        S = [],
        T = E ? Math.ceil(c.length / h.grid.rows) : c.length,
        M = n && T - v < w && !f;
      let C = M ? v : d.activeIndex;
      void 0 === r ? r = d.getSlideIndex(c.find(e => e.classList.contains(h.slideActiveClass))) : C = r;
      const P = "next" === a || !a,
        L = "prev" === a || !a;
      let I = 0,
        z = 0;
      const A = (E ? c[r].column : r) + (f && void 0 === i ? -w / 2 + .5 : 0);
      if (A < y) {
        I = Math.max(y - A, b);
        for (let e = 0; e < y - A; e += 1) {
          const t = e - Math.floor(e / T) * T;
          if (E) {
            const e = T - t - 1;
            for (let t = c.length - 1; t >= 0; t -= 1) c[t].column === e && x.push(t);
          } else x.push(T - t - 1);
        }
      } else if (A + w > T - y) {
        z = Math.max(A - (T - 2 * y), b), M && (z = Math.max(z, w - T + v + 1));
        for (let e = 0; e < z; e += 1) {
          const t = e - Math.floor(e / T) * T;
          E ? c.forEach((e, s) => {
            e.column === t && S.push(s);
          }) : S.push(t);
        }
      }
      if (d.__preventObserver__ = !0, requestAnimationFrame(() => {
        d.__preventObserver__ = !1;
      }), "cards" === d.params.effect && c.length < w + 2 * y && (S.includes(r) && S.splice(S.indexOf(r), 1), x.includes(r) && x.splice(x.indexOf(r), 1)), L && x.forEach(e => {
        c[e].swiperLoopMoveDOM = !0, m.prepend(c[e]), c[e].swiperLoopMoveDOM = !1;
      }), P && S.forEach(e => {
        c[e].swiperLoopMoveDOM = !0, m.append(c[e]), c[e].swiperLoopMoveDOM = !1;
      }), d.recalcSlides(), "auto" === h.slidesPerView ? d.updateSlides() : E && (x.length > 0 && L || S.length > 0 && P) && d.slides.forEach((e, t) => {
        d.grid.updateSlide(t, e, d.slides);
      }), h.watchSlidesProgress && d.updateSlidesOffset(), s) if (x.length > 0 && L) {
        if (void 0 === t) {
          const e = d.slidesGrid[C],
            t = d.slidesGrid[C + I] - e;
          o ? d.setTranslate(d.translate - t) : (d.slideTo(C + Math.ceil(I), 0, !1, !0), i && (d.touchEventsData.startTranslate = d.touchEventsData.startTranslate - t, d.touchEventsData.currentTranslate = d.touchEventsData.currentTranslate - t));
        } else if (i) {
          const e = E ? x.length / h.grid.rows : x.length;
          d.slideTo(d.activeIndex + e, 0, !1, !0), d.touchEventsData.currentTranslate = d.translate;
        }
      } else if (S.length > 0 && P) if (void 0 === t) {
        const e = d.slidesGrid[C],
          t = d.slidesGrid[C - z] - e;
        o ? d.setTranslate(d.translate - t) : (d.slideTo(C - z, 0, !1, !0), i && (d.touchEventsData.startTranslate = d.touchEventsData.startTranslate - t, d.touchEventsData.currentTranslate = d.touchEventsData.currentTranslate - t));
      } else {
        const e = E ? S.length / h.grid.rows : S.length;
        d.slideTo(d.activeIndex - e, 0, !1, !0);
      }
      if (d.allowSlidePrev = p, d.allowSlideNext = u, d.controller && d.controller.control && !l) {
        const e = {
          slideRealIndex: t,
          direction: a,
          setTranslate: i,
          activeSlideIndex: r,
          byController: !0
        };
        Array.isArray(d.controller.control) ? d.controller.control.forEach(t => {
          !t.destroyed && t.params.loop && t.loopFix({
            ...e,
            slideTo: t.params.slidesPerView === h.slidesPerView && s
          });
        }) : d.controller.control instanceof d.constructor && d.controller.control.params.loop && d.controller.control.loopFix({
          ...e,
          slideTo: d.controller.control.params.slidesPerView === h.slidesPerView && s
        });
      }
      d.emit("loopFix");
    },
    loopDestroy: function () {
      const e = this,
        {
          params: t,
          slidesEl: s
        } = e;
      if (!t.loop || !s || e.virtual && e.params.virtual.enabled) return;
      e.recalcSlides();
      const a = [];
      e.slides.forEach(e => {
        const t = void 0 === e.swiperSlideIndex ? 1 * e.getAttribute("data-swiper-slide-index") : e.swiperSlideIndex;
        a[t] = e;
      }), e.slides.forEach(e => {
        e.removeAttribute("data-swiper-slide-index");
      }), a.forEach(e => {
        s.append(e);
      }), e.recalcSlides(), e.slideTo(e.realIndex, 0);
    }
  };
  function q(e, t, s) {
    const a = r(),
      {
        params: i
      } = e,
      n = i.edgeSwipeDetection,
      l = i.edgeSwipeThreshold;
    return !n || !(s <= l || s >= a.innerWidth - l) || "prevent" === n && (t.preventDefault(), !0);
  }
  function V(e) {
    const t = this,
      s = a();
    let i = e;
    i.originalEvent && (i = i.originalEvent);
    const n = t.touchEventsData;
    if ("pointerdown" === i.type) {
      if (null !== n.pointerId && n.pointerId !== i.pointerId) return;
      n.pointerId = i.pointerId;
    } else "touchstart" === i.type && 1 === i.targetTouches.length && (n.touchId = i.targetTouches[0].identifier);
    if ("touchstart" === i.type) return void q(t, i, i.targetTouches[0].pageX);
    const {
      params: l,
      touches: d,
      enabled: c
    } = t;
    if (!c) return;
    if (!l.simulateTouch && "mouse" === i.pointerType) return;
    if (t.animating && l.preventInteractionOnTransition) return;
    !t.animating && l.cssMode && l.loop && t.loopFix();
    let p = i.target;
    if ("wrapper" === l.touchEventsTarget && !function (e, t) {
      const s = r();
      let a = t.contains(e);
      !a && s.HTMLSlotElement && t instanceof HTMLSlotElement && (a = [...t.assignedElements()].includes(e), a || (a = function (e, t) {
        const s = [t];
        for (; s.length > 0;) {
          const t = s.shift();
          if (e === t) return !0;
          s.push(...t.children, ...(t.shadowRoot ? t.shadowRoot.children : []), ...(t.assignedElements ? t.assignedElements() : []));
        }
      }(e, t)));
      return a;
    }(p, t.wrapperEl)) return;
    if ("which" in i && 3 === i.which) return;
    if ("button" in i && i.button > 0) return;
    if (n.isTouched && n.isMoved) return;
    const u = !!l.noSwipingClass && "" !== l.noSwipingClass,
      m = i.composedPath ? i.composedPath() : i.path;
    u && i.target && i.target.shadowRoot && m && (p = m[0]);
    const h = l.noSwipingSelector ? l.noSwipingSelector : `.${l.noSwipingClass}`,
      f = !(!i.target || !i.target.shadowRoot);
    if (l.noSwiping && (f ? function (e, t) {
      return void 0 === t && (t = this), function t(s) {
        if (!s || s === a() || s === r()) return null;
        s.assignedSlot && (s = s.assignedSlot);
        const i = s.closest(e);
        return i || s.getRootNode ? i || t(s.getRootNode().host) : null;
      }(t);
    }(h, p) : p.closest(h))) return void (t.allowClick = !0);
    if (l.swipeHandler && !p.closest(l.swipeHandler)) return;
    d.currentX = i.pageX, d.currentY = i.pageY;
    const g = d.currentX,
      v = d.currentY;
    if (!q(t, i, g)) return;
    Object.assign(n, {
      isTouched: !0,
      isMoved: !1,
      allowTouchCallbacks: !0,
      isScrolling: void 0,
      startMoving: void 0
    }), d.startX = g, d.startY = v, n.touchStartTime = o(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, l.threshold > 0 && (n.allowThresholdMove = !1);
    let w = !0;
    p.matches(n.focusableElements) && (w = !1, "SELECT" === p.nodeName && (n.isTouched = !1)), s.activeElement && s.activeElement.matches(n.focusableElements) && s.activeElement !== p && ("mouse" === i.pointerType || "mouse" !== i.pointerType && !p.matches(n.focusableElements)) && s.activeElement.blur();
    const b = w && t.allowTouchMove && l.touchStartPreventDefault;
    !l.touchStartForcePreventDefault && !b || p.isContentEditable || i.preventDefault(), l.freeMode && l.freeMode.enabled && t.freeMode && t.animating && !l.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", i);
  }
  function F(e) {
    const t = a(),
      s = this,
      i = s.touchEventsData,
      {
        params: r,
        touches: n,
        rtlTranslate: l,
        enabled: d
      } = s;
    if (!d) return;
    if (!r.simulateTouch && "mouse" === e.pointerType) return;
    let c,
      p = e;
    if (p.originalEvent && (p = p.originalEvent), "pointermove" === p.type) {
      if (null !== i.touchId) return;
      if (p.pointerId !== i.pointerId) return;
    }
    if ("touchmove" === p.type) {
      if (c = [...p.changedTouches].find(e => e.identifier === i.touchId), !c || c.identifier !== i.touchId) return;
    } else c = p;
    if (!i.isTouched) return void (i.startMoving && i.isScrolling && s.emit("touchMoveOpposite", p));
    const u = c.pageX,
      m = c.pageY;
    if (p.preventedByNestedSwiper) return n.startX = u, void (n.startY = m);
    if (!s.allowTouchMove) return p.target.matches(i.focusableElements) || (s.allowClick = !1), void (i.isTouched && (Object.assign(n, {
      startX: u,
      startY: m,
      currentX: u,
      currentY: m
    }), i.touchStartTime = o()));
    if (r.touchReleaseOnEdges && !r.loop) if (s.isVertical()) {
      if (m < n.startY && s.translate <= s.maxTranslate() || m > n.startY && s.translate >= s.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1);
    } else {
      if (l && (u > n.startX && -s.translate <= s.maxTranslate() || u < n.startX && -s.translate >= s.minTranslate())) return;
      if (!l && (u < n.startX && s.translate <= s.maxTranslate() || u > n.startX && s.translate >= s.minTranslate())) return;
    }
    if (t.activeElement && t.activeElement.matches(i.focusableElements) && t.activeElement !== p.target && "mouse" !== p.pointerType && t.activeElement.blur(), t.activeElement && p.target === t.activeElement && p.target.matches(i.focusableElements)) return i.isMoved = !0, void (s.allowClick = !1);
    i.allowTouchCallbacks && s.emit("touchMove", p), n.previousX = n.currentX, n.previousY = n.currentY, n.currentX = u, n.currentY = m;
    const h = n.currentX - n.startX,
      f = n.currentY - n.startY;
    if (s.params.threshold && Math.sqrt(h ** 2 + f ** 2) < s.params.threshold) return;
    if (void 0 === i.isScrolling) {
      let e;
      s.isHorizontal() && n.currentY === n.startY || s.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : h * h + f * f >= 25 && (e = 180 * Math.atan2(Math.abs(f), Math.abs(h)) / Math.PI, i.isScrolling = s.isHorizontal() ? e > r.touchAngle : 90 - e > r.touchAngle);
    }
    if (i.isScrolling && s.emit("touchMoveOpposite", p), void 0 === i.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (i.startMoving = !0)), i.isScrolling || "touchmove" === p.type && i.preventTouchMoveFromPointerMove) return void (i.isTouched = !1);
    if (!i.startMoving) return;
    s.allowClick = !1, !r.cssMode && p.cancelable && p.preventDefault(), r.touchMoveStopPropagation && !r.nested && p.stopPropagation();
    let g = s.isHorizontal() ? h : f,
      v = s.isHorizontal() ? n.currentX - n.previousX : n.currentY - n.previousY;
    r.oneWayMovement && (g = Math.abs(g) * (l ? 1 : -1), v = Math.abs(v) * (l ? 1 : -1)), n.diff = g, g *= r.touchRatio, l && (g = -g, v = -v);
    const w = s.touchesDirection;
    s.swipeDirection = g > 0 ? "prev" : "next", s.touchesDirection = v > 0 ? "prev" : "next";
    const b = s.params.loop && !r.cssMode,
      y = "next" === s.touchesDirection && s.allowSlideNext || "prev" === s.touchesDirection && s.allowSlidePrev;
    if (!i.isMoved) {
      if (b && y && s.loopFix({
        direction: s.swipeDirection
      }), i.startTranslate = s.getTranslate(), s.setTransition(0), s.animating) {
        const e = new window.CustomEvent("transitionend", {
          bubbles: !0,
          cancelable: !0,
          detail: {
            bySwiperTouchMove: !0
          }
        });
        s.wrapperEl.dispatchEvent(e);
      }
      i.allowMomentumBounce = !1, !r.grabCursor || !0 !== s.allowSlideNext && !0 !== s.allowSlidePrev || s.setGrabCursor(!0), s.emit("sliderFirstMove", p);
    }
    if (new Date().getTime(), !1 !== r._loopSwapReset && i.isMoved && i.allowThresholdMove && w !== s.touchesDirection && b && y && Math.abs(g) >= 1) return Object.assign(n, {
      startX: u,
      startY: m,
      currentX: u,
      currentY: m,
      startTranslate: i.currentTranslate
    }), i.loopSwapReset = !0, void (i.startTranslate = i.currentTranslate);
    s.emit("sliderMove", p), i.isMoved = !0, i.currentTranslate = g + i.startTranslate;
    let E = !0,
      x = r.resistanceRatio;
    if (r.touchReleaseOnEdges && (x = 0), g > 0 ? (b && y && i.allowThresholdMove && i.currentTranslate > (r.centeredSlides ? s.minTranslate() - s.slidesSizesGrid[s.activeIndex + 1] - ("auto" !== r.slidesPerView && s.slides.length - r.slidesPerView >= 2 ? s.slidesSizesGrid[s.activeIndex + 1] + s.params.spaceBetween : 0) - s.params.spaceBetween : s.minTranslate()) && s.loopFix({
      direction: "prev",
      setTranslate: !0,
      activeSlideIndex: 0
    }), i.currentTranslate > s.minTranslate() && (E = !1, r.resistance && (i.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + i.startTranslate + g) ** x))) : g < 0 && (b && y && i.allowThresholdMove && i.currentTranslate < (r.centeredSlides ? s.maxTranslate() + s.slidesSizesGrid[s.slidesSizesGrid.length - 1] + s.params.spaceBetween + ("auto" !== r.slidesPerView && s.slides.length - r.slidesPerView >= 2 ? s.slidesSizesGrid[s.slidesSizesGrid.length - 1] + s.params.spaceBetween : 0) : s.maxTranslate()) && s.loopFix({
      direction: "next",
      setTranslate: !0,
      activeSlideIndex: s.slides.length - ("auto" === r.slidesPerView ? s.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10)))
    }), i.currentTranslate < s.maxTranslate() && (E = !1, r.resistance && (i.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - i.startTranslate - g) ** x))), E && (p.preventedByNestedSwiper = !0), !s.allowSlideNext && "next" === s.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !s.allowSlidePrev && "prev" === s.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.allowSlidePrev || s.allowSlideNext || (i.currentTranslate = i.startTranslate), r.threshold > 0) {
      if (!(Math.abs(g) > r.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate);
      if (!i.allowThresholdMove) return i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, void (n.diff = s.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY);
    }
    r.followFinger && !r.cssMode && ((r.freeMode && r.freeMode.enabled && s.freeMode || r.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), r.freeMode && r.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(i.currentTranslate), s.setTranslate(i.currentTranslate));
  }
  function W(e) {
    const t = this,
      s = t.touchEventsData;
    let a,
      i = e;
    i.originalEvent && (i = i.originalEvent);
    if ("touchend" === i.type || "touchcancel" === i.type) {
      if (a = [...i.changedTouches].find(e => e.identifier === s.touchId), !a || a.identifier !== s.touchId) return;
    } else {
      if (null !== s.touchId) return;
      if (i.pointerId !== s.pointerId) return;
      a = i;
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(i.type)) {
      if (!(["pointercancel", "contextmenu"].includes(i.type) && (t.browser.isSafari || t.browser.isWebView))) return;
    }
    s.pointerId = null, s.touchId = null;
    const {
      params: r,
      touches: n,
      rtlTranslate: d,
      slidesGrid: c,
      enabled: p
    } = t;
    if (!p) return;
    if (!r.simulateTouch && "mouse" === i.pointerType) return;
    if (s.allowTouchCallbacks && t.emit("touchEnd", i), s.allowTouchCallbacks = !1, !s.isTouched) return s.isMoved && r.grabCursor && t.setGrabCursor(!1), s.isMoved = !1, void (s.startMoving = !1);
    r.grabCursor && s.isMoved && s.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
    const u = o(),
      m = u - s.touchStartTime;
    if (t.allowClick) {
      const e = i.path || i.composedPath && i.composedPath();
      t.updateClickedSlide(e && e[0] || i.target, e), t.emit("tap click", i), m < 300 && u - s.lastClickTime < 300 && t.emit("doubleTap doubleClick", i);
    }
    if (s.lastClickTime = o(), l(() => {
      t.destroyed || (t.allowClick = !0);
    }), !s.isTouched || !s.isMoved || !t.swipeDirection || 0 === n.diff && !s.loopSwapReset || s.currentTranslate === s.startTranslate && !s.loopSwapReset) return s.isTouched = !1, s.isMoved = !1, void (s.startMoving = !1);
    let h;
    if (s.isTouched = !1, s.isMoved = !1, s.startMoving = !1, h = r.followFinger ? d ? t.translate : -t.translate : -s.currentTranslate, r.cssMode) return;
    if (r.freeMode && r.freeMode.enabled) return void t.freeMode.onTouchEnd({
      currentPos: h
    });
    const f = h >= -t.maxTranslate() && !t.params.loop;
    let g = 0,
      v = t.slidesSizesGrid[0];
    for (let e = 0; e < c.length; e += e < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup) {
      const t = e < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
      void 0 !== c[e + t] ? (f || h >= c[e] && h < c[e + t]) && (g = e, v = c[e + t] - c[e]) : (f || h >= c[e]) && (g = e, v = c[c.length - 1] - c[c.length - 2]);
    }
    let w = null,
      b = null;
    r.rewind && (t.isBeginning ? b = r.virtual && r.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (w = 0));
    const y = (h - c[g]) / v,
      E = g < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
    if (m > r.longSwipesMs) {
      if (!r.longSwipes) return void t.slideTo(t.activeIndex);
      "next" === t.swipeDirection && (y >= r.longSwipesRatio ? t.slideTo(r.rewind && t.isEnd ? w : g + E) : t.slideTo(g)), "prev" === t.swipeDirection && (y > 1 - r.longSwipesRatio ? t.slideTo(g + E) : null !== b && y < 0 && Math.abs(y) > r.longSwipesRatio ? t.slideTo(b) : t.slideTo(g));
    } else {
      if (!r.shortSwipes) return void t.slideTo(t.activeIndex);
      t.navigation && (i.target === t.navigation.nextEl || i.target === t.navigation.prevEl) ? i.target === t.navigation.nextEl ? t.slideTo(g + E) : t.slideTo(g) : ("next" === t.swipeDirection && t.slideTo(null !== w ? w : g + E), "prev" === t.swipeDirection && t.slideTo(null !== b ? b : g));
    }
  }
  function j() {
    const e = this,
      {
        params: t,
        el: s
      } = e;
    if (s && 0 === s.offsetWidth) return;
    t.breakpoints && e.setBreakpoint();
    const {
        allowSlideNext: a,
        allowSlidePrev: i,
        snapGrid: r
      } = e,
      n = e.virtual && e.params.virtual.enabled;
    e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses();
    const l = n && t.loop;
    !("auto" === t.slidesPerView || t.slidesPerView > 1) || !e.isEnd || e.isBeginning || e.params.centeredSlides || l ? e.params.loop && !n ? e.slideToLoop(e.realIndex, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0) : e.slideTo(e.slides.length - 1, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && (clearTimeout(e.autoplay.resizeTimeout), e.autoplay.resizeTimeout = setTimeout(() => {
      e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.resume();
    }, 500)), e.allowSlidePrev = i, e.allowSlideNext = a, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow();
  }
  function U(e) {
    const t = this;
    t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())));
  }
  function K() {
    const e = this,
      {
        wrapperEl: t,
        rtlTranslate: s,
        enabled: a
      } = e;
    if (!a) return;
    let i;
    e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
    const r = e.maxTranslate() - e.minTranslate();
    i = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, i !== e.progress && e.updateProgress(s ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1);
  }
  function Z(e) {
    const t = this;
    G(t, e.target), t.params.cssMode || "auto" !== t.params.slidesPerView && !t.params.autoHeight || t.update();
  }
  function Q() {
    const e = this;
    e.documentTouchHandlerProceeded || (e.documentTouchHandlerProceeded = !0, e.params.touchReleaseOnEdges && (e.el.style.touchAction = "auto"));
  }
  const J = (e, t) => {
    const s = a(),
      {
        params: i,
        el: r,
        wrapperEl: n,
        device: l
      } = e,
      o = !!i.nested,
      d = "on" === t ? "addEventListener" : "removeEventListener",
      c = t;
    r && "string" != typeof r && (s[d]("touchstart", e.onDocumentTouchStart, {
      passive: !1,
      capture: o
    }), r[d]("touchstart", e.onTouchStart, {
      passive: !1
    }), r[d]("pointerdown", e.onTouchStart, {
      passive: !1
    }), s[d]("touchmove", e.onTouchMove, {
      passive: !1,
      capture: o
    }), s[d]("pointermove", e.onTouchMove, {
      passive: !1,
      capture: o
    }), s[d]("touchend", e.onTouchEnd, {
      passive: !0
    }), s[d]("pointerup", e.onTouchEnd, {
      passive: !0
    }), s[d]("pointercancel", e.onTouchEnd, {
      passive: !0
    }), s[d]("touchcancel", e.onTouchEnd, {
      passive: !0
    }), s[d]("pointerout", e.onTouchEnd, {
      passive: !0
    }), s[d]("pointerleave", e.onTouchEnd, {
      passive: !0
    }), s[d]("contextmenu", e.onTouchEnd, {
      passive: !0
    }), (i.preventClicks || i.preventClicksPropagation) && r[d]("click", e.onClick, !0), i.cssMode && n[d]("scroll", e.onScroll), i.updateOnWindowResize ? e[c](l.ios || l.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", j, !0) : e[c]("observerUpdate", j, !0), r[d]("load", e.onLoad, {
      capture: !0
    }));
  };
  const ee = (e, t) => e.grid && t.grid && t.grid.rows > 1;
  var te = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    eventsPrefix: "swiper",
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: .5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: .85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    loop: !1,
    loopAddBlankSlides: !0,
    loopAdditionalSlides: 0,
    loopPreventsSliding: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    runCallbacksOnInit: !0,
    _emitClasses: !1
  };
  function se(e, t) {
    return function (s) {
      void 0 === s && (s = {});
      const a = Object.keys(s)[0],
        i = s[a];
      "object" == typeof i && null !== i ? (!0 === e[a] && (e[a] = {
        enabled: !0
      }), "navigation" === a && e[a] && e[a].enabled && !e[a].prevEl && !e[a].nextEl && (e[a].auto = !0), ["pagination", "scrollbar"].indexOf(a) >= 0 && e[a] && e[a].enabled && !e[a].el && (e[a].auto = !0), a in e && "enabled" in i ? ("object" != typeof e[a] || "enabled" in e[a] || (e[a].enabled = !0), e[a] || (e[a] = {
        enabled: !1
      }), p(t, s)) : p(t, s)) : p(t, s);
    };
  }
  const ae = {
      eventsEmitter: k,
      update: B,
      translate: H,
      transition: {
        setTransition: function (e, t) {
          const s = this;
          s.params.cssMode || (s.wrapperEl.style.transitionDuration = `${e}ms`, s.wrapperEl.style.transitionDelay = 0 === e ? "0ms" : ""), s.emit("setTransition", e, t);
        },
        transitionStart: function (e, t) {
          void 0 === e && (e = !0);
          const s = this,
            {
              params: a
            } = s;
          a.cssMode || (a.autoHeight && s.updateAutoHeight(), N({
            swiper: s,
            runCallbacks: e,
            direction: t,
            step: "Start"
          }));
        },
        transitionEnd: function (e, t) {
          void 0 === e && (e = !0);
          const s = this,
            {
              params: a
            } = s;
          s.animating = !1, a.cssMode || (s.setTransition(0), N({
            swiper: s,
            runCallbacks: e,
            direction: t,
            step: "End"
          }));
        }
      },
      slide: R,
      loop: _,
      grabCursor: {
        setGrabCursor: function (e) {
          const t = this;
          if (!t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return;
          const s = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl;
          t.isElement && (t.__preventObserver__ = !0), s.style.cursor = "move", s.style.cursor = e ? "grabbing" : "grab", t.isElement && requestAnimationFrame(() => {
            t.__preventObserver__ = !1;
          });
        },
        unsetGrabCursor: function () {
          const e = this;
          e.params.watchOverflow && e.isLocked || e.params.cssMode || (e.isElement && (e.__preventObserver__ = !0), e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "", e.isElement && requestAnimationFrame(() => {
            e.__preventObserver__ = !1;
          }));
        }
      },
      events: {
        attachEvents: function () {
          const e = this,
            {
              params: t
            } = e;
          e.onTouchStart = V.bind(e), e.onTouchMove = F.bind(e), e.onTouchEnd = W.bind(e), e.onDocumentTouchStart = Q.bind(e), t.cssMode && (e.onScroll = K.bind(e)), e.onClick = U.bind(e), e.onLoad = Z.bind(e), J(e, "on");
        },
        detachEvents: function () {
          J(this, "off");
        }
      },
      breakpoints: {
        setBreakpoint: function () {
          const e = this,
            {
              realIndex: t,
              initialized: s,
              params: i,
              el: r
            } = e,
            n = i.breakpoints;
          if (!n || n && 0 === Object.keys(n).length) return;
          const l = a(),
            o = "window" !== i.breakpointsBase && i.breakpointsBase ? "container" : i.breakpointsBase,
            d = ["window", "container"].includes(i.breakpointsBase) || !i.breakpointsBase ? e.el : l.querySelector(i.breakpointsBase),
            c = e.getBreakpoint(n, o, d);
          if (!c || e.currentBreakpoint === c) return;
          const u = (c in n ? n[c] : void 0) || e.originalParams,
            m = ee(e, i),
            h = ee(e, u),
            f = e.params.grabCursor,
            g = u.grabCursor,
            v = i.enabled;
          m && !h ? (r.classList.remove(`${i.containerModifierClass}grid`, `${i.containerModifierClass}grid-column`), e.emitContainerClasses()) : !m && h && (r.classList.add(`${i.containerModifierClass}grid`), (u.grid.fill && "column" === u.grid.fill || !u.grid.fill && "column" === i.grid.fill) && r.classList.add(`${i.containerModifierClass}grid-column`), e.emitContainerClasses()), f && !g ? e.unsetGrabCursor() : !f && g && e.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach(t => {
            if (void 0 === u[t]) return;
            const s = i[t] && i[t].enabled,
              a = u[t] && u[t].enabled;
            s && !a && e[t].disable(), !s && a && e[t].enable();
          });
          const w = u.direction && u.direction !== i.direction,
            b = i.loop && (u.slidesPerView !== i.slidesPerView || w),
            y = i.loop;
          w && s && e.changeDirection(), p(e.params, u);
          const E = e.params.enabled,
            x = e.params.loop;
          Object.assign(e, {
            allowTouchMove: e.params.allowTouchMove,
            allowSlideNext: e.params.allowSlideNext,
            allowSlidePrev: e.params.allowSlidePrev
          }), v && !E ? e.disable() : !v && E && e.enable(), e.currentBreakpoint = c, e.emit("_beforeBreakpoint", u), s && (b ? (e.loopDestroy(), e.loopCreate(t), e.updateSlides()) : !y && x ? (e.loopCreate(t), e.updateSlides()) : y && !x && e.loopDestroy()), e.emit("breakpoint", u);
        },
        getBreakpoint: function (e, t, s) {
          if (void 0 === t && (t = "window"), !e || "container" === t && !s) return;
          let a = !1;
          const i = r(),
            n = "window" === t ? i.innerHeight : s.clientHeight,
            l = Object.keys(e).map(e => {
              if ("string" == typeof e && 0 === e.indexOf("@")) {
                const t = parseFloat(e.substr(1));
                return {
                  value: n * t,
                  point: e
                };
              }
              return {
                value: e,
                point: e
              };
            });
          l.sort((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10));
          for (let e = 0; e < l.length; e += 1) {
            const {
              point: r,
              value: n
            } = l[e];
            "window" === t ? i.matchMedia(`(min-width: ${n}px)`).matches && (a = r) : n <= s.clientWidth && (a = r);
          }
          return a || "max";
        }
      },
      checkOverflow: {
        checkOverflow: function () {
          const e = this,
            {
              isLocked: t,
              params: s
            } = e,
            {
              slidesOffsetBefore: a
            } = s;
          if (a) {
            const t = e.slides.length - 1,
              s = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * a;
            e.isLocked = e.size > s;
          } else e.isLocked = 1 === e.snapGrid.length;
          !0 === s.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === s.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock");
        }
      },
      classes: {
        addClasses: function () {
          const e = this,
            {
              classNames: t,
              params: s,
              rtl: a,
              el: i,
              device: r
            } = e,
            n = function (e, t) {
              const s = [];
              return e.forEach(e => {
                "object" == typeof e ? Object.keys(e).forEach(a => {
                  e[a] && s.push(t + a);
                }) : "string" == typeof e && s.push(t + e);
              }), s;
            }(["initialized", s.direction, {
              "free-mode": e.params.freeMode && s.freeMode.enabled
            }, {
              autoheight: s.autoHeight
            }, {
              rtl: a
            }, {
              grid: s.grid && s.grid.rows > 1
            }, {
              "grid-column": s.grid && s.grid.rows > 1 && "column" === s.grid.fill
            }, {
              android: r.android
            }, {
              ios: r.ios
            }, {
              "css-mode": s.cssMode
            }, {
              centered: s.cssMode && s.centeredSlides
            }, {
              "watch-progress": s.watchSlidesProgress
            }], s.containerModifierClass);
          t.push(...n), i.classList.add(...t), e.emitContainerClasses();
        },
        removeClasses: function () {
          const {
            el: e,
            classNames: t
          } = this;
          e && "string" != typeof e && (e.classList.remove(...t), this.emitContainerClasses());
        }
      }
    },
    ie = {};
  class re {
    constructor() {
      let e, t;
      for (var s = arguments.length, i = new Array(s), r = 0; r < s; r++) i[r] = arguments[r];
      1 === i.length && i[0].constructor && "Object" === Object.prototype.toString.call(i[0]).slice(8, -1) ? t = i[0] : [e, t] = i, t || (t = {}), t = p({}, t), e && !t.el && (t.el = e);
      const n = a();
      if (t.el && "string" == typeof t.el && n.querySelectorAll(t.el).length > 1) {
        const e = [];
        return n.querySelectorAll(t.el).forEach(s => {
          const a = p({}, t, {
            el: s
          });
          e.push(new re(a));
        }), e;
      }
      const l = this;
      l.__swiper__ = !0, l.support = z(), l.device = A({
        userAgent: t.userAgent
      }), l.browser = $(), l.eventsListeners = {}, l.eventsAnyListeners = [], l.modules = [...l.__modules__], t.modules && Array.isArray(t.modules) && l.modules.push(...t.modules);
      const o = {};
      l.modules.forEach(e => {
        e({
          params: t,
          swiper: l,
          extendParams: se(t, o),
          on: l.on.bind(l),
          once: l.once.bind(l),
          off: l.off.bind(l),
          emit: l.emit.bind(l)
        });
      });
      const d = p({}, te, o);
      return l.params = p({}, d, ie, t), l.originalParams = p({}, l.params), l.passedParams = p({}, t), l.params && l.params.on && Object.keys(l.params.on).forEach(e => {
        l.on(e, l.params.on[e]);
      }), l.params && l.params.onAny && l.onAny(l.params.onAny), Object.assign(l, {
        enabled: l.params.enabled,
        el: e,
        classNames: [],
        slides: [],
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        isHorizontal: () => "horizontal" === l.params.direction,
        isVertical: () => "vertical" === l.params.direction,
        activeIndex: 0,
        realIndex: 0,
        isBeginning: !0,
        isEnd: !1,
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: !1,
        cssOverflowAdjustment() {
          return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
        },
        allowSlideNext: l.params.allowSlideNext,
        allowSlidePrev: l.params.allowSlidePrev,
        touchEventsData: {
          isTouched: void 0,
          isMoved: void 0,
          allowTouchCallbacks: void 0,
          touchStartTime: void 0,
          isScrolling: void 0,
          currentTranslate: void 0,
          startTranslate: void 0,
          allowThresholdMove: void 0,
          focusableElements: l.params.focusableElements,
          lastClickTime: 0,
          clickTimeout: void 0,
          velocities: [],
          allowMomentumBounce: void 0,
          startMoving: void 0,
          pointerId: null,
          touchId: null
        },
        allowClick: !0,
        allowTouchMove: l.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        imagesToLoad: [],
        imagesLoaded: 0
      }), l.emit("_swiper"), l.params.init && l.init(), l;
    }
    getDirectionLabel(e) {
      return this.isHorizontal() ? e : {
        width: "height",
        "margin-top": "margin-left",
        "margin-bottom ": "margin-right",
        "margin-left": "margin-top",
        "margin-right": "margin-bottom",
        "padding-left": "padding-top",
        "padding-right": "padding-bottom",
        marginRight: "marginBottom"
      }[e];
    }
    getSlideIndex(e) {
      const {
          slidesEl: t,
          params: s
        } = this,
        a = y(f(t, `.${s.slideClass}, swiper-slide`)[0]);
      return y(e) - a;
    }
    getSlideIndexByData(e) {
      return this.getSlideIndex(this.slides.find(t => 1 * t.getAttribute("data-swiper-slide-index") === e));
    }
    getSlideIndexWhenGrid(e) {
      return this.grid && this.params.grid && this.params.grid.rows > 1 && ("column" === this.params.grid.fill ? e = Math.floor(e / this.params.grid.rows) : "row" === this.params.grid.fill && (e %= Math.ceil(this.slides.length / this.params.grid.rows))), e;
    }
    recalcSlides() {
      const {
        slidesEl: e,
        params: t
      } = this;
      this.slides = f(e, `.${t.slideClass}, swiper-slide`);
    }
    enable() {
      const e = this;
      e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"));
    }
    disable() {
      const e = this;
      e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"));
    }
    setProgress(e, t) {
      const s = this;
      e = Math.min(Math.max(e, 0), 1);
      const a = s.minTranslate(),
        i = (s.maxTranslate() - a) * e + a;
      s.translateTo(i, void 0 === t ? 0 : t), s.updateActiveIndex(), s.updateSlidesClasses();
    }
    emitContainerClasses() {
      const e = this;
      if (!e.params._emitClasses || !e.el) return;
      const t = e.el.className.split(" ").filter(t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass));
      e.emit("_containerClasses", t.join(" "));
    }
    getSlideClasses(e) {
      const t = this;
      return t.destroyed ? "" : e.className.split(" ").filter(e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass)).join(" ");
    }
    emitSlidesClasses() {
      const e = this;
      if (!e.params._emitClasses || !e.el) return;
      const t = [];
      e.slides.forEach(s => {
        const a = e.getSlideClasses(s);
        t.push({
          slideEl: s,
          classNames: a
        }), e.emit("_slideClass", s, a);
      }), e.emit("_slideClasses", t);
    }
    slidesPerViewDynamic(e, t) {
      void 0 === e && (e = "current"), void 0 === t && (t = !1);
      const {
        params: s,
        slides: a,
        slidesGrid: i,
        slidesSizesGrid: r,
        size: n,
        activeIndex: l
      } = this;
      let o = 1;
      if ("number" == typeof s.slidesPerView) return s.slidesPerView;
      if (s.centeredSlides) {
        let e,
          t = a[l] ? Math.ceil(a[l].swiperSlideSize) : 0;
        for (let s = l + 1; s < a.length; s += 1) a[s] && !e && (t += Math.ceil(a[s].swiperSlideSize), o += 1, t > n && (e = !0));
        for (let s = l - 1; s >= 0; s -= 1) a[s] && !e && (t += a[s].swiperSlideSize, o += 1, t > n && (e = !0));
      } else if ("current" === e) for (let e = l + 1; e < a.length; e += 1) {
        (t ? i[e] + r[e] - i[l] < n : i[e] - i[l] < n) && (o += 1);
      } else for (let e = l - 1; e >= 0; e -= 1) {
        i[l] - i[e] < n && (o += 1);
      }
      return o;
    }
    update() {
      const e = this;
      if (!e || e.destroyed) return;
      const {
        snapGrid: t,
        params: s
      } = e;
      function a() {
        const t = e.rtlTranslate ? -1 * e.translate : e.translate,
          s = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
        e.setTranslate(s), e.updateActiveIndex(), e.updateSlidesClasses();
      }
      let i;
      if (s.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach(t => {
        t.complete && G(e, t);
      }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), s.freeMode && s.freeMode.enabled && !s.cssMode) a(), s.autoHeight && e.updateAutoHeight();else {
        if (("auto" === s.slidesPerView || s.slidesPerView > 1) && e.isEnd && !s.centeredSlides) {
          const t = e.virtual && s.virtual.enabled ? e.virtual.slides : e.slides;
          i = e.slideTo(t.length - 1, 0, !1, !0);
        } else i = e.slideTo(e.activeIndex, 0, !1, !0);
        i || a();
      }
      s.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update");
    }
    changeDirection(e, t) {
      void 0 === t && (t = !0);
      const s = this,
        a = s.params.direction;
      return e || (e = "horizontal" === a ? "vertical" : "horizontal"), e === a || "horizontal" !== e && "vertical" !== e || (s.el.classList.remove(`${s.params.containerModifierClass}${a}`), s.el.classList.add(`${s.params.containerModifierClass}${e}`), s.emitContainerClasses(), s.params.direction = e, s.slides.forEach(t => {
        "vertical" === e ? t.style.width = "" : t.style.height = "";
      }), s.emit("changeDirection"), t && s.update()), s;
    }
    changeLanguageDirection(e) {
      const t = this;
      t.rtl && "rtl" === e || !t.rtl && "ltr" === e || (t.rtl = "rtl" === e, t.rtlTranslate = "horizontal" === t.params.direction && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update());
    }
    mount(e) {
      const t = this;
      if (t.mounted) return !0;
      let s = e || t.params.el;
      if ("string" == typeof s && (s = document.querySelector(s)), !s) return !1;
      s.swiper = t, s.parentNode && s.parentNode.host && s.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
      const a = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`;
      let i = (() => {
        if (s && s.shadowRoot && s.shadowRoot.querySelector) {
          return s.shadowRoot.querySelector(a());
        }
        return f(s, a())[0];
      })();
      return !i && t.params.createElements && (i = v("div", t.params.wrapperClass), s.append(i), f(s, `.${t.params.slideClass}`).forEach(e => {
        i.append(e);
      })), Object.assign(t, {
        el: s,
        wrapperEl: i,
        slidesEl: t.isElement && !s.parentNode.host.slideSlots ? s.parentNode.host : i,
        hostEl: t.isElement ? s.parentNode.host : s,
        mounted: !0,
        rtl: "rtl" === s.dir.toLowerCase() || "rtl" === b(s, "direction"),
        rtlTranslate: "horizontal" === t.params.direction && ("rtl" === s.dir.toLowerCase() || "rtl" === b(s, "direction")),
        wrongRTL: "-webkit-box" === b(i, "display")
      }), !0;
    }
    init(e) {
      const t = this;
      if (t.initialized) return t;
      if (!1 === t.mount(e)) return t;
      t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(void 0, !0), t.attachEvents();
      const s = [...t.el.querySelectorAll('[loading="lazy"]')];
      return t.isElement && s.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), s.forEach(e => {
        e.complete ? G(t, e) : e.addEventListener("load", e => {
          G(t, e.target);
        });
      }), Y(t), t.initialized = !0, Y(t), t.emit("init"), t.emit("afterInit"), t;
    }
    destroy(e, t) {
      void 0 === e && (e = !0), void 0 === t && (t = !0);
      const s = this,
        {
          params: a,
          el: i,
          wrapperEl: r,
          slides: n
        } = s;
      return void 0 === s.params || s.destroyed || (s.emit("beforeDestroy"), s.initialized = !1, s.detachEvents(), a.loop && s.loopDestroy(), t && (s.removeClasses(), i && "string" != typeof i && i.removeAttribute("style"), r && r.removeAttribute("style"), n && n.length && n.forEach(e => {
        e.classList.remove(a.slideVisibleClass, a.slideFullyVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass), e.removeAttribute("style"), e.removeAttribute("data-swiper-slide-index");
      })), s.emit("destroy"), Object.keys(s.eventsListeners).forEach(e => {
        s.off(e);
      }), !1 !== e && (s.el && "string" != typeof s.el && (s.el.swiper = null), function (e) {
        const t = e;
        Object.keys(t).forEach(e => {
          try {
            t[e] = null;
          } catch (e) {}
          try {
            delete t[e];
          } catch (e) {}
        });
      }(s)), s.destroyed = !0), null;
    }
    static extendDefaults(e) {
      p(ie, e);
    }
    static get extendedDefaults() {
      return ie;
    }
    static get defaults() {
      return te;
    }
    static installModule(e) {
      re.prototype.__modules__ || (re.prototype.__modules__ = []);
      const t = re.prototype.__modules__;
      "function" == typeof e && t.indexOf(e) < 0 && t.push(e);
    }
    static use(e) {
      return Array.isArray(e) ? (e.forEach(e => re.installModule(e)), re) : (re.installModule(e), re);
    }
  }
  function ne(e, t, s, a) {
    return e.params.createElements && Object.keys(a).forEach(i => {
      if (!s[i] && !0 === s.auto) {
        let r = f(e.el, `.${a[i]}`)[0];
        r || (r = v("div", a[i]), r.className = a[i], e.el.append(r)), s[i] = r, t[i] = r;
      }
    }), s;
  }
  function le(e) {
    return void 0 === e && (e = ""), `.${e.trim().replace(/([\.:!+\/()[\]])/g, "\\$1").replace(/ /g, ".")}`;
  }
  function oe(e) {
    const t = this,
      {
        params: s,
        slidesEl: a
      } = t;
    s.loop && t.loopDestroy();
    const i = e => {
      if ("string" == typeof e) {
        const t = document.createElement("div");
        C(t, e), a.append(t.children[0]), C(t, "");
      } else a.append(e);
    };
    if ("object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1) e[t] && i(e[t]);else i(e);
    t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update();
  }
  function de(e) {
    const t = this,
      {
        params: s,
        activeIndex: a,
        slidesEl: i
      } = t;
    s.loop && t.loopDestroy();
    let r = a + 1;
    const n = e => {
      if ("string" == typeof e) {
        const t = document.createElement("div");
        C(t, e), i.prepend(t.children[0]), C(t, "");
      } else i.prepend(e);
    };
    if ("object" == typeof e && "length" in e) {
      for (let t = 0; t < e.length; t += 1) e[t] && n(e[t]);
      r = a + e.length;
    } else n(e);
    t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update(), t.slideTo(r, 0, !1);
  }
  function ce(e, t) {
    const s = this,
      {
        params: a,
        activeIndex: i,
        slidesEl: r
      } = s;
    let n = i;
    a.loop && (n -= s.loopedSlides, s.loopDestroy(), s.recalcSlides());
    const l = s.slides.length;
    if (e <= 0) return void s.prependSlide(t);
    if (e >= l) return void s.appendSlide(t);
    let o = n > e ? n + 1 : n;
    const d = [];
    for (let t = l - 1; t >= e; t -= 1) {
      const e = s.slides[t];
      e.remove(), d.unshift(e);
    }
    if ("object" == typeof t && "length" in t) {
      for (let e = 0; e < t.length; e += 1) t[e] && r.append(t[e]);
      o = n > e ? n + t.length : n;
    } else r.append(t);
    for (let e = 0; e < d.length; e += 1) r.append(d[e]);
    s.recalcSlides(), a.loop && s.loopCreate(), a.observer && !s.isElement || s.update(), a.loop ? s.slideTo(o + s.loopedSlides, 0, !1) : s.slideTo(o, 0, !1);
  }
  function pe(e) {
    const t = this,
      {
        params: s,
        activeIndex: a
      } = t;
    let i = a;
    s.loop && (i -= t.loopedSlides, t.loopDestroy());
    let r,
      n = i;
    if ("object" == typeof e && "length" in e) {
      for (let s = 0; s < e.length; s += 1) r = e[s], t.slides[r] && t.slides[r].remove(), r < n && (n -= 1);
      n = Math.max(n, 0);
    } else r = e, t.slides[r] && t.slides[r].remove(), r < n && (n -= 1), n = Math.max(n, 0);
    t.recalcSlides(), s.loop && t.loopCreate(), s.observer && !t.isElement || t.update(), s.loop ? t.slideTo(n + t.loopedSlides, 0, !1) : t.slideTo(n, 0, !1);
  }
  function ue() {
    const e = this,
      t = [];
    for (let s = 0; s < e.slides.length; s += 1) t.push(s);
    e.removeSlide(t);
  }
  function me(e) {
    const {
      effect: t,
      swiper: s,
      on: a,
      setTranslate: i,
      setTransition: r,
      overwriteParams: n,
      perspective: l,
      recreateShadows: o,
      getEffectParams: d
    } = e;
    let c;
    a("beforeInit", () => {
      if (s.params.effect !== t) return;
      s.classNames.push(`${s.params.containerModifierClass}${t}`), l && l() && s.classNames.push(`${s.params.containerModifierClass}3d`);
      const e = n ? n() : {};
      Object.assign(s.params, e), Object.assign(s.originalParams, e);
    }), a("setTranslate _virtualUpdated", () => {
      s.params.effect === t && i();
    }), a("setTransition", (e, a) => {
      s.params.effect === t && r(a);
    }), a("transitionEnd", () => {
      if (s.params.effect === t && o) {
        if (!d || !d().slideShadows) return;
        s.slides.forEach(e => {
          e.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(e => e.remove());
        }), o();
      }
    }), a("virtualUpdate", () => {
      s.params.effect === t && (s.slides.length || (c = !0), requestAnimationFrame(() => {
        c && s.slides && s.slides.length && (i(), c = !1);
      }));
    });
  }
  function he(e, t) {
    const s = h(t);
    return s !== t && (s.style.backfaceVisibility = "hidden", s.style["-webkit-backface-visibility"] = "hidden"), s;
  }
  function fe(e) {
    let {
      swiper: t,
      duration: s,
      transformElements: a,
      allSlides: i
    } = e;
    const {
      activeIndex: r
    } = t;
    if (t.params.virtualTranslate && 0 !== s) {
      let e,
        s = !1;
      e = i ? a : a.filter(e => {
        const s = e.classList.contains("swiper-slide-transform") ? (e => {
          if (!e.parentElement) return t.slides.find(t => t.shadowRoot && t.shadowRoot === e.parentNode);
          return e.parentElement;
        })(e) : e;
        return t.getSlideIndex(s) === r;
      }), e.forEach(e => {
        x(e, () => {
          if (s) return;
          if (!t || t.destroyed) return;
          s = !0, t.animating = !1;
          const e = new window.CustomEvent("transitionend", {
            bubbles: !0,
            cancelable: !0
          });
          t.wrapperEl.dispatchEvent(e);
        });
      });
    }
  }
  function ge(e, t, s) {
    const a = `swiper-slide-shadow${s ? `-${s}` : ""}${e ? ` swiper-slide-shadow-${e}` : ""}`,
      i = h(t);
    let r = i.querySelector(`.${a.split(" ").join(".")}`);
    return r || (r = v("div", a.split(" ")), i.append(r)), r;
  }
  Object.keys(ae).forEach(e => {
    Object.keys(ae[e]).forEach(t => {
      re.prototype[t] = ae[e][t];
    });
  }), re.use([function (e) {
    let {
      swiper: t,
      on: s,
      emit: a
    } = e;
    const i = r();
    let n = null,
      l = null;
    const o = () => {
        t && !t.destroyed && t.initialized && (a("beforeResize"), a("resize"));
      },
      d = () => {
        t && !t.destroyed && t.initialized && a("orientationchange");
      };
    s("init", () => {
      t.params.resizeObserver && void 0 !== i.ResizeObserver ? t && !t.destroyed && t.initialized && (n = new ResizeObserver(e => {
        l = i.requestAnimationFrame(() => {
          const {
            width: s,
            height: a
          } = t;
          let i = s,
            r = a;
          e.forEach(e => {
            let {
              contentBoxSize: s,
              contentRect: a,
              target: n
            } = e;
            n && n !== t.el || (i = a ? a.width : (s[0] || s).inlineSize, r = a ? a.height : (s[0] || s).blockSize);
          }), i === s && r === a || o();
        });
      }), n.observe(t.el)) : (i.addEventListener("resize", o), i.addEventListener("orientationchange", d));
    }), s("destroy", () => {
      l && i.cancelAnimationFrame(l), n && n.unobserve && t.el && (n.unobserve(t.el), n = null), i.removeEventListener("resize", o), i.removeEventListener("orientationchange", d);
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a,
      emit: i
    } = e;
    const n = [],
      l = r(),
      o = function (e, s) {
        void 0 === s && (s = {});
        const a = new (l.MutationObserver || l.WebkitMutationObserver)(e => {
          if (t.__preventObserver__) return;
          if (1 === e.length) return void i("observerUpdate", e[0]);
          const s = function () {
            i("observerUpdate", e[0]);
          };
          l.requestAnimationFrame ? l.requestAnimationFrame(s) : l.setTimeout(s, 0);
        });
        a.observe(e, {
          attributes: void 0 === s.attributes || s.attributes,
          childList: t.isElement || (void 0 === s.childList || s).childList,
          characterData: void 0 === s.characterData || s.characterData
        }), n.push(a);
      };
    s({
      observer: !1,
      observeParents: !1,
      observeSlideChildren: !1
    }), a("init", () => {
      if (t.params.observer) {
        if (t.params.observeParents) {
          const e = E(t.hostEl);
          for (let t = 0; t < e.length; t += 1) o(e[t]);
        }
        o(t.hostEl, {
          childList: t.params.observeSlideChildren
        }), o(t.wrapperEl, {
          attributes: !1
        });
      }
    }), a("destroy", () => {
      n.forEach(e => {
        e.disconnect();
      }), n.splice(0, n.length);
    });
  }]);
  const ve = [function (e) {
    let t,
      {
        swiper: s,
        extendParams: i,
        on: r,
        emit: n
      } = e;
    i({
      virtual: {
        enabled: !1,
        slides: [],
        cache: !0,
        renderSlide: null,
        renderExternal: null,
        renderExternalUpdate: !0,
        addSlidesBefore: 0,
        addSlidesAfter: 0
      }
    });
    const l = a();
    s.virtual = {
      cache: {},
      from: void 0,
      to: void 0,
      slides: [],
      offset: 0,
      slidesGrid: []
    };
    const o = l.createElement("div");
    function d(e, t) {
      const a = s.params.virtual;
      if (a.cache && s.virtual.cache[t]) return s.virtual.cache[t];
      let i;
      return a.renderSlide ? (i = a.renderSlide.call(s, e, t), "string" == typeof i && (C(o, i), i = o.children[0])) : i = s.isElement ? v("swiper-slide") : v("div", s.params.slideClass), i.setAttribute("data-swiper-slide-index", t), a.renderSlide || C(i, e), a.cache && (s.virtual.cache[t] = i), i;
    }
    function c(e, t, a) {
      const {
        slidesPerView: i,
        slidesPerGroup: r,
        centeredSlides: l,
        loop: o,
        initialSlide: c
      } = s.params;
      if (t && !o && c > 0) return;
      const {
          addSlidesBefore: p,
          addSlidesAfter: u
        } = s.params.virtual,
        {
          from: m,
          to: h,
          slides: g,
          slidesGrid: v,
          offset: w
        } = s.virtual;
      s.params.cssMode || s.updateActiveIndex();
      const b = void 0 === a ? s.activeIndex || 0 : a;
      let y, E, x;
      y = s.rtlTranslate ? "right" : s.isHorizontal() ? "left" : "top", l ? (E = Math.floor(i / 2) + r + u, x = Math.floor(i / 2) + r + p) : (E = i + (r - 1) + u, x = (o ? i : r) + p);
      let S = b - x,
        T = b + E;
      o || (S = Math.max(S, 0), T = Math.min(T, g.length - 1));
      let M = (s.slidesGrid[S] || 0) - (s.slidesGrid[0] || 0);
      function C() {
        s.updateSlides(), s.updateProgress(), s.updateSlidesClasses(), n("virtualUpdate");
      }
      if (o && b >= x ? (S -= x, l || (M += s.slidesGrid[0])) : o && b < x && (S = -x, l && (M += s.slidesGrid[0])), Object.assign(s.virtual, {
        from: S,
        to: T,
        offset: M,
        slidesGrid: s.slidesGrid,
        slidesBefore: x,
        slidesAfter: E
      }), m === S && h === T && !e) return s.slidesGrid !== v && M !== w && s.slides.forEach(e => {
        e.style[y] = M - Math.abs(s.cssOverflowAdjustment()) + "px";
      }), s.updateProgress(), void n("virtualUpdate");
      if (s.params.virtual.renderExternal) return s.params.virtual.renderExternal.call(s, {
        offset: M,
        from: S,
        to: T,
        slides: function () {
          const e = [];
          for (let t = S; t <= T; t += 1) e.push(g[t]);
          return e;
        }()
      }), void (s.params.virtual.renderExternalUpdate ? C() : n("virtualUpdate"));
      const P = [],
        L = [],
        I = e => {
          let t = e;
          return e < 0 ? t = g.length + e : t >= g.length && (t -= g.length), t;
        };
      if (e) s.slides.filter(e => e.matches(`.${s.params.slideClass}, swiper-slide`)).forEach(e => {
        e.remove();
      });else for (let e = m; e <= h; e += 1) if (e < S || e > T) {
        const t = I(e);
        s.slides.filter(e => e.matches(`.${s.params.slideClass}[data-swiper-slide-index="${t}"], swiper-slide[data-swiper-slide-index="${t}"]`)).forEach(e => {
          e.remove();
        });
      }
      const z = o ? -g.length : 0,
        A = o ? 2 * g.length : g.length;
      for (let t = z; t < A; t += 1) if (t >= S && t <= T) {
        const s = I(t);
        void 0 === h || e ? L.push(s) : (t > h && L.push(s), t < m && P.push(s));
      }
      if (L.forEach(e => {
        s.slidesEl.append(d(g[e], e));
      }), o) for (let e = P.length - 1; e >= 0; e -= 1) {
        const t = P[e];
        s.slidesEl.prepend(d(g[t], t));
      } else P.sort((e, t) => t - e), P.forEach(e => {
        s.slidesEl.prepend(d(g[e], e));
      });
      f(s.slidesEl, ".swiper-slide, swiper-slide").forEach(e => {
        e.style[y] = M - Math.abs(s.cssOverflowAdjustment()) + "px";
      }), C();
    }
    r("beforeInit", () => {
      if (!s.params.virtual.enabled) return;
      let e;
      if (void 0 === s.passedParams.virtual.slides) {
        const t = [...s.slidesEl.children].filter(e => e.matches(`.${s.params.slideClass}, swiper-slide`));
        t && t.length && (s.virtual.slides = [...t], e = !0, t.forEach((e, t) => {
          e.setAttribute("data-swiper-slide-index", t), s.virtual.cache[t] = e, e.remove();
        }));
      }
      e || (s.virtual.slides = s.params.virtual.slides), s.classNames.push(`${s.params.containerModifierClass}virtual`), s.params.watchSlidesProgress = !0, s.originalParams.watchSlidesProgress = !0, c(!1, !0);
    }), r("setTranslate", () => {
      s.params.virtual.enabled && (s.params.cssMode && !s._immediateVirtual ? (clearTimeout(t), t = setTimeout(() => {
        c();
      }, 100)) : c());
    }), r("init update resize", () => {
      s.params.virtual.enabled && s.params.cssMode && u(s.wrapperEl, "--swiper-virtual-size", `${s.virtualSize}px`);
    }), Object.assign(s.virtual, {
      appendSlide: function (e) {
        if ("object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.push(e[t]);else s.virtual.slides.push(e);
        c(!0);
      },
      prependSlide: function (e) {
        const t = s.activeIndex;
        let a = t + 1,
          i = 1;
        if (Array.isArray(e)) {
          for (let t = 0; t < e.length; t += 1) e[t] && s.virtual.slides.unshift(e[t]);
          a = t + e.length, i = e.length;
        } else s.virtual.slides.unshift(e);
        if (s.params.virtual.cache) {
          const e = s.virtual.cache,
            t = {};
          Object.keys(e).forEach(s => {
            const a = e[s],
              r = a.getAttribute("data-swiper-slide-index");
            r && a.setAttribute("data-swiper-slide-index", parseInt(r, 10) + i), t[parseInt(s, 10) + i] = a;
          }), s.virtual.cache = t;
        }
        c(!0), s.slideTo(a, 0);
      },
      removeSlide: function (e) {
        if (null == e) return;
        let t = s.activeIndex;
        if (Array.isArray(e)) for (let a = e.length - 1; a >= 0; a -= 1) s.params.virtual.cache && (delete s.virtual.cache[e[a]], Object.keys(s.virtual.cache).forEach(t => {
          t > e && (s.virtual.cache[t - 1] = s.virtual.cache[t], s.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete s.virtual.cache[t]);
        })), s.virtual.slides.splice(e[a], 1), e[a] < t && (t -= 1), t = Math.max(t, 0);else s.params.virtual.cache && (delete s.virtual.cache[e], Object.keys(s.virtual.cache).forEach(t => {
          t > e && (s.virtual.cache[t - 1] = s.virtual.cache[t], s.virtual.cache[t - 1].setAttribute("data-swiper-slide-index", t - 1), delete s.virtual.cache[t]);
        })), s.virtual.slides.splice(e, 1), e < t && (t -= 1), t = Math.max(t, 0);
        c(!0), s.slideTo(t, 0);
      },
      removeAllSlides: function () {
        s.virtual.slides = [], s.params.virtual.cache && (s.virtual.cache = {}), c(!0), s.slideTo(0, 0);
      },
      update: c
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: i,
      emit: n
    } = e;
    const l = a(),
      o = r();
    function d(e) {
      if (!t.enabled) return;
      const {
        rtlTranslate: s
      } = t;
      let a = e;
      a.originalEvent && (a = a.originalEvent);
      const i = a.keyCode || a.charCode,
        r = t.params.keyboard.pageUpDown,
        d = r && 33 === i,
        c = r && 34 === i,
        p = 37 === i,
        u = 39 === i,
        m = 38 === i,
        h = 40 === i;
      if (!t.allowSlideNext && (t.isHorizontal() && u || t.isVertical() && h || c)) return !1;
      if (!t.allowSlidePrev && (t.isHorizontal() && p || t.isVertical() && m || d)) return !1;
      if (!(a.shiftKey || a.altKey || a.ctrlKey || a.metaKey || l.activeElement && (l.activeElement.isContentEditable || l.activeElement.nodeName && ("input" === l.activeElement.nodeName.toLowerCase() || "textarea" === l.activeElement.nodeName.toLowerCase())))) {
        if (t.params.keyboard.onlyInViewport && (d || c || p || u || m || h)) {
          let e = !1;
          if (E(t.el, `.${t.params.slideClass}, swiper-slide`).length > 0 && 0 === E(t.el, `.${t.params.slideActiveClass}`).length) return;
          const a = t.el,
            i = a.clientWidth,
            r = a.clientHeight,
            n = o.innerWidth,
            l = o.innerHeight,
            d = w(a);
          s && (d.left -= a.scrollLeft);
          const c = [[d.left, d.top], [d.left + i, d.top], [d.left, d.top + r], [d.left + i, d.top + r]];
          for (let t = 0; t < c.length; t += 1) {
            const s = c[t];
            if (s[0] >= 0 && s[0] <= n && s[1] >= 0 && s[1] <= l) {
              if (0 === s[0] && 0 === s[1]) continue;
              e = !0;
            }
          }
          if (!e) return;
        }
        t.isHorizontal() ? ((d || c || p || u) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), ((c || u) && !s || (d || p) && s) && t.slideNext(), ((d || p) && !s || (c || u) && s) && t.slidePrev()) : ((d || c || m || h) && (a.preventDefault ? a.preventDefault() : a.returnValue = !1), (c || h) && t.slideNext(), (d || m) && t.slidePrev()), n("keyPress", i);
      }
    }
    function c() {
      t.keyboard.enabled || (l.addEventListener("keydown", d), t.keyboard.enabled = !0);
    }
    function p() {
      t.keyboard.enabled && (l.removeEventListener("keydown", d), t.keyboard.enabled = !1);
    }
    t.keyboard = {
      enabled: !1
    }, s({
      keyboard: {
        enabled: !1,
        onlyInViewport: !0,
        pageUpDown: !0
      }
    }), i("init", () => {
      t.params.keyboard.enabled && c();
    }), i("destroy", () => {
      t.keyboard.enabled && p();
    }), Object.assign(t.keyboard, {
      enable: c,
      disable: p
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a,
      emit: i
    } = e;
    const n = r();
    let d;
    s({
      mousewheel: {
        enabled: !1,
        releaseOnEdges: !1,
        invert: !1,
        forceToAxis: !1,
        sensitivity: 1,
        eventsTarget: "container",
        thresholdDelta: null,
        thresholdTime: null,
        noMousewheelClass: "swiper-no-mousewheel"
      }
    }), t.mousewheel = {
      enabled: !1
    };
    let c,
      p = o();
    const u = [];
    function m() {
      t.enabled && (t.mouseEntered = !0);
    }
    function h() {
      t.enabled && (t.mouseEntered = !1);
    }
    function f(e) {
      return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta) && !(t.params.mousewheel.thresholdTime && o() - p < t.params.mousewheel.thresholdTime) && (e.delta >= 6 && o() - p < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), i("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), i("scroll", e.raw)), p = new n.Date().getTime(), !1));
    }
    function g(e) {
      let s = e,
        a = !0;
      if (!t.enabled) return;
      if (e.target.closest(`.${t.params.mousewheel.noMousewheelClass}`)) return;
      const r = t.params.mousewheel;
      t.params.cssMode && s.preventDefault();
      let n = t.el;
      "container" !== t.params.mousewheel.eventsTarget && (n = document.querySelector(t.params.mousewheel.eventsTarget));
      const p = n && n.contains(s.target);
      if (!t.mouseEntered && !p && !r.releaseOnEdges) return !0;
      s.originalEvent && (s = s.originalEvent);
      let m = 0;
      const h = t.rtlTranslate ? -1 : 1,
        g = function (e) {
          let t = 0,
            s = 0,
            a = 0,
            i = 0;
          return "detail" in e && (s = e.detail), "wheelDelta" in e && (s = -e.wheelDelta / 120), "wheelDeltaY" in e && (s = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = s, s = 0), a = 10 * t, i = 10 * s, "deltaY" in e && (i = e.deltaY), "deltaX" in e && (a = e.deltaX), e.shiftKey && !a && (a = i, i = 0), (a || i) && e.deltaMode && (1 === e.deltaMode ? (a *= 40, i *= 40) : (a *= 800, i *= 800)), a && !t && (t = a < 1 ? -1 : 1), i && !s && (s = i < 1 ? -1 : 1), {
            spinX: t,
            spinY: s,
            pixelX: a,
            pixelY: i
          };
        }(s);
      if (r.forceToAxis) {
        if (t.isHorizontal()) {
          if (!(Math.abs(g.pixelX) > Math.abs(g.pixelY))) return !0;
          m = -g.pixelX * h;
        } else {
          if (!(Math.abs(g.pixelY) > Math.abs(g.pixelX))) return !0;
          m = -g.pixelY;
        }
      } else m = Math.abs(g.pixelX) > Math.abs(g.pixelY) ? -g.pixelX * h : -g.pixelY;
      if (0 === m) return !0;
      r.invert && (m = -m);
      let v = t.getTranslate() + m * r.sensitivity;
      if (v >= t.minTranslate() && (v = t.minTranslate()), v <= t.maxTranslate() && (v = t.maxTranslate()), a = !!t.params.loop || !(v === t.minTranslate() || v === t.maxTranslate()), a && t.params.nested && s.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) {
        const e = {
            time: o(),
            delta: Math.abs(m),
            direction: Math.sign(m)
          },
          a = c && e.time < c.time + 500 && e.delta <= c.delta && e.direction === c.direction;
        if (!a) {
          c = void 0;
          let n = t.getTranslate() + m * r.sensitivity;
          const o = t.isBeginning,
            p = t.isEnd;
          if (n >= t.minTranslate() && (n = t.minTranslate()), n <= t.maxTranslate() && (n = t.maxTranslate()), t.setTransition(0), t.setTranslate(n), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!o && t.isBeginning || !p && t.isEnd) && t.updateSlidesClasses(), t.params.loop && t.loopFix({
            direction: e.direction < 0 ? "next" : "prev",
            byMousewheel: !0
          }), t.params.freeMode.sticky) {
            clearTimeout(d), d = void 0, u.length >= 15 && u.shift();
            const s = u.length ? u[u.length - 1] : void 0,
              a = u[0];
            if (u.push(e), s && (e.delta > s.delta || e.direction !== s.direction)) u.splice(0);else if (u.length >= 15 && e.time - a.time < 500 && a.delta - e.delta >= 1 && e.delta <= 6) {
              const s = m > 0 ? .8 : .2;
              c = e, u.splice(0), d = l(() => {
                !t.destroyed && t.params && t.slideToClosest(t.params.speed, !0, void 0, s);
              }, 0);
            }
            d || (d = l(() => {
              if (t.destroyed || !t.params) return;
              c = e, u.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5);
            }, 500));
          }
          if (a || i("scroll", s), t.params.autoplay && t.params.autoplay.disableOnInteraction && t.autoplay.stop(), r.releaseOnEdges && (n === t.minTranslate() || n === t.maxTranslate())) return !0;
        }
      } else {
        const s = {
          time: o(),
          delta: Math.abs(m),
          direction: Math.sign(m),
          raw: e
        };
        u.length >= 2 && u.shift();
        const a = u.length ? u[u.length - 1] : void 0;
        if (u.push(s), a ? (s.direction !== a.direction || s.delta > a.delta || s.time > a.time + 150) && f(s) : f(s), function (e) {
          const s = t.params.mousewheel;
          if (e.direction < 0) {
            if (t.isEnd && !t.params.loop && s.releaseOnEdges) return !0;
          } else if (t.isBeginning && !t.params.loop && s.releaseOnEdges) return !0;
          return !1;
        }(s)) return !0;
      }
      return s.preventDefault ? s.preventDefault() : s.returnValue = !1, !1;
    }
    function v(e) {
      let s = t.el;
      "container" !== t.params.mousewheel.eventsTarget && (s = document.querySelector(t.params.mousewheel.eventsTarget)), s[e]("mouseenter", m), s[e]("mouseleave", h), s[e]("wheel", g);
    }
    function w() {
      return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", g), !0) : !t.mousewheel.enabled && (v("addEventListener"), t.mousewheel.enabled = !0, !0);
    }
    function b() {
      return t.params.cssMode ? (t.wrapperEl.addEventListener(event, g), !0) : !!t.mousewheel.enabled && (v("removeEventListener"), t.mousewheel.enabled = !1, !0);
    }
    a("init", () => {
      !t.params.mousewheel.enabled && t.params.cssMode && b(), t.params.mousewheel.enabled && w();
    }), a("destroy", () => {
      t.params.cssMode && w(), t.mousewheel.enabled && b();
    }), Object.assign(t.mousewheel, {
      enable: w,
      disable: b
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a,
      emit: i
    } = e;
    function r(e) {
      let s;
      return e && "string" == typeof e && t.isElement && (s = t.el.querySelector(e) || t.hostEl.querySelector(e), s) ? s : (e && ("string" == typeof e && (s = [...document.querySelectorAll(e)]), t.params.uniqueNavElements && "string" == typeof e && s && s.length > 1 && 1 === t.el.querySelectorAll(e).length ? s = t.el.querySelector(e) : s && 1 === s.length && (s = s[0])), e && !s ? e : s);
    }
    function n(e, s) {
      const a = t.params.navigation;
      (e = T(e)).forEach(e => {
        e && (e.classList[s ? "add" : "remove"](...a.disabledClass.split(" ")), "BUTTON" === e.tagName && (e.disabled = s), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](a.lockClass));
      });
    }
    function l() {
      const {
        nextEl: e,
        prevEl: s
      } = t.navigation;
      if (t.params.loop) return n(s, !1), void n(e, !1);
      n(s, t.isBeginning && !t.params.rewind), n(e, t.isEnd && !t.params.rewind);
    }
    function o(e) {
      e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), i("navigationPrev"));
    }
    function d(e) {
      e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), i("navigationNext"));
    }
    function c() {
      const e = t.params.navigation;
      if (t.params.navigation = ne(t, t.originalParams.navigation, t.params.navigation, {
        nextEl: "swiper-button-next",
        prevEl: "swiper-button-prev"
      }), !e.nextEl && !e.prevEl) return;
      let s = r(e.nextEl),
        a = r(e.prevEl);
      Object.assign(t.navigation, {
        nextEl: s,
        prevEl: a
      }), s = T(s), a = T(a);
      const i = (s, a) => {
        s && s.addEventListener("click", "next" === a ? d : o), !t.enabled && s && s.classList.add(...e.lockClass.split(" "));
      };
      s.forEach(e => i(e, "next")), a.forEach(e => i(e, "prev"));
    }
    function p() {
      let {
        nextEl: e,
        prevEl: s
      } = t.navigation;
      e = T(e), s = T(s);
      const a = (e, s) => {
        e.removeEventListener("click", "next" === s ? d : o), e.classList.remove(...t.params.navigation.disabledClass.split(" "));
      };
      e.forEach(e => a(e, "next")), s.forEach(e => a(e, "prev"));
    }
    s({
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: !1,
        disabledClass: "swiper-button-disabled",
        hiddenClass: "swiper-button-hidden",
        lockClass: "swiper-button-lock",
        navigationDisabledClass: "swiper-navigation-disabled"
      }
    }), t.navigation = {
      nextEl: null,
      prevEl: null
    }, a("init", () => {
      !1 === t.params.navigation.enabled ? u() : (c(), l());
    }), a("toEdge fromEdge lock unlock", () => {
      l();
    }), a("destroy", () => {
      p();
    }), a("enable disable", () => {
      let {
        nextEl: e,
        prevEl: s
      } = t.navigation;
      e = T(e), s = T(s), t.enabled ? l() : [...e, ...s].filter(e => !!e).forEach(e => e.classList.add(t.params.navigation.lockClass));
    }), a("click", (e, s) => {
      let {
        nextEl: a,
        prevEl: r
      } = t.navigation;
      a = T(a), r = T(r);
      const n = s.target;
      let l = r.includes(n) || a.includes(n);
      if (t.isElement && !l) {
        const e = s.path || s.composedPath && s.composedPath();
        e && (l = e.find(e => a.includes(e) || r.includes(e)));
      }
      if (t.params.navigation.hideOnClick && !l) {
        if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === n || t.pagination.el.contains(n))) return;
        let e;
        a.length ? e = a[0].classList.contains(t.params.navigation.hiddenClass) : r.length && (e = r[0].classList.contains(t.params.navigation.hiddenClass)), i(!0 === e ? "navigationShow" : "navigationHide"), [...a, ...r].filter(e => !!e).forEach(e => e.classList.toggle(t.params.navigation.hiddenClass));
      }
    });
    const u = () => {
      t.el.classList.add(...t.params.navigation.navigationDisabledClass.split(" ")), p();
    };
    Object.assign(t.navigation, {
      enable: () => {
        t.el.classList.remove(...t.params.navigation.navigationDisabledClass.split(" ")), c(), l();
      },
      disable: u,
      update: l,
      init: c,
      destroy: p
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a,
      emit: i
    } = e;
    const r = "swiper-pagination";
    let n;
    s({
      pagination: {
        el: null,
        bulletElement: "span",
        clickable: !1,
        hideOnClick: !1,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: !1,
        type: "bullets",
        dynamicBullets: !1,
        dynamicMainBullets: 1,
        formatFractionCurrent: e => e,
        formatFractionTotal: e => e,
        bulletClass: `${r}-bullet`,
        bulletActiveClass: `${r}-bullet-active`,
        modifierClass: `${r}-`,
        currentClass: `${r}-current`,
        totalClass: `${r}-total`,
        hiddenClass: `${r}-hidden`,
        progressbarFillClass: `${r}-progressbar-fill`,
        progressbarOppositeClass: `${r}-progressbar-opposite`,
        clickableClass: `${r}-clickable`,
        lockClass: `${r}-lock`,
        horizontalClass: `${r}-horizontal`,
        verticalClass: `${r}-vertical`,
        paginationDisabledClass: `${r}-disabled`
      }
    }), t.pagination = {
      el: null,
      bullets: []
    };
    let l = 0;
    function o() {
      return !t.params.pagination.el || !t.pagination.el || Array.isArray(t.pagination.el) && 0 === t.pagination.el.length;
    }
    function d(e, s) {
      const {
        bulletActiveClass: a
      } = t.params.pagination;
      e && (e = e[("prev" === s ? "previous" : "next") + "ElementSibling"]) && (e.classList.add(`${a}-${s}`), (e = e[("prev" === s ? "previous" : "next") + "ElementSibling"]) && e.classList.add(`${a}-${s}-${s}`));
    }
    function c(e) {
      const s = e.target.closest(le(t.params.pagination.bulletClass));
      if (!s) return;
      e.preventDefault();
      const a = y(s) * t.params.slidesPerGroup;
      if (t.params.loop) {
        if (t.realIndex === a) return;
        const e = (i = t.realIndex, r = a, n = t.slides.length, (r %= n) == 1 + (i %= n) ? "next" : r === i - 1 ? "previous" : void 0);
        "next" === e ? t.slideNext() : "previous" === e ? t.slidePrev() : t.slideToLoop(a);
      } else t.slideTo(a);
      var i, r, n;
    }
    function p() {
      const e = t.rtl,
        s = t.params.pagination;
      if (o()) return;
      let a,
        r,
        c = t.pagination.el;
      c = T(c);
      const p = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
        u = t.params.loop ? Math.ceil(p / t.params.slidesPerGroup) : t.snapGrid.length;
      if (t.params.loop ? (r = t.previousRealIndex || 0, a = t.params.slidesPerGroup > 1 ? Math.floor(t.realIndex / t.params.slidesPerGroup) : t.realIndex) : void 0 !== t.snapIndex ? (a = t.snapIndex, r = t.previousSnapIndex) : (r = t.previousIndex || 0, a = t.activeIndex || 0), "bullets" === s.type && t.pagination.bullets && t.pagination.bullets.length > 0) {
        const i = t.pagination.bullets;
        let o, p, u;
        if (s.dynamicBullets && (n = S(i[0], t.isHorizontal() ? "width" : "height", !0), c.forEach(e => {
          e.style[t.isHorizontal() ? "width" : "height"] = n * (s.dynamicMainBullets + 4) + "px";
        }), s.dynamicMainBullets > 1 && void 0 !== r && (l += a - (r || 0), l > s.dynamicMainBullets - 1 ? l = s.dynamicMainBullets - 1 : l < 0 && (l = 0)), o = Math.max(a - l, 0), p = o + (Math.min(i.length, s.dynamicMainBullets) - 1), u = (p + o) / 2), i.forEach(e => {
          const t = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(e => `${s.bulletActiveClass}${e}`)].map(e => "string" == typeof e && e.includes(" ") ? e.split(" ") : e).flat();
          e.classList.remove(...t);
        }), c.length > 1) i.forEach(e => {
          const i = y(e);
          i === a ? e.classList.add(...s.bulletActiveClass.split(" ")) : t.isElement && e.setAttribute("part", "bullet"), s.dynamicBullets && (i >= o && i <= p && e.classList.add(...`${s.bulletActiveClass}-main`.split(" ")), i === o && d(e, "prev"), i === p && d(e, "next"));
        });else {
          const e = i[a];
          if (e && e.classList.add(...s.bulletActiveClass.split(" ")), t.isElement && i.forEach((e, t) => {
            e.setAttribute("part", t === a ? "bullet-active" : "bullet");
          }), s.dynamicBullets) {
            const e = i[o],
              t = i[p];
            for (let e = o; e <= p; e += 1) i[e] && i[e].classList.add(...`${s.bulletActiveClass}-main`.split(" "));
            d(e, "prev"), d(t, "next");
          }
        }
        if (s.dynamicBullets) {
          const a = Math.min(i.length, s.dynamicMainBullets + 4),
            r = (n * a - n) / 2 - u * n,
            l = e ? "right" : "left";
          i.forEach(e => {
            e.style[t.isHorizontal() ? l : "top"] = `${r}px`;
          });
        }
      }
      c.forEach((e, r) => {
        if ("fraction" === s.type && (e.querySelectorAll(le(s.currentClass)).forEach(e => {
          e.textContent = s.formatFractionCurrent(a + 1);
        }), e.querySelectorAll(le(s.totalClass)).forEach(e => {
          e.textContent = s.formatFractionTotal(u);
        })), "progressbar" === s.type) {
          let i;
          i = s.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical";
          const r = (a + 1) / u;
          let n = 1,
            l = 1;
          "horizontal" === i ? n = r : l = r, e.querySelectorAll(le(s.progressbarFillClass)).forEach(e => {
            e.style.transform = `translate3d(0,0,0) scaleX(${n}) scaleY(${l})`, e.style.transitionDuration = `${t.params.speed}ms`;
          });
        }
        "custom" === s.type && s.renderCustom ? (C(e, s.renderCustom(t, a + 1, u)), 0 === r && i("paginationRender", e)) : (0 === r && i("paginationRender", e), i("paginationUpdate", e)), t.params.watchOverflow && t.enabled && e.classList[t.isLocked ? "add" : "remove"](s.lockClass);
      });
    }
    function u() {
      const e = t.params.pagination;
      if (o()) return;
      const s = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.grid && t.params.grid.rows > 1 ? t.slides.length / Math.ceil(t.params.grid.rows) : t.slides.length;
      let a = t.pagination.el;
      a = T(a);
      let r = "";
      if ("bullets" === e.type) {
        let a = t.params.loop ? Math.ceil(s / t.params.slidesPerGroup) : t.snapGrid.length;
        t.params.freeMode && t.params.freeMode.enabled && a > s && (a = s);
        for (let s = 0; s < a; s += 1) e.renderBullet ? r += e.renderBullet.call(t, s, e.bulletClass) : r += `<${e.bulletElement} ${t.isElement ? 'part="bullet"' : ""} class="${e.bulletClass}"></${e.bulletElement}>`;
      }
      "fraction" === e.type && (r = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`), "progressbar" === e.type && (r = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`), t.pagination.bullets = [], a.forEach(s => {
        "custom" !== e.type && C(s, r || ""), "bullets" === e.type && t.pagination.bullets.push(...s.querySelectorAll(le(e.bulletClass)));
      }), "custom" !== e.type && i("paginationRender", a[0]);
    }
    function m() {
      t.params.pagination = ne(t, t.originalParams.pagination, t.params.pagination, {
        el: "swiper-pagination"
      });
      const e = t.params.pagination;
      if (!e.el) return;
      let s;
      "string" == typeof e.el && t.isElement && (s = t.el.querySelector(e.el)), s || "string" != typeof e.el || (s = [...document.querySelectorAll(e.el)]), s || (s = e.el), s && 0 !== s.length && (t.params.uniqueNavElements && "string" == typeof e.el && Array.isArray(s) && s.length > 1 && (s = [...t.el.querySelectorAll(e.el)], s.length > 1 && (s = s.find(e => E(e, ".swiper")[0] === t.el))), Array.isArray(s) && 1 === s.length && (s = s[0]), Object.assign(t.pagination, {
        el: s
      }), s = T(s), s.forEach(s => {
        "bullets" === e.type && e.clickable && s.classList.add(...(e.clickableClass || "").split(" ")), s.classList.add(e.modifierClass + e.type), s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (s.classList.add(`${e.modifierClass}${e.type}-dynamic`), l = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && s.classList.add(e.progressbarOppositeClass), e.clickable && s.addEventListener("click", c), t.enabled || s.classList.add(e.lockClass);
      }));
    }
    function h() {
      const e = t.params.pagination;
      if (o()) return;
      let s = t.pagination.el;
      s && (s = T(s), s.forEach(s => {
        s.classList.remove(e.hiddenClass), s.classList.remove(e.modifierClass + e.type), s.classList.remove(t.isHorizontal() ? e.horizontalClass : e.verticalClass), e.clickable && (s.classList.remove(...(e.clickableClass || "").split(" ")), s.removeEventListener("click", c));
      })), t.pagination.bullets && t.pagination.bullets.forEach(t => t.classList.remove(...e.bulletActiveClass.split(" ")));
    }
    a("changeDirection", () => {
      if (!t.pagination || !t.pagination.el) return;
      const e = t.params.pagination;
      let {
        el: s
      } = t.pagination;
      s = T(s), s.forEach(s => {
        s.classList.remove(e.horizontalClass, e.verticalClass), s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass);
      });
    }), a("init", () => {
      !1 === t.params.pagination.enabled ? f() : (m(), u(), p());
    }), a("activeIndexChange", () => {
      void 0 === t.snapIndex && p();
    }), a("snapIndexChange", () => {
      p();
    }), a("snapGridLengthChange", () => {
      u(), p();
    }), a("destroy", () => {
      h();
    }), a("enable disable", () => {
      let {
        el: e
      } = t.pagination;
      e && (e = T(e), e.forEach(e => e.classList[t.enabled ? "remove" : "add"](t.params.pagination.lockClass)));
    }), a("lock unlock", () => {
      p();
    }), a("click", (e, s) => {
      const a = s.target,
        r = T(t.pagination.el);
      if (t.params.pagination.el && t.params.pagination.hideOnClick && r && r.length > 0 && !a.classList.contains(t.params.pagination.bulletClass)) {
        if (t.navigation && (t.navigation.nextEl && a === t.navigation.nextEl || t.navigation.prevEl && a === t.navigation.prevEl)) return;
        const e = r[0].classList.contains(t.params.pagination.hiddenClass);
        i(!0 === e ? "paginationShow" : "paginationHide"), r.forEach(e => e.classList.toggle(t.params.pagination.hiddenClass));
      }
    });
    const f = () => {
      t.el.classList.add(t.params.pagination.paginationDisabledClass);
      let {
        el: e
      } = t.pagination;
      e && (e = T(e), e.forEach(e => e.classList.add(t.params.pagination.paginationDisabledClass))), h();
    };
    Object.assign(t.pagination, {
      enable: () => {
        t.el.classList.remove(t.params.pagination.paginationDisabledClass);
        let {
          el: e
        } = t.pagination;
        e && (e = T(e), e.forEach(e => e.classList.remove(t.params.pagination.paginationDisabledClass))), m(), u(), p();
      },
      disable: f,
      render: u,
      update: p,
      init: m,
      destroy: h
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: i,
      emit: r
    } = e;
    const o = a();
    let d,
      c,
      p,
      u,
      m = !1,
      h = null,
      f = null;
    function g() {
      if (!t.params.scrollbar.el || !t.scrollbar.el) return;
      const {
          scrollbar: e,
          rtlTranslate: s
        } = t,
        {
          dragEl: a,
          el: i
        } = e,
        r = t.params.scrollbar,
        n = t.params.loop ? t.progressLoop : t.progress;
      let l = c,
        o = (p - c) * n;
      s ? (o = -o, o > 0 ? (l = c - o, o = 0) : -o + c > p && (l = p + o)) : o < 0 ? (l = c + o, o = 0) : o + c > p && (l = p - o), t.isHorizontal() ? (a.style.transform = `translate3d(${o}px, 0, 0)`, a.style.width = `${l}px`) : (a.style.transform = `translate3d(0px, ${o}px, 0)`, a.style.height = `${l}px`), r.hide && (clearTimeout(h), i.style.opacity = 1, h = setTimeout(() => {
        i.style.opacity = 0, i.style.transitionDuration = "400ms";
      }, 1e3));
    }
    function b() {
      if (!t.params.scrollbar.el || !t.scrollbar.el) return;
      const {
          scrollbar: e
        } = t,
        {
          dragEl: s,
          el: a
        } = e;
      s.style.width = "", s.style.height = "", p = t.isHorizontal() ? a.offsetWidth : a.offsetHeight, u = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), c = "auto" === t.params.scrollbar.dragSize ? p * u : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? s.style.width = `${c}px` : s.style.height = `${c}px`, a.style.display = u >= 1 ? "none" : "", t.params.scrollbar.hide && (a.style.opacity = 0), t.params.watchOverflow && t.enabled && e.el.classList[t.isLocked ? "add" : "remove"](t.params.scrollbar.lockClass);
    }
    function y(e) {
      return t.isHorizontal() ? e.clientX : e.clientY;
    }
    function E(e) {
      const {
          scrollbar: s,
          rtlTranslate: a
        } = t,
        {
          el: i
        } = s;
      let r;
      r = (y(e) - w(i)[t.isHorizontal() ? "left" : "top"] - (null !== d ? d : c / 2)) / (p - c), r = Math.max(Math.min(r, 1), 0), a && (r = 1 - r);
      const n = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * r;
      t.updateProgress(n), t.setTranslate(n), t.updateActiveIndex(), t.updateSlidesClasses();
    }
    function x(e) {
      const s = t.params.scrollbar,
        {
          scrollbar: a,
          wrapperEl: i
        } = t,
        {
          el: n,
          dragEl: l
        } = a;
      m = !0, d = e.target === l ? y(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), i.style.transitionDuration = "100ms", l.style.transitionDuration = "100ms", E(e), clearTimeout(f), n.style.transitionDuration = "0ms", s.hide && (n.style.opacity = 1), t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "none"), r("scrollbarDragStart", e);
    }
    function S(e) {
      const {
          scrollbar: s,
          wrapperEl: a
        } = t,
        {
          el: i,
          dragEl: n
        } = s;
      m && (e.preventDefault && e.cancelable ? e.preventDefault() : e.returnValue = !1, E(e), a.style.transitionDuration = "0ms", i.style.transitionDuration = "0ms", n.style.transitionDuration = "0ms", r("scrollbarDragMove", e));
    }
    function M(e) {
      const s = t.params.scrollbar,
        {
          scrollbar: a,
          wrapperEl: i
        } = t,
        {
          el: n
        } = a;
      m && (m = !1, t.params.cssMode && (t.wrapperEl.style["scroll-snap-type"] = "", i.style.transitionDuration = ""), s.hide && (clearTimeout(f), f = l(() => {
        n.style.opacity = 0, n.style.transitionDuration = "400ms";
      }, 1e3)), r("scrollbarDragEnd", e), s.snapOnRelease && t.slideToClosest());
    }
    function C(e) {
      const {
          scrollbar: s,
          params: a
        } = t,
        i = s.el;
      if (!i) return;
      const r = i,
        n = !!a.passiveListeners && {
          passive: !1,
          capture: !1
        },
        l = !!a.passiveListeners && {
          passive: !0,
          capture: !1
        };
      if (!r) return;
      const d = "on" === e ? "addEventListener" : "removeEventListener";
      r[d]("pointerdown", x, n), o[d]("pointermove", S, n), o[d]("pointerup", M, l);
    }
    function P() {
      const {
        scrollbar: e,
        el: s
      } = t;
      t.params.scrollbar = ne(t, t.originalParams.scrollbar, t.params.scrollbar, {
        el: "swiper-scrollbar"
      });
      const a = t.params.scrollbar;
      if (!a.el) return;
      let i, r;
      if ("string" == typeof a.el && t.isElement && (i = t.el.querySelector(a.el)), i || "string" != typeof a.el) i || (i = a.el);else if (i = o.querySelectorAll(a.el), !i.length) return;
      t.params.uniqueNavElements && "string" == typeof a.el && i.length > 1 && 1 === s.querySelectorAll(a.el).length && (i = s.querySelector(a.el)), i.length > 0 && (i = i[0]), i.classList.add(t.isHorizontal() ? a.horizontalClass : a.verticalClass), i && (r = i.querySelector(le(t.params.scrollbar.dragClass)), r || (r = v("div", t.params.scrollbar.dragClass), i.append(r))), Object.assign(e, {
        el: i,
        dragEl: r
      }), a.draggable && t.params.scrollbar.el && t.scrollbar.el && C("on"), i && i.classList[t.enabled ? "remove" : "add"](...n(t.params.scrollbar.lockClass));
    }
    function L() {
      const e = t.params.scrollbar,
        s = t.scrollbar.el;
      s && s.classList.remove(...n(t.isHorizontal() ? e.horizontalClass : e.verticalClass)), t.params.scrollbar.el && t.scrollbar.el && C("off");
    }
    s({
      scrollbar: {
        el: null,
        dragSize: "auto",
        hide: !1,
        draggable: !1,
        snapOnRelease: !0,
        lockClass: "swiper-scrollbar-lock",
        dragClass: "swiper-scrollbar-drag",
        scrollbarDisabledClass: "swiper-scrollbar-disabled",
        horizontalClass: "swiper-scrollbar-horizontal",
        verticalClass: "swiper-scrollbar-vertical"
      }
    }), t.scrollbar = {
      el: null,
      dragEl: null
    }, i("changeDirection", () => {
      if (!t.scrollbar || !t.scrollbar.el) return;
      const e = t.params.scrollbar;
      let {
        el: s
      } = t.scrollbar;
      s = T(s), s.forEach(s => {
        s.classList.remove(e.horizontalClass, e.verticalClass), s.classList.add(t.isHorizontal() ? e.horizontalClass : e.verticalClass);
      });
    }), i("init", () => {
      !1 === t.params.scrollbar.enabled ? I() : (P(), b(), g());
    }), i("update resize observerUpdate lock unlock changeDirection", () => {
      b();
    }), i("setTranslate", () => {
      g();
    }), i("setTransition", (e, s) => {
      !function (e) {
        t.params.scrollbar.el && t.scrollbar.el && (t.scrollbar.dragEl.style.transitionDuration = `${e}ms`);
      }(s);
    }), i("enable disable", () => {
      const {
        el: e
      } = t.scrollbar;
      e && e.classList[t.enabled ? "remove" : "add"](...n(t.params.scrollbar.lockClass));
    }), i("destroy", () => {
      L();
    });
    const I = () => {
      t.el.classList.add(...n(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.add(...n(t.params.scrollbar.scrollbarDisabledClass)), L();
    };
    Object.assign(t.scrollbar, {
      enable: () => {
        t.el.classList.remove(...n(t.params.scrollbar.scrollbarDisabledClass)), t.scrollbar.el && t.scrollbar.el.classList.remove(...n(t.params.scrollbar.scrollbarDisabledClass)), P(), b(), g();
      },
      disable: I,
      updateSize: b,
      setTranslate: g,
      init: P,
      destroy: L
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      parallax: {
        enabled: !1
      }
    });
    const i = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]",
      r = (e, s) => {
        const {
            rtl: a
          } = t,
          i = a ? -1 : 1,
          r = e.getAttribute("data-swiper-parallax") || "0";
        let n = e.getAttribute("data-swiper-parallax-x"),
          l = e.getAttribute("data-swiper-parallax-y");
        const o = e.getAttribute("data-swiper-parallax-scale"),
          d = e.getAttribute("data-swiper-parallax-opacity"),
          c = e.getAttribute("data-swiper-parallax-rotate");
        if (n || l ? (n = n || "0", l = l || "0") : t.isHorizontal() ? (n = r, l = "0") : (l = r, n = "0"), n = n.indexOf("%") >= 0 ? parseInt(n, 10) * s * i + "%" : n * s * i + "px", l = l.indexOf("%") >= 0 ? parseInt(l, 10) * s + "%" : l * s + "px", null != d) {
          const t = d - (d - 1) * (1 - Math.abs(s));
          e.style.opacity = t;
        }
        let p = `translate3d(${n}, ${l}, 0px)`;
        if (null != o) {
          p += ` scale(${o - (o - 1) * (1 - Math.abs(s))})`;
        }
        if (c && null != c) {
          p += ` rotate(${c * s * -1}deg)`;
        }
        e.style.transform = p;
      },
      n = () => {
        const {
            el: e,
            slides: s,
            progress: a,
            snapGrid: n,
            isElement: l
          } = t,
          o = f(e, i);
        t.isElement && o.push(...f(t.hostEl, i)), o.forEach(e => {
          r(e, a);
        }), s.forEach((e, s) => {
          let l = e.progress;
          t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (l += Math.ceil(s / 2) - a * (n.length - 1)), l = Math.min(Math.max(l, -1), 1), e.querySelectorAll(`${i}, [data-swiper-parallax-rotate]`).forEach(e => {
            r(e, l);
          });
        });
      };
    a("beforeInit", () => {
      t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0);
    }), a("init", () => {
      t.params.parallax.enabled && n();
    }), a("setTranslate", () => {
      t.params.parallax.enabled && n();
    }), a("setTransition", (e, s) => {
      t.params.parallax.enabled && function (e) {
        void 0 === e && (e = t.params.speed);
        const {
            el: s,
            hostEl: a
          } = t,
          r = [...s.querySelectorAll(i)];
        t.isElement && r.push(...a.querySelectorAll(i)), r.forEach(t => {
          let s = parseInt(t.getAttribute("data-swiper-parallax-duration"), 10) || e;
          0 === e && (s = 0), t.style.transitionDuration = `${s}ms`;
        });
      }(s);
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a,
      emit: i
    } = e;
    const n = r();
    s({
      zoom: {
        enabled: !1,
        limitToOriginalSize: !1,
        maxRatio: 3,
        minRatio: 1,
        panOnMouseMove: !1,
        toggle: !0,
        containerClass: "swiper-zoom-container",
        zoomedSlideClass: "swiper-slide-zoomed"
      }
    }), t.zoom = {
      enabled: !1
    };
    let l = 1,
      o = !1,
      c = !1,
      p = {
        x: 0,
        y: 0
      };
    const u = -3;
    let m, h;
    const g = [],
      v = {
        originX: 0,
        originY: 0,
        slideEl: void 0,
        slideWidth: void 0,
        slideHeight: void 0,
        imageEl: void 0,
        imageWrapEl: void 0,
        maxRatio: 3
      },
      b = {
        isTouched: void 0,
        isMoved: void 0,
        currentX: void 0,
        currentY: void 0,
        minX: void 0,
        minY: void 0,
        maxX: void 0,
        maxY: void 0,
        width: void 0,
        height: void 0,
        startX: void 0,
        startY: void 0,
        touchesStart: {},
        touchesCurrent: {}
      },
      y = {
        x: void 0,
        y: void 0,
        prevPositionX: void 0,
        prevPositionY: void 0,
        prevTime: void 0
      };
    let x,
      S = 1;
    function T() {
      if (g.length < 2) return 1;
      const e = g[0].pageX,
        t = g[0].pageY,
        s = g[1].pageX,
        a = g[1].pageY;
      return Math.sqrt((s - e) ** 2 + (a - t) ** 2);
    }
    function M() {
      const e = t.params.zoom,
        s = v.imageWrapEl.getAttribute("data-swiper-zoom") || e.maxRatio;
      if (e.limitToOriginalSize && v.imageEl && v.imageEl.naturalWidth) {
        const e = v.imageEl.naturalWidth / v.imageEl.offsetWidth;
        return Math.min(e, s);
      }
      return s;
    }
    function C(e) {
      const s = t.isElement ? "swiper-slide" : `.${t.params.slideClass}`;
      return !!e.target.matches(s) || t.slides.filter(t => t.contains(e.target)).length > 0;
    }
    function P(e) {
      const s = `.${t.params.zoom.containerClass}`;
      return !!e.target.matches(s) || [...t.hostEl.querySelectorAll(s)].filter(t => t.contains(e.target)).length > 0;
    }
    function L(e) {
      if ("mouse" === e.pointerType && g.splice(0, g.length), !C(e)) return;
      const s = t.params.zoom;
      if (m = !1, h = !1, g.push(e), !(g.length < 2)) {
        if (m = !0, v.scaleStart = T(), !v.slideEl) {
          v.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`), v.slideEl || (v.slideEl = t.slides[t.activeIndex]);
          let a = v.slideEl.querySelector(`.${s.containerClass}`);
          if (a && (a = a.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), v.imageEl = a, v.imageWrapEl = a ? E(v.imageEl, `.${s.containerClass}`)[0] : void 0, !v.imageWrapEl) return void (v.imageEl = void 0);
          v.maxRatio = M();
        }
        if (v.imageEl) {
          const [e, t] = function () {
            if (g.length < 2) return {
              x: null,
              y: null
            };
            const e = v.imageEl.getBoundingClientRect();
            return [(g[0].pageX + (g[1].pageX - g[0].pageX) / 2 - e.x - n.scrollX) / l, (g[0].pageY + (g[1].pageY - g[0].pageY) / 2 - e.y - n.scrollY) / l];
          }();
          v.originX = e, v.originY = t, v.imageEl.style.transitionDuration = "0ms";
        }
        o = !0;
      }
    }
    function I(e) {
      if (!C(e)) return;
      const s = t.params.zoom,
        a = t.zoom,
        i = g.findIndex(t => t.pointerId === e.pointerId);
      i >= 0 && (g[i] = e), g.length < 2 || (h = !0, v.scaleMove = T(), v.imageEl && (a.scale = v.scaleMove / v.scaleStart * l, a.scale > v.maxRatio && (a.scale = v.maxRatio - 1 + (a.scale - v.maxRatio + 1) ** .5), a.scale < s.minRatio && (a.scale = s.minRatio + 1 - (s.minRatio - a.scale + 1) ** .5), v.imageEl.style.transform = `translate3d(0,0,0) scale(${a.scale})`));
    }
    function z(e) {
      if (!C(e)) return;
      if ("mouse" === e.pointerType && "pointerout" === e.type) return;
      const s = t.params.zoom,
        a = t.zoom,
        i = g.findIndex(t => t.pointerId === e.pointerId);
      i >= 0 && g.splice(i, 1), m && h && (m = !1, h = !1, v.imageEl && (a.scale = Math.max(Math.min(a.scale, v.maxRatio), s.minRatio), v.imageEl.style.transitionDuration = `${t.params.speed}ms`, v.imageEl.style.transform = `translate3d(0,0,0) scale(${a.scale})`, l = a.scale, o = !1, a.scale > 1 && v.slideEl ? v.slideEl.classList.add(`${s.zoomedSlideClass}`) : a.scale <= 1 && v.slideEl && v.slideEl.classList.remove(`${s.zoomedSlideClass}`), 1 === a.scale && (v.originX = 0, v.originY = 0, v.slideEl = void 0)));
    }
    function A() {
      t.touchEventsData.preventTouchMoveFromPointerMove = !1;
    }
    function $(e) {
      const s = "mouse" === e.pointerType && t.params.zoom.panOnMouseMove;
      if (!C(e) || !P(e)) return;
      const a = t.zoom;
      if (!v.imageEl) return;
      if (!b.isTouched || !v.slideEl) return void (s && O(e));
      if (s) return void O(e);
      b.isMoved || (b.width = v.imageEl.offsetWidth || v.imageEl.clientWidth, b.height = v.imageEl.offsetHeight || v.imageEl.clientHeight, b.startX = d(v.imageWrapEl, "x") || 0, b.startY = d(v.imageWrapEl, "y") || 0, v.slideWidth = v.slideEl.offsetWidth, v.slideHeight = v.slideEl.offsetHeight, v.imageWrapEl.style.transitionDuration = "0ms");
      const i = b.width * a.scale,
        r = b.height * a.scale;
      b.minX = Math.min(v.slideWidth / 2 - i / 2, 0), b.maxX = -b.minX, b.minY = Math.min(v.slideHeight / 2 - r / 2, 0), b.maxY = -b.minY, b.touchesCurrent.x = g.length > 0 ? g[0].pageX : e.pageX, b.touchesCurrent.y = g.length > 0 ? g[0].pageY : e.pageY;
      if (Math.max(Math.abs(b.touchesCurrent.x - b.touchesStart.x), Math.abs(b.touchesCurrent.y - b.touchesStart.y)) > 5 && (t.allowClick = !1), !b.isMoved && !o) {
        if (t.isHorizontal() && (Math.floor(b.minX) === Math.floor(b.startX) && b.touchesCurrent.x < b.touchesStart.x || Math.floor(b.maxX) === Math.floor(b.startX) && b.touchesCurrent.x > b.touchesStart.x)) return b.isTouched = !1, void A();
        if (!t.isHorizontal() && (Math.floor(b.minY) === Math.floor(b.startY) && b.touchesCurrent.y < b.touchesStart.y || Math.floor(b.maxY) === Math.floor(b.startY) && b.touchesCurrent.y > b.touchesStart.y)) return b.isTouched = !1, void A();
      }
      e.cancelable && e.preventDefault(), e.stopPropagation(), clearTimeout(x), t.touchEventsData.preventTouchMoveFromPointerMove = !0, x = setTimeout(() => {
        t.destroyed || A();
      }), b.isMoved = !0;
      const n = (a.scale - l) / (v.maxRatio - t.params.zoom.minRatio),
        {
          originX: c,
          originY: p
        } = v;
      b.currentX = b.touchesCurrent.x - b.touchesStart.x + b.startX + n * (b.width - 2 * c), b.currentY = b.touchesCurrent.y - b.touchesStart.y + b.startY + n * (b.height - 2 * p), b.currentX < b.minX && (b.currentX = b.minX + 1 - (b.minX - b.currentX + 1) ** .8), b.currentX > b.maxX && (b.currentX = b.maxX - 1 + (b.currentX - b.maxX + 1) ** .8), b.currentY < b.minY && (b.currentY = b.minY + 1 - (b.minY - b.currentY + 1) ** .8), b.currentY > b.maxY && (b.currentY = b.maxY - 1 + (b.currentY - b.maxY + 1) ** .8), y.prevPositionX || (y.prevPositionX = b.touchesCurrent.x), y.prevPositionY || (y.prevPositionY = b.touchesCurrent.y), y.prevTime || (y.prevTime = Date.now()), y.x = (b.touchesCurrent.x - y.prevPositionX) / (Date.now() - y.prevTime) / 2, y.y = (b.touchesCurrent.y - y.prevPositionY) / (Date.now() - y.prevTime) / 2, Math.abs(b.touchesCurrent.x - y.prevPositionX) < 2 && (y.x = 0), Math.abs(b.touchesCurrent.y - y.prevPositionY) < 2 && (y.y = 0), y.prevPositionX = b.touchesCurrent.x, y.prevPositionY = b.touchesCurrent.y, y.prevTime = Date.now(), v.imageWrapEl.style.transform = `translate3d(${b.currentX}px, ${b.currentY}px,0)`;
    }
    function k() {
      const e = t.zoom;
      v.slideEl && t.activeIndex !== t.slides.indexOf(v.slideEl) && (v.imageEl && (v.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), v.imageWrapEl && (v.imageWrapEl.style.transform = "translate3d(0,0,0)"), v.slideEl.classList.remove(`${t.params.zoom.zoomedSlideClass}`), e.scale = 1, l = 1, v.slideEl = void 0, v.imageEl = void 0, v.imageWrapEl = void 0, v.originX = 0, v.originY = 0);
    }
    function O(e) {
      if (l <= 1 || !v.imageWrapEl) return;
      if (!C(e) || !P(e)) return;
      const t = n.getComputedStyle(v.imageWrapEl).transform,
        s = new n.DOMMatrix(t);
      if (!c) return c = !0, p.x = e.clientX, p.y = e.clientY, b.startX = s.e, b.startY = s.f, b.width = v.imageEl.offsetWidth || v.imageEl.clientWidth, b.height = v.imageEl.offsetHeight || v.imageEl.clientHeight, v.slideWidth = v.slideEl.offsetWidth, void (v.slideHeight = v.slideEl.offsetHeight);
      const a = (e.clientX - p.x) * u,
        i = (e.clientY - p.y) * u,
        r = b.width * l,
        o = b.height * l,
        d = v.slideWidth,
        m = v.slideHeight,
        h = Math.min(d / 2 - r / 2, 0),
        f = -h,
        g = Math.min(m / 2 - o / 2, 0),
        w = -g,
        y = Math.max(Math.min(b.startX + a, f), h),
        E = Math.max(Math.min(b.startY + i, w), g);
      v.imageWrapEl.style.transitionDuration = "0ms", v.imageWrapEl.style.transform = `translate3d(${y}px, ${E}px, 0)`, p.x = e.clientX, p.y = e.clientY, b.startX = y, b.startY = E, b.currentX = y, b.currentY = E;
    }
    function D(e) {
      const s = t.zoom,
        a = t.params.zoom;
      if (!v.slideEl) {
        e && e.target && (v.slideEl = e.target.closest(`.${t.params.slideClass}, swiper-slide`)), v.slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? v.slideEl = f(t.slidesEl, `.${t.params.slideActiveClass}`)[0] : v.slideEl = t.slides[t.activeIndex]);
        let s = v.slideEl.querySelector(`.${a.containerClass}`);
        s && (s = s.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), v.imageEl = s, v.imageWrapEl = s ? E(v.imageEl, `.${a.containerClass}`)[0] : void 0;
      }
      if (!v.imageEl || !v.imageWrapEl) return;
      let i, r, o, d, c, p, u, m, h, g, y, x, S, T, C, P, L, I;
      t.params.cssMode && (t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.touchAction = "none"), v.slideEl.classList.add(`${a.zoomedSlideClass}`), void 0 === b.touchesStart.x && e ? (i = e.pageX, r = e.pageY) : (i = b.touchesStart.x, r = b.touchesStart.y);
      const z = l,
        A = "number" == typeof e ? e : null;
      1 === l && A && (i = void 0, r = void 0, b.touchesStart.x = void 0, b.touchesStart.y = void 0);
      const $ = M();
      s.scale = A || $, l = A || $, !e || 1 === l && A ? (u = 0, m = 0) : (L = v.slideEl.offsetWidth, I = v.slideEl.offsetHeight, o = w(v.slideEl).left + n.scrollX, d = w(v.slideEl).top + n.scrollY, c = o + L / 2 - i, p = d + I / 2 - r, h = v.imageEl.offsetWidth || v.imageEl.clientWidth, g = v.imageEl.offsetHeight || v.imageEl.clientHeight, y = h * s.scale, x = g * s.scale, S = Math.min(L / 2 - y / 2, 0), T = Math.min(I / 2 - x / 2, 0), C = -S, P = -T, z > 0 && A && "number" == typeof b.currentX && "number" == typeof b.currentY ? (u = b.currentX * s.scale / z, m = b.currentY * s.scale / z) : (u = c * s.scale, m = p * s.scale), u < S && (u = S), u > C && (u = C), m < T && (m = T), m > P && (m = P)), A && 1 === s.scale && (v.originX = 0, v.originY = 0), b.currentX = u, b.currentY = m, v.imageWrapEl.style.transitionDuration = "300ms", v.imageWrapEl.style.transform = `translate3d(${u}px, ${m}px,0)`, v.imageEl.style.transitionDuration = "300ms", v.imageEl.style.transform = `translate3d(0,0,0) scale(${s.scale})`;
    }
    function G() {
      const e = t.zoom,
        s = t.params.zoom;
      if (!v.slideEl) {
        t.params.virtual && t.params.virtual.enabled && t.virtual ? v.slideEl = f(t.slidesEl, `.${t.params.slideActiveClass}`)[0] : v.slideEl = t.slides[t.activeIndex];
        let e = v.slideEl.querySelector(`.${s.containerClass}`);
        e && (e = e.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), v.imageEl = e, v.imageWrapEl = e ? E(v.imageEl, `.${s.containerClass}`)[0] : void 0;
      }
      v.imageEl && v.imageWrapEl && (t.params.cssMode && (t.wrapperEl.style.overflow = "", t.wrapperEl.style.touchAction = ""), e.scale = 1, l = 1, b.currentX = void 0, b.currentY = void 0, b.touchesStart.x = void 0, b.touchesStart.y = void 0, v.imageWrapEl.style.transitionDuration = "300ms", v.imageWrapEl.style.transform = "translate3d(0,0,0)", v.imageEl.style.transitionDuration = "300ms", v.imageEl.style.transform = "translate3d(0,0,0) scale(1)", v.slideEl.classList.remove(`${s.zoomedSlideClass}`), v.slideEl = void 0, v.originX = 0, v.originY = 0, t.params.zoom.panOnMouseMove && (p = {
        x: 0,
        y: 0
      }, c && (c = !1, b.startX = 0, b.startY = 0)));
    }
    function X(e) {
      const s = t.zoom;
      s.scale && 1 !== s.scale ? G() : D(e);
    }
    function Y() {
      return {
        passiveListener: !!t.params.passiveListeners && {
          passive: !0,
          capture: !1
        },
        activeListenerWithCapture: !t.params.passiveListeners || {
          passive: !1,
          capture: !0
        }
      };
    }
    function B() {
      const e = t.zoom;
      if (e.enabled) return;
      e.enabled = !0;
      const {
        passiveListener: s,
        activeListenerWithCapture: a
      } = Y();
      t.wrapperEl.addEventListener("pointerdown", L, s), t.wrapperEl.addEventListener("pointermove", I, a), ["pointerup", "pointercancel", "pointerout"].forEach(e => {
        t.wrapperEl.addEventListener(e, z, s);
      }), t.wrapperEl.addEventListener("pointermove", $, a);
    }
    function H() {
      const e = t.zoom;
      if (!e.enabled) return;
      e.enabled = !1;
      const {
        passiveListener: s,
        activeListenerWithCapture: a
      } = Y();
      t.wrapperEl.removeEventListener("pointerdown", L, s), t.wrapperEl.removeEventListener("pointermove", I, a), ["pointerup", "pointercancel", "pointerout"].forEach(e => {
        t.wrapperEl.removeEventListener(e, z, s);
      }), t.wrapperEl.removeEventListener("pointermove", $, a);
    }
    Object.defineProperty(t.zoom, "scale", {
      get: () => S,
      set(e) {
        if (S !== e) {
          const t = v.imageEl,
            s = v.slideEl;
          i("zoomChange", e, t, s);
        }
        S = e;
      }
    }), a("init", () => {
      t.params.zoom.enabled && B();
    }), a("destroy", () => {
      H();
    }), a("touchStart", (e, s) => {
      t.zoom.enabled && function (e) {
        const s = t.device;
        if (!v.imageEl) return;
        if (b.isTouched) return;
        s.android && e.cancelable && e.preventDefault(), b.isTouched = !0;
        const a = g.length > 0 ? g[0] : e;
        b.touchesStart.x = a.pageX, b.touchesStart.y = a.pageY;
      }(s);
    }), a("touchEnd", (e, s) => {
      t.zoom.enabled && function () {
        const e = t.zoom;
        if (g.length = 0, !v.imageEl) return;
        if (!b.isTouched || !b.isMoved) return b.isTouched = !1, void (b.isMoved = !1);
        b.isTouched = !1, b.isMoved = !1;
        let s = 300,
          a = 300;
        const i = y.x * s,
          r = b.currentX + i,
          n = y.y * a,
          l = b.currentY + n;
        0 !== y.x && (s = Math.abs((r - b.currentX) / y.x)), 0 !== y.y && (a = Math.abs((l - b.currentY) / y.y));
        const o = Math.max(s, a);
        b.currentX = r, b.currentY = l;
        const d = b.width * e.scale,
          c = b.height * e.scale;
        b.minX = Math.min(v.slideWidth / 2 - d / 2, 0), b.maxX = -b.minX, b.minY = Math.min(v.slideHeight / 2 - c / 2, 0), b.maxY = -b.minY, b.currentX = Math.max(Math.min(b.currentX, b.maxX), b.minX), b.currentY = Math.max(Math.min(b.currentY, b.maxY), b.minY), v.imageWrapEl.style.transitionDuration = `${o}ms`, v.imageWrapEl.style.transform = `translate3d(${b.currentX}px, ${b.currentY}px,0)`;
      }();
    }), a("doubleTap", (e, s) => {
      !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && X(s);
    }), a("transitionEnd", () => {
      t.zoom.enabled && t.params.zoom.enabled && k();
    }), a("slideChange", () => {
      t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && k();
    }), Object.assign(t.zoom, {
      enable: B,
      disable: H,
      in: D,
      out: G,
      toggle: X
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    function i(e, t) {
      const s = function () {
        let e, t, s;
        return (a, i) => {
          for (t = -1, e = a.length; e - t > 1;) s = e + t >> 1, a[s] <= i ? t = s : e = s;
          return e;
        };
      }();
      let a, i;
      return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) {
        return e ? (i = s(this.x, e), a = i - 1, (e - this.x[a]) * (this.y[i] - this.y[a]) / (this.x[i] - this.x[a]) + this.y[a]) : 0;
      }, this;
    }
    function r() {
      t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline);
    }
    s({
      controller: {
        control: void 0,
        inverse: !1,
        by: "slide"
      }
    }), t.controller = {
      control: void 0
    }, a("beforeInit", () => {
      if ("undefined" != typeof window && ("string" == typeof t.params.controller.control || t.params.controller.control instanceof HTMLElement)) {
        ("string" == typeof t.params.controller.control ? [...document.querySelectorAll(t.params.controller.control)] : [t.params.controller.control]).forEach(e => {
          if (t.controller.control || (t.controller.control = []), e && e.swiper) t.controller.control.push(e.swiper);else if (e) {
            const s = `${t.params.eventsPrefix}init`,
              a = i => {
                t.controller.control.push(i.detail[0]), t.update(), e.removeEventListener(s, a);
              };
            e.addEventListener(s, a);
          }
        });
      } else t.controller.control = t.params.controller.control;
    }), a("update", () => {
      r();
    }), a("resize", () => {
      r();
    }), a("observerUpdate", () => {
      r();
    }), a("setTranslate", (e, s, a) => {
      t.controller.control && !t.controller.control.destroyed && t.controller.setTranslate(s, a);
    }), a("setTransition", (e, s, a) => {
      t.controller.control && !t.controller.control.destroyed && t.controller.setTransition(s, a);
    }), Object.assign(t.controller, {
      setTranslate: function (e, s) {
        const a = t.controller.control;
        let r, n;
        const l = t.constructor;
        function o(e) {
          if (e.destroyed) return;
          const s = t.rtlTranslate ? -t.translate : t.translate;
          "slide" === t.params.controller.by && (!function (e) {
            t.controller.spline = t.params.loop ? new i(t.slidesGrid, e.slidesGrid) : new i(t.snapGrid, e.snapGrid);
          }(e), n = -t.controller.spline.interpolate(-s)), n && "container" !== t.params.controller.by || (r = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), !Number.isNaN(r) && Number.isFinite(r) || (r = 1), n = (s - t.minTranslate()) * r + e.minTranslate()), t.params.controller.inverse && (n = e.maxTranslate() - n), e.updateProgress(n), e.setTranslate(n, t), e.updateActiveIndex(), e.updateSlidesClasses();
        }
        if (Array.isArray(a)) for (let e = 0; e < a.length; e += 1) a[e] !== s && a[e] instanceof l && o(a[e]);else a instanceof l && s !== a && o(a);
      },
      setTransition: function (e, s) {
        const a = t.constructor,
          i = t.controller.control;
        let r;
        function n(s) {
          s.destroyed || (s.setTransition(e, t), 0 !== e && (s.transitionStart(), s.params.autoHeight && l(() => {
            s.updateAutoHeight();
          }), x(s.wrapperEl, () => {
            i && s.transitionEnd();
          })));
        }
        if (Array.isArray(i)) for (r = 0; r < i.length; r += 1) i[r] !== s && i[r] instanceof a && n(i[r]);else i instanceof a && s !== i && n(i);
      }
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: i
    } = e;
    s({
      a11y: {
        enabled: !0,
        notificationClass: "swiper-notification",
        prevSlideMessage: "Previous slide",
        nextSlideMessage: "Next slide",
        firstSlideMessage: "This is the first slide",
        lastSlideMessage: "This is the last slide",
        paginationBulletMessage: "Go to slide {{index}}",
        slideLabelMessage: "{{index}} / {{slidesLength}}",
        containerMessage: null,
        containerRoleDescriptionMessage: null,
        containerRole: null,
        itemRoleDescriptionMessage: null,
        slideRole: "group",
        id: null,
        scrollOnFocus: !0
      }
    }), t.a11y = {
      clicked: !1
    };
    let r,
      n,
      l = null,
      o = new Date().getTime();
    function d(e) {
      const t = l;
      0 !== t.length && C(t, e);
    }
    function c(e) {
      (e = T(e)).forEach(e => {
        e.setAttribute("tabIndex", "0");
      });
    }
    function p(e) {
      (e = T(e)).forEach(e => {
        e.setAttribute("tabIndex", "-1");
      });
    }
    function u(e, t) {
      (e = T(e)).forEach(e => {
        e.setAttribute("role", t);
      });
    }
    function m(e, t) {
      (e = T(e)).forEach(e => {
        e.setAttribute("aria-roledescription", t);
      });
    }
    function h(e, t) {
      (e = T(e)).forEach(e => {
        e.setAttribute("aria-label", t);
      });
    }
    function f(e) {
      (e = T(e)).forEach(e => {
        e.setAttribute("aria-disabled", !0);
      });
    }
    function g(e) {
      (e = T(e)).forEach(e => {
        e.setAttribute("aria-disabled", !1);
      });
    }
    function w(e) {
      if (13 !== e.keyCode && 32 !== e.keyCode) return;
      const s = t.params.a11y,
        a = e.target;
      if (!t.pagination || !t.pagination.el || a !== t.pagination.el && !t.pagination.el.contains(e.target) || e.target.matches(le(t.params.pagination.bulletClass))) {
        if (t.navigation && t.navigation.prevEl && t.navigation.nextEl) {
          const e = T(t.navigation.prevEl);
          T(t.navigation.nextEl).includes(a) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? d(s.lastSlideMessage) : d(s.nextSlideMessage)), e.includes(a) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? d(s.firstSlideMessage) : d(s.prevSlideMessage));
        }
        t.pagination && a.matches(le(t.params.pagination.bulletClass)) && a.click();
      }
    }
    function b() {
      return t.pagination && t.pagination.bullets && t.pagination.bullets.length;
    }
    function E() {
      return b() && t.params.pagination.clickable;
    }
    const x = (e, t, s) => {
        c(e), "BUTTON" !== e.tagName && (u(e, "button"), e.addEventListener("keydown", w)), h(e, s), function (e, t) {
          (e = T(e)).forEach(e => {
            e.setAttribute("aria-controls", t);
          });
        }(e, t);
      },
      S = e => {
        n && n !== e.target && !n.contains(e.target) && (r = !0), t.a11y.clicked = !0;
      },
      M = () => {
        r = !1, requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            t.destroyed || (t.a11y.clicked = !1);
          });
        });
      },
      P = e => {
        o = new Date().getTime();
      },
      L = e => {
        if (t.a11y.clicked || !t.params.a11y.scrollOnFocus) return;
        if (new Date().getTime() - o < 100) return;
        const s = e.target.closest(`.${t.params.slideClass}, swiper-slide`);
        if (!s || !t.slides.includes(s)) return;
        n = s;
        const a = t.slides.indexOf(s) === t.activeIndex,
          i = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(s);
        a || i || e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, requestAnimationFrame(() => {
          r || (t.params.loop ? t.slideToLoop(t.getSlideIndexWhenGrid(parseInt(s.getAttribute("data-swiper-slide-index"))), 0) : t.slideTo(t.getSlideIndexWhenGrid(t.slides.indexOf(s)), 0), r = !1);
        }));
      },
      I = () => {
        const e = t.params.a11y;
        e.itemRoleDescriptionMessage && m(t.slides, e.itemRoleDescriptionMessage), e.slideRole && u(t.slides, e.slideRole);
        const s = t.slides.length;
        e.slideLabelMessage && t.slides.forEach((a, i) => {
          const r = t.params.loop ? parseInt(a.getAttribute("data-swiper-slide-index"), 10) : i;
          h(a, e.slideLabelMessage.replace(/\{\{index\}\}/, r + 1).replace(/\{\{slidesLength\}\}/, s));
        });
      },
      z = () => {
        const e = t.params.a11y;
        t.el.append(l);
        const s = t.el;
        e.containerRoleDescriptionMessage && m(s, e.containerRoleDescriptionMessage), e.containerMessage && h(s, e.containerMessage), e.containerRole && u(s, e.containerRole);
        const i = t.wrapperEl,
          r = e.id || i.getAttribute("id") || `swiper-wrapper-${n = 16, void 0 === n && (n = 16), "x".repeat(n).replace(/x/g, () => Math.round(16 * Math.random()).toString(16))}`;
        var n;
        const o = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite";
        var d;
        d = r, T(i).forEach(e => {
          e.setAttribute("id", d);
        }), function (e, t) {
          (e = T(e)).forEach(e => {
            e.setAttribute("aria-live", t);
          });
        }(i, o), I();
        let {
          nextEl: c,
          prevEl: p
        } = t.navigation ? t.navigation : {};
        if (c = T(c), p = T(p), c && c.forEach(t => x(t, r, e.nextSlideMessage)), p && p.forEach(t => x(t, r, e.prevSlideMessage)), E()) {
          T(t.pagination.el).forEach(e => {
            e.addEventListener("keydown", w);
          });
        }
        a().addEventListener("visibilitychange", P), t.el.addEventListener("focus", L, !0), t.el.addEventListener("focus", L, !0), t.el.addEventListener("pointerdown", S, !0), t.el.addEventListener("pointerup", M, !0);
      };
    i("beforeInit", () => {
      l = v("span", t.params.a11y.notificationClass), l.setAttribute("aria-live", "assertive"), l.setAttribute("aria-atomic", "true");
    }), i("afterInit", () => {
      t.params.a11y.enabled && z();
    }), i("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => {
      t.params.a11y.enabled && I();
    }), i("fromEdge toEdge afterInit lock unlock", () => {
      t.params.a11y.enabled && function () {
        if (t.params.loop || t.params.rewind || !t.navigation) return;
        const {
          nextEl: e,
          prevEl: s
        } = t.navigation;
        s && (t.isBeginning ? (f(s), p(s)) : (g(s), c(s))), e && (t.isEnd ? (f(e), p(e)) : (g(e), c(e)));
      }();
    }), i("paginationUpdate", () => {
      t.params.a11y.enabled && function () {
        const e = t.params.a11y;
        b() && t.pagination.bullets.forEach(s => {
          t.params.pagination.clickable && (c(s), t.params.pagination.renderBullet || (u(s, "button"), h(s, e.paginationBulletMessage.replace(/\{\{index\}\}/, y(s) + 1)))), s.matches(le(t.params.pagination.bulletActiveClass)) ? s.setAttribute("aria-current", "true") : s.removeAttribute("aria-current");
        });
      }();
    }), i("destroy", () => {
      t.params.a11y.enabled && function () {
        l && l.remove();
        let {
          nextEl: e,
          prevEl: s
        } = t.navigation ? t.navigation : {};
        e = T(e), s = T(s), e && e.forEach(e => e.removeEventListener("keydown", w)), s && s.forEach(e => e.removeEventListener("keydown", w)), E() && T(t.pagination.el).forEach(e => {
          e.removeEventListener("keydown", w);
        });
        a().removeEventListener("visibilitychange", P), t.el && "string" != typeof t.el && (t.el.removeEventListener("focus", L, !0), t.el.removeEventListener("pointerdown", S, !0), t.el.removeEventListener("pointerup", M, !0));
      }();
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      history: {
        enabled: !1,
        root: "",
        replaceState: !1,
        key: "slides",
        keepQuery: !1
      }
    });
    let i = !1,
      n = {};
    const l = e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
      o = e => {
        const t = r();
        let s;
        s = e ? new URL(e) : t.location;
        const a = s.pathname.slice(1).split("/").filter(e => "" !== e),
          i = a.length;
        return {
          key: a[i - 2],
          value: a[i - 1]
        };
      },
      d = (e, s) => {
        const a = r();
        if (!i || !t.params.history.enabled) return;
        let n;
        n = t.params.url ? new URL(t.params.url) : a.location;
        const o = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${s}"]`) : t.slides[s];
        let d = l(o.getAttribute("data-history"));
        if (t.params.history.root.length > 0) {
          let s = t.params.history.root;
          "/" === s[s.length - 1] && (s = s.slice(0, s.length - 1)), d = `${s}/${e ? `${e}/` : ""}${d}`;
        } else n.pathname.includes(e) || (d = `${e ? `${e}/` : ""}${d}`);
        t.params.history.keepQuery && (d += n.search);
        const c = a.history.state;
        c && c.value === d || (t.params.history.replaceState ? a.history.replaceState({
          value: d
        }, null, d) : a.history.pushState({
          value: d
        }, null, d));
      },
      c = (e, s, a) => {
        if (s) for (let i = 0, r = t.slides.length; i < r; i += 1) {
          const r = t.slides[i];
          if (l(r.getAttribute("data-history")) === s) {
            const s = t.getSlideIndex(r);
            t.slideTo(s, e, a);
          }
        } else t.slideTo(0, e, a);
      },
      p = () => {
        n = o(t.params.url), c(t.params.speed, n.value, !1);
      };
    a("init", () => {
      t.params.history.enabled && (() => {
        const e = r();
        if (t.params.history) {
          if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void (t.params.hashNavigation.enabled = !0);
          i = !0, n = o(t.params.url), n.key || n.value ? (c(0, n.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener("popstate", p)) : t.params.history.replaceState || e.addEventListener("popstate", p);
        }
      })();
    }), a("destroy", () => {
      t.params.history.enabled && (() => {
        const e = r();
        t.params.history.replaceState || e.removeEventListener("popstate", p);
      })();
    }), a("transitionEnd _freeModeNoMomentumRelease", () => {
      i && d(t.params.history.key, t.activeIndex);
    }), a("slideChange", () => {
      i && t.params.cssMode && d(t.params.history.key, t.activeIndex);
    });
  }, function (e) {
    let {
        swiper: t,
        extendParams: s,
        emit: i,
        on: n
      } = e,
      l = !1;
    const o = a(),
      d = r();
    s({
      hashNavigation: {
        enabled: !1,
        replaceState: !1,
        watchState: !1,
        getSlideIndex(e, s) {
          if (t.virtual && t.params.virtual.enabled) {
            const e = t.slides.find(e => e.getAttribute("data-hash") === s);
            if (!e) return 0;
            return parseInt(e.getAttribute("data-swiper-slide-index"), 10);
          }
          return t.getSlideIndex(f(t.slidesEl, `.${t.params.slideClass}[data-hash="${s}"], swiper-slide[data-hash="${s}"]`)[0]);
        }
      }
    });
    const c = () => {
        i("hashChange");
        const e = o.location.hash.replace("#", ""),
          s = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex];
        if (e !== (s ? s.getAttribute("data-hash") : "")) {
          const s = t.params.hashNavigation.getSlideIndex(t, e);
          if (void 0 === s || Number.isNaN(s)) return;
          t.slideTo(s);
        }
      },
      p = () => {
        if (!l || !t.params.hashNavigation.enabled) return;
        const e = t.virtual && t.params.virtual.enabled ? t.slidesEl.querySelector(`[data-swiper-slide-index="${t.activeIndex}"]`) : t.slides[t.activeIndex],
          s = e ? e.getAttribute("data-hash") || e.getAttribute("data-history") : "";
        t.params.hashNavigation.replaceState && d.history && d.history.replaceState ? (d.history.replaceState(null, null, `#${s}` || ""), i("hashSet")) : (o.location.hash = s || "", i("hashSet"));
      };
    n("init", () => {
      t.params.hashNavigation.enabled && (() => {
        if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return;
        l = !0;
        const e = o.location.hash.replace("#", "");
        if (e) {
          const s = 0,
            a = t.params.hashNavigation.getSlideIndex(t, e);
          t.slideTo(a || 0, s, t.params.runCallbacksOnInit, !0);
        }
        t.params.hashNavigation.watchState && d.addEventListener("hashchange", c);
      })();
    }), n("destroy", () => {
      t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && d.removeEventListener("hashchange", c);
    }), n("transitionEnd _freeModeNoMomentumRelease", () => {
      l && p();
    }), n("slideChange", () => {
      l && t.params.cssMode && p();
    });
  }, function (e) {
    let t,
      s,
      {
        swiper: i,
        extendParams: r,
        on: n,
        emit: l,
        params: o
      } = e;
    i.autoplay = {
      running: !1,
      paused: !1,
      timeLeft: 0
    }, r({
      autoplay: {
        enabled: !1,
        delay: 3e3,
        waitForTransition: !0,
        disableOnInteraction: !1,
        stopOnLastSlide: !1,
        reverseDirection: !1,
        pauseOnMouseEnter: !1
      }
    });
    let d,
      c,
      p,
      u,
      m,
      h,
      f,
      g,
      v = o && o.autoplay ? o.autoplay.delay : 3e3,
      w = o && o.autoplay ? o.autoplay.delay : 3e3,
      b = new Date().getTime();
    function y(e) {
      i && !i.destroyed && i.wrapperEl && e.target === i.wrapperEl && (i.wrapperEl.removeEventListener("transitionend", y), g || e.detail && e.detail.bySwiperTouchMove || C());
    }
    const E = () => {
        if (i.destroyed || !i.autoplay.running) return;
        i.autoplay.paused ? c = !0 : c && (w = d, c = !1);
        const e = i.autoplay.paused ? d : b + w - new Date().getTime();
        i.autoplay.timeLeft = e, l("autoplayTimeLeft", e, e / v), s = requestAnimationFrame(() => {
          E();
        });
      },
      x = e => {
        if (i.destroyed || !i.autoplay.running) return;
        cancelAnimationFrame(s), E();
        let a = void 0 === e ? i.params.autoplay.delay : e;
        v = i.params.autoplay.delay, w = i.params.autoplay.delay;
        const r = (() => {
          let e;
          if (e = i.virtual && i.params.virtual.enabled ? i.slides.find(e => e.classList.contains("swiper-slide-active")) : i.slides[i.activeIndex], !e) return;
          return parseInt(e.getAttribute("data-swiper-autoplay"), 10);
        })();
        !Number.isNaN(r) && r > 0 && void 0 === e && (a = r, v = r, w = r), d = a;
        const n = i.params.speed,
          o = () => {
            i && !i.destroyed && (i.params.autoplay.reverseDirection ? !i.isBeginning || i.params.loop || i.params.rewind ? (i.slidePrev(n, !0, !0), l("autoplay")) : i.params.autoplay.stopOnLastSlide || (i.slideTo(i.slides.length - 1, n, !0, !0), l("autoplay")) : !i.isEnd || i.params.loop || i.params.rewind ? (i.slideNext(n, !0, !0), l("autoplay")) : i.params.autoplay.stopOnLastSlide || (i.slideTo(0, n, !0, !0), l("autoplay")), i.params.cssMode && (b = new Date().getTime(), requestAnimationFrame(() => {
              x();
            })));
          };
        return a > 0 ? (clearTimeout(t), t = setTimeout(() => {
          o();
        }, a)) : requestAnimationFrame(() => {
          o();
        }), a;
      },
      S = () => {
        b = new Date().getTime(), i.autoplay.running = !0, x(), l("autoplayStart");
      },
      T = () => {
        i.autoplay.running = !1, clearTimeout(t), cancelAnimationFrame(s), l("autoplayStop");
      },
      M = (e, s) => {
        if (i.destroyed || !i.autoplay.running) return;
        clearTimeout(t), e || (f = !0);
        const a = () => {
          l("autoplayPause"), i.params.autoplay.waitForTransition ? i.wrapperEl.addEventListener("transitionend", y) : C();
        };
        if (i.autoplay.paused = !0, s) return h && (d = i.params.autoplay.delay), h = !1, void a();
        const r = d || i.params.autoplay.delay;
        d = r - (new Date().getTime() - b), i.isEnd && d < 0 && !i.params.loop || (d < 0 && (d = 0), a());
      },
      C = () => {
        i.isEnd && d < 0 && !i.params.loop || i.destroyed || !i.autoplay.running || (b = new Date().getTime(), f ? (f = !1, x(d)) : x(), i.autoplay.paused = !1, l("autoplayResume"));
      },
      P = () => {
        if (i.destroyed || !i.autoplay.running) return;
        const e = a();
        "hidden" === e.visibilityState && (f = !0, M(!0)), "visible" === e.visibilityState && C();
      },
      L = e => {
        "mouse" === e.pointerType && (f = !0, g = !0, i.animating || i.autoplay.paused || M(!0));
      },
      I = e => {
        "mouse" === e.pointerType && (g = !1, i.autoplay.paused && C());
      };
    n("init", () => {
      i.params.autoplay.enabled && (i.params.autoplay.pauseOnMouseEnter && (i.el.addEventListener("pointerenter", L), i.el.addEventListener("pointerleave", I)), a().addEventListener("visibilitychange", P), S());
    }), n("destroy", () => {
      i.el && "string" != typeof i.el && (i.el.removeEventListener("pointerenter", L), i.el.removeEventListener("pointerleave", I)), a().removeEventListener("visibilitychange", P), i.autoplay.running && T();
    }), n("_freeModeStaticRelease", () => {
      (u || f) && C();
    }), n("_freeModeNoMomentumRelease", () => {
      i.params.autoplay.disableOnInteraction ? T() : M(!0, !0);
    }), n("beforeTransitionStart", (e, t, s) => {
      !i.destroyed && i.autoplay.running && (s || !i.params.autoplay.disableOnInteraction ? M(!0, !0) : T());
    }), n("sliderFirstMove", () => {
      !i.destroyed && i.autoplay.running && (i.params.autoplay.disableOnInteraction ? T() : (p = !0, u = !1, f = !1, m = setTimeout(() => {
        f = !0, u = !0, M(!0);
      }, 200)));
    }), n("touchEnd", () => {
      if (!i.destroyed && i.autoplay.running && p) {
        if (clearTimeout(m), clearTimeout(t), i.params.autoplay.disableOnInteraction) return u = !1, void (p = !1);
        u && i.params.cssMode && C(), u = !1, p = !1;
      }
    }), n("slideChange", () => {
      !i.destroyed && i.autoplay.running && (h = !0);
    }), Object.assign(i.autoplay, {
      start: S,
      stop: T,
      pause: M,
      resume: C
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: i
    } = e;
    s({
      thumbs: {
        swiper: null,
        multipleActiveThumbs: !0,
        autoScrollOffset: 0,
        slideThumbActiveClass: "swiper-slide-thumb-active",
        thumbsContainerClass: "swiper-thumbs"
      }
    });
    let r = !1,
      n = !1;
    function l() {
      const e = t.thumbs.swiper;
      if (!e || e.destroyed) return;
      const s = e.clickedIndex,
        a = e.clickedSlide;
      if (a && a.classList.contains(t.params.thumbs.slideThumbActiveClass)) return;
      if (null == s) return;
      let i;
      i = e.params.loop ? parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : s, t.params.loop ? t.slideToLoop(i) : t.slideTo(i);
    }
    function o() {
      const {
        thumbs: e
      } = t.params;
      if (r) return !1;
      r = !0;
      const s = t.constructor;
      if (e.swiper instanceof s) {
        if (e.swiper.destroyed) return r = !1, !1;
        t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, {
          watchSlidesProgress: !0,
          slideToClickedSlide: !1
        }), Object.assign(t.thumbs.swiper.params, {
          watchSlidesProgress: !0,
          slideToClickedSlide: !1
        }), t.thumbs.swiper.update();
      } else if (c(e.swiper)) {
        const a = Object.assign({}, e.swiper);
        Object.assign(a, {
          watchSlidesProgress: !0,
          slideToClickedSlide: !1
        }), t.thumbs.swiper = new s(a), n = !0;
      }
      return t.thumbs.swiper.el.classList.add(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", l), !0;
    }
    function d(e) {
      const s = t.thumbs.swiper;
      if (!s || s.destroyed) return;
      const a = "auto" === s.params.slidesPerView ? s.slidesPerViewDynamic() : s.params.slidesPerView;
      let i = 1;
      const r = t.params.thumbs.slideThumbActiveClass;
      if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (i = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (i = 1), i = Math.floor(i), s.slides.forEach(e => e.classList.remove(r)), s.params.loop || s.params.virtual && s.params.virtual.enabled) for (let e = 0; e < i; e += 1) f(s.slidesEl, `[data-swiper-slide-index="${t.realIndex + e}"]`).forEach(e => {
        e.classList.add(r);
      });else for (let e = 0; e < i; e += 1) s.slides[t.realIndex + e] && s.slides[t.realIndex + e].classList.add(r);
      const n = t.params.thumbs.autoScrollOffset,
        l = n && !s.params.loop;
      if (t.realIndex !== s.realIndex || l) {
        const i = s.activeIndex;
        let r, o;
        if (s.params.loop) {
          const e = s.slides.find(e => e.getAttribute("data-swiper-slide-index") === `${t.realIndex}`);
          r = s.slides.indexOf(e), o = t.activeIndex > t.previousIndex ? "next" : "prev";
        } else r = t.realIndex, o = r > t.previousIndex ? "next" : "prev";
        l && (r += "next" === o ? n : -1 * n), s.visibleSlidesIndexes && s.visibleSlidesIndexes.indexOf(r) < 0 && (s.params.centeredSlides ? r = r > i ? r - Math.floor(a / 2) + 1 : r + Math.floor(a / 2) - 1 : r > i && s.params.slidesPerGroup, s.slideTo(r, e ? 0 : void 0));
      }
    }
    t.thumbs = {
      swiper: null
    }, i("beforeInit", () => {
      const {
        thumbs: e
      } = t.params;
      if (e && e.swiper) if ("string" == typeof e.swiper || e.swiper instanceof HTMLElement) {
        const s = a(),
          i = () => {
            const a = "string" == typeof e.swiper ? s.querySelector(e.swiper) : e.swiper;
            if (a && a.swiper) e.swiper = a.swiper, o(), d(!0);else if (a) {
              const s = `${t.params.eventsPrefix}init`,
                i = r => {
                  e.swiper = r.detail[0], a.removeEventListener(s, i), o(), d(!0), e.swiper.update(), t.update();
                };
              a.addEventListener(s, i);
            }
            return a;
          },
          r = () => {
            if (t.destroyed) return;
            i() || requestAnimationFrame(r);
          };
        requestAnimationFrame(r);
      } else o(), d(!0);
    }), i("slideChange update resize observerUpdate", () => {
      d();
    }), i("setTransition", (e, s) => {
      const a = t.thumbs.swiper;
      a && !a.destroyed && a.setTransition(s);
    }), i("beforeDestroy", () => {
      const e = t.thumbs.swiper;
      e && !e.destroyed && n && e.destroy();
    }), Object.assign(t.thumbs, {
      init: o,
      update: d
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      emit: a,
      once: i
    } = e;
    s({
      freeMode: {
        enabled: !1,
        momentum: !0,
        momentumRatio: 1,
        momentumBounce: !0,
        momentumBounceRatio: 1,
        momentumVelocityRatio: 1,
        sticky: !1,
        minimumVelocity: .02
      }
    }), Object.assign(t, {
      freeMode: {
        onTouchStart: function () {
          if (t.params.cssMode) return;
          const e = t.getTranslate();
          t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({
            currentPos: t.rtl ? t.translate : -t.translate
          });
        },
        onTouchMove: function () {
          if (t.params.cssMode) return;
          const {
            touchEventsData: e,
            touches: s
          } = t;
          0 === e.velocities.length && e.velocities.push({
            position: s[t.isHorizontal() ? "startX" : "startY"],
            time: e.touchStartTime
          }), e.velocities.push({
            position: s[t.isHorizontal() ? "currentX" : "currentY"],
            time: o()
          });
        },
        onTouchEnd: function (e) {
          let {
            currentPos: s
          } = e;
          if (t.params.cssMode) return;
          const {
              params: r,
              wrapperEl: n,
              rtlTranslate: l,
              snapGrid: d,
              touchEventsData: c
            } = t,
            p = o() - c.touchStartTime;
          if (s < -t.minTranslate()) t.slideTo(t.activeIndex);else if (s > -t.maxTranslate()) t.slides.length < d.length ? t.slideTo(d.length - 1) : t.slideTo(t.slides.length - 1);else {
            if (r.freeMode.momentum) {
              if (c.velocities.length > 1) {
                const e = c.velocities.pop(),
                  s = c.velocities.pop(),
                  a = e.position - s.position,
                  i = e.time - s.time;
                t.velocity = a / i, t.velocity /= 2, Math.abs(t.velocity) < r.freeMode.minimumVelocity && (t.velocity = 0), (i > 150 || o() - e.time > 300) && (t.velocity = 0);
              } else t.velocity = 0;
              t.velocity *= r.freeMode.momentumVelocityRatio, c.velocities.length = 0;
              let e = 1e3 * r.freeMode.momentumRatio;
              const s = t.velocity * e;
              let p = t.translate + s;
              l && (p = -p);
              let u,
                m = !1;
              const h = 20 * Math.abs(t.velocity) * r.freeMode.momentumBounceRatio;
              let f;
              if (p < t.maxTranslate()) r.freeMode.momentumBounce ? (p + t.maxTranslate() < -h && (p = t.maxTranslate() - h), u = t.maxTranslate(), m = !0, c.allowMomentumBounce = !0) : p = t.maxTranslate(), r.loop && r.centeredSlides && (f = !0);else if (p > t.minTranslate()) r.freeMode.momentumBounce ? (p - t.minTranslate() > h && (p = t.minTranslate() + h), u = t.minTranslate(), m = !0, c.allowMomentumBounce = !0) : p = t.minTranslate(), r.loop && r.centeredSlides && (f = !0);else if (r.freeMode.sticky) {
                let e;
                for (let t = 0; t < d.length; t += 1) if (d[t] > -p) {
                  e = t;
                  break;
                }
                p = Math.abs(d[e] - p) < Math.abs(d[e - 1] - p) || "next" === t.swipeDirection ? d[e] : d[e - 1], p = -p;
              }
              if (f && i("transitionEnd", () => {
                t.loopFix();
              }), 0 !== t.velocity) {
                if (e = l ? Math.abs((-p - t.translate) / t.velocity) : Math.abs((p - t.translate) / t.velocity), r.freeMode.sticky) {
                  const s = Math.abs((l ? -p : p) - t.translate),
                    a = t.slidesSizesGrid[t.activeIndex];
                  e = s < a ? r.speed : s < 2 * a ? 1.5 * r.speed : 2.5 * r.speed;
                }
              } else if (r.freeMode.sticky) return void t.slideToClosest();
              r.freeMode.momentumBounce && m ? (t.updateProgress(u), t.setTransition(e), t.setTranslate(p), t.transitionStart(!0, t.swipeDirection), t.animating = !0, x(n, () => {
                t && !t.destroyed && c.allowMomentumBounce && (a("momentumBounce"), t.setTransition(r.speed), setTimeout(() => {
                  t.setTranslate(u), x(n, () => {
                    t && !t.destroyed && t.transitionEnd();
                  });
                }, 0));
              })) : t.velocity ? (a("_freeModeNoMomentumRelease"), t.updateProgress(p), t.setTransition(e), t.setTranslate(p), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, x(n, () => {
                t && !t.destroyed && t.transitionEnd();
              }))) : t.updateProgress(p), t.updateActiveIndex(), t.updateSlidesClasses();
            } else {
              if (r.freeMode.sticky) return void t.slideToClosest();
              r.freeMode && a("_freeModeNoMomentumRelease");
            }
            (!r.freeMode.momentum || p >= r.longSwipesMs) && (a("_freeModeStaticRelease"), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses());
          }
        }
      }
    });
  }, function (e) {
    let t,
      s,
      a,
      i,
      {
        swiper: r,
        extendParams: n,
        on: l
      } = e;
    n({
      grid: {
        rows: 1,
        fill: "column"
      }
    });
    const o = () => {
      let e = r.params.spaceBetween;
      return "string" == typeof e && e.indexOf("%") >= 0 ? e = parseFloat(e.replace("%", "")) / 100 * r.size : "string" == typeof e && (e = parseFloat(e)), e;
    };
    l("init", () => {
      i = r.params.grid && r.params.grid.rows > 1;
    }), l("update", () => {
      const {
          params: e,
          el: t
        } = r,
        s = e.grid && e.grid.rows > 1;
      i && !s ? (t.classList.remove(`${e.containerModifierClass}grid`, `${e.containerModifierClass}grid-column`), a = 1, r.emitContainerClasses()) : !i && s && (t.classList.add(`${e.containerModifierClass}grid`), "column" === e.grid.fill && t.classList.add(`${e.containerModifierClass}grid-column`), r.emitContainerClasses()), i = s;
    }), r.grid = {
      initSlides: e => {
        const {
            slidesPerView: i
          } = r.params,
          {
            rows: n,
            fill: l
          } = r.params.grid,
          o = r.virtual && r.params.virtual.enabled ? r.virtual.slides.length : e.length;
        a = Math.floor(o / n), t = Math.floor(o / n) === o / n ? o : Math.ceil(o / n) * n, "auto" !== i && "row" === l && (t = Math.max(t, i * n)), s = t / n;
      },
      unsetSlides: () => {
        r.slides && r.slides.forEach(e => {
          e.swiperSlideGridSet && (e.style.height = "", e.style[r.getDirectionLabel("margin-top")] = "");
        });
      },
      updateSlide: (e, i, n) => {
        const {
            slidesPerGroup: l
          } = r.params,
          d = o(),
          {
            rows: c,
            fill: p
          } = r.params.grid,
          u = r.virtual && r.params.virtual.enabled ? r.virtual.slides.length : n.length;
        let m, h, f;
        if ("row" === p && l > 1) {
          const s = Math.floor(e / (l * c)),
            a = e - c * l * s,
            r = 0 === s ? l : Math.min(Math.ceil((u - s * c * l) / c), l);
          f = Math.floor(a / r), h = a - f * r + s * l, m = h + f * t / c, i.style.order = m;
        } else "column" === p ? (h = Math.floor(e / c), f = e - h * c, (h > a || h === a && f === c - 1) && (f += 1, f >= c && (f = 0, h += 1))) : (f = Math.floor(e / s), h = e - f * s);
        i.row = f, i.column = h, i.style.height = `calc((100% - ${(c - 1) * d}px) / ${c})`, i.style[r.getDirectionLabel("margin-top")] = 0 !== f ? d && `${d}px` : "", i.swiperSlideGridSet = !0;
      },
      updateWrapperSize: (e, s) => {
        const {
            centeredSlides: a,
            roundLengths: i
          } = r.params,
          n = o(),
          {
            rows: l
          } = r.params.grid;
        if (r.virtualSize = (e + n) * t, r.virtualSize = Math.ceil(r.virtualSize / l) - n, r.params.cssMode || (r.wrapperEl.style[r.getDirectionLabel("width")] = `${r.virtualSize + n}px`), a) {
          const e = [];
          for (let t = 0; t < s.length; t += 1) {
            let a = s[t];
            i && (a = Math.floor(a)), s[t] < r.virtualSize + s[0] && e.push(a);
          }
          s.splice(0, s.length), s.push(...e);
        }
      }
    };
  }, function (e) {
    let {
      swiper: t
    } = e;
    Object.assign(t, {
      appendSlide: oe.bind(t),
      prependSlide: de.bind(t),
      addSlide: ce.bind(t),
      removeSlide: pe.bind(t),
      removeAllSlides: ue.bind(t)
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      fadeEffect: {
        crossFade: !1
      }
    }), me({
      effect: "fade",
      swiper: t,
      on: a,
      setTranslate: () => {
        const {
          slides: e
        } = t;
        t.params.fadeEffect;
        for (let s = 0; s < e.length; s += 1) {
          const e = t.slides[s];
          let a = -e.swiperSlideOffset;
          t.params.virtualTranslate || (a -= t.translate);
          let i = 0;
          t.isHorizontal() || (i = a, a = 0);
          const r = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e.progress), 0) : 1 + Math.min(Math.max(e.progress, -1), 0),
            n = he(0, e);
          n.style.opacity = r, n.style.transform = `translate3d(${a}px, ${i}px, 0px)`;
        }
      },
      setTransition: e => {
        const s = t.slides.map(e => h(e));
        s.forEach(t => {
          t.style.transitionDuration = `${e}ms`;
        }), fe({
          swiper: t,
          duration: e,
          transformElements: s,
          allSlides: !0
        });
      },
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: !0,
        spaceBetween: 0,
        virtualTranslate: !t.params.cssMode
      })
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      cubeEffect: {
        slideShadows: !0,
        shadow: !0,
        shadowOffset: 20,
        shadowScale: .94
      }
    });
    const i = (e, t, s) => {
      let a = s ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"),
        i = s ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom");
      a || (a = v("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (s ? "left" : "top")).split(" ")), e.append(a)), i || (i = v("div", ("swiper-slide-shadow-cube swiper-slide-shadow-" + (s ? "right" : "bottom")).split(" ")), e.append(i)), a && (a.style.opacity = Math.max(-t, 0)), i && (i.style.opacity = Math.max(t, 0));
    };
    me({
      effect: "cube",
      swiper: t,
      on: a,
      setTranslate: () => {
        const {
            el: e,
            wrapperEl: s,
            slides: a,
            width: r,
            height: n,
            rtlTranslate: l,
            size: o,
            browser: d
          } = t,
          c = M(t),
          p = t.params.cubeEffect,
          u = t.isHorizontal(),
          m = t.virtual && t.params.virtual.enabled;
        let h,
          f = 0;
        p.shadow && (u ? (h = t.wrapperEl.querySelector(".swiper-cube-shadow"), h || (h = v("div", "swiper-cube-shadow"), t.wrapperEl.append(h)), h.style.height = `${r}px`) : (h = e.querySelector(".swiper-cube-shadow"), h || (h = v("div", "swiper-cube-shadow"), e.append(h))));
        for (let e = 0; e < a.length; e += 1) {
          const t = a[e];
          let s = e;
          m && (s = parseInt(t.getAttribute("data-swiper-slide-index"), 10));
          let r = 90 * s,
            n = Math.floor(r / 360);
          l && (r = -r, n = Math.floor(-r / 360));
          const d = Math.max(Math.min(t.progress, 1), -1);
          let h = 0,
            g = 0,
            v = 0;
          s % 4 == 0 ? (h = 4 * -n * o, v = 0) : (s - 1) % 4 == 0 ? (h = 0, v = 4 * -n * o) : (s - 2) % 4 == 0 ? (h = o + 4 * n * o, v = o) : (s - 3) % 4 == 0 && (h = -o, v = 3 * o + 4 * o * n), l && (h = -h), u || (g = h, h = 0);
          const w = `rotateX(${c(u ? 0 : -r)}deg) rotateY(${c(u ? r : 0)}deg) translate3d(${h}px, ${g}px, ${v}px)`;
          d <= 1 && d > -1 && (f = 90 * s + 90 * d, l && (f = 90 * -s - 90 * d)), t.style.transform = w, p.slideShadows && i(t, d, u);
        }
        if (s.style.transformOrigin = `50% 50% -${o / 2}px`, s.style["-webkit-transform-origin"] = `50% 50% -${o / 2}px`, p.shadow) if (u) h.style.transform = `translate3d(0px, ${r / 2 + p.shadowOffset}px, ${-r / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${p.shadowScale})`;else {
          const e = Math.abs(f) - 90 * Math.floor(Math.abs(f) / 90),
            t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2),
            s = p.shadowScale,
            a = p.shadowScale / t,
            i = p.shadowOffset;
          h.style.transform = `scale3d(${s}, 1, ${a}) translate3d(0px, ${n / 2 + i}px, ${-n / 2 / a}px) rotateX(-89.99deg)`;
        }
        const g = (d.isSafari || d.isWebView) && d.needPerspectiveFix ? -o / 2 : 0;
        s.style.transform = `translate3d(0px,0,${g}px) rotateX(${c(t.isHorizontal() ? 0 : f)}deg) rotateY(${c(t.isHorizontal() ? -f : 0)}deg)`, s.style.setProperty("--swiper-cube-translate-z", `${g}px`);
      },
      setTransition: e => {
        const {
          el: s,
          slides: a
        } = t;
        if (a.forEach(t => {
          t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(t => {
            t.style.transitionDuration = `${e}ms`;
          });
        }), t.params.cubeEffect.shadow && !t.isHorizontal()) {
          const t = s.querySelector(".swiper-cube-shadow");
          t && (t.style.transitionDuration = `${e}ms`);
        }
      },
      recreateShadows: () => {
        const e = t.isHorizontal();
        t.slides.forEach(t => {
          const s = Math.max(Math.min(t.progress, 1), -1);
          i(t, s, e);
        });
      },
      getEffectParams: () => t.params.cubeEffect,
      perspective: () => !0,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: !0,
        resistanceRatio: 0,
        spaceBetween: 0,
        centeredSlides: !1,
        virtualTranslate: !0
      })
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      flipEffect: {
        slideShadows: !0,
        limitRotation: !0
      }
    });
    const i = (e, s) => {
      let a = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-left") : e.querySelector(".swiper-slide-shadow-top"),
        i = t.isHorizontal() ? e.querySelector(".swiper-slide-shadow-right") : e.querySelector(".swiper-slide-shadow-bottom");
      a || (a = ge("flip", e, t.isHorizontal() ? "left" : "top")), i || (i = ge("flip", e, t.isHorizontal() ? "right" : "bottom")), a && (a.style.opacity = Math.max(-s, 0)), i && (i.style.opacity = Math.max(s, 0));
    };
    me({
      effect: "flip",
      swiper: t,
      on: a,
      setTranslate: () => {
        const {
            slides: e,
            rtlTranslate: s
          } = t,
          a = t.params.flipEffect,
          r = M(t);
        for (let n = 0; n < e.length; n += 1) {
          const l = e[n];
          let o = l.progress;
          t.params.flipEffect.limitRotation && (o = Math.max(Math.min(l.progress, 1), -1));
          const d = l.swiperSlideOffset;
          let c = -180 * o,
            p = 0,
            u = t.params.cssMode ? -d - t.translate : -d,
            m = 0;
          t.isHorizontal() ? s && (c = -c) : (m = u, u = 0, p = -c, c = 0), l.style.zIndex = -Math.abs(Math.round(o)) + e.length, a.slideShadows && i(l, o);
          const h = `translate3d(${u}px, ${m}px, 0px) rotateX(${r(p)}deg) rotateY(${r(c)}deg)`;
          he(0, l).style.transform = h;
        }
      },
      setTransition: e => {
        const s = t.slides.map(e => h(e));
        s.forEach(t => {
          t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(t => {
            t.style.transitionDuration = `${e}ms`;
          });
        }), fe({
          swiper: t,
          duration: e,
          transformElements: s
        });
      },
      recreateShadows: () => {
        t.params.flipEffect, t.slides.forEach(e => {
          let s = e.progress;
          t.params.flipEffect.limitRotation && (s = Math.max(Math.min(e.progress, 1), -1)), i(e, s);
        });
      },
      getEffectParams: () => t.params.flipEffect,
      perspective: () => !0,
      overwriteParams: () => ({
        slidesPerView: 1,
        slidesPerGroup: 1,
        watchSlidesProgress: !0,
        spaceBetween: 0,
        virtualTranslate: !t.params.cssMode
      })
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      coverflowEffect: {
        rotate: 50,
        stretch: 0,
        depth: 100,
        scale: 1,
        modifier: 1,
        slideShadows: !0
      }
    }), me({
      effect: "coverflow",
      swiper: t,
      on: a,
      setTranslate: () => {
        const {
            width: e,
            height: s,
            slides: a,
            slidesSizesGrid: i
          } = t,
          r = t.params.coverflowEffect,
          n = t.isHorizontal(),
          l = t.translate,
          o = n ? e / 2 - l : s / 2 - l,
          d = n ? r.rotate : -r.rotate,
          c = r.depth,
          p = M(t);
        for (let e = 0, t = a.length; e < t; e += 1) {
          const t = a[e],
            s = i[e],
            l = (o - t.swiperSlideOffset - s / 2) / s,
            u = "function" == typeof r.modifier ? r.modifier(l) : l * r.modifier;
          let m = n ? d * u : 0,
            h = n ? 0 : d * u,
            f = -c * Math.abs(u),
            g = r.stretch;
          "string" == typeof g && -1 !== g.indexOf("%") && (g = parseFloat(r.stretch) / 100 * s);
          let v = n ? 0 : g * u,
            w = n ? g * u : 0,
            b = 1 - (1 - r.scale) * Math.abs(u);
          Math.abs(w) < .001 && (w = 0), Math.abs(v) < .001 && (v = 0), Math.abs(f) < .001 && (f = 0), Math.abs(m) < .001 && (m = 0), Math.abs(h) < .001 && (h = 0), Math.abs(b) < .001 && (b = 0);
          const y = `translate3d(${w}px,${v}px,${f}px)  rotateX(${p(h)}deg) rotateY(${p(m)}deg) scale(${b})`;
          if (he(0, t).style.transform = y, t.style.zIndex = 1 - Math.abs(Math.round(u)), r.slideShadows) {
            let e = n ? t.querySelector(".swiper-slide-shadow-left") : t.querySelector(".swiper-slide-shadow-top"),
              s = n ? t.querySelector(".swiper-slide-shadow-right") : t.querySelector(".swiper-slide-shadow-bottom");
            e || (e = ge("coverflow", t, n ? "left" : "top")), s || (s = ge("coverflow", t, n ? "right" : "bottom")), e && (e.style.opacity = u > 0 ? u : 0), s && (s.style.opacity = -u > 0 ? -u : 0);
          }
        }
      },
      setTransition: e => {
        t.slides.map(e => h(e)).forEach(t => {
          t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(t => {
            t.style.transitionDuration = `${e}ms`;
          });
        });
      },
      perspective: () => !0,
      overwriteParams: () => ({
        watchSlidesProgress: !0
      })
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      creativeEffect: {
        limitProgress: 1,
        shadowPerProgress: !1,
        progressMultiplier: 1,
        perspective: !0,
        prev: {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          opacity: 1,
          scale: 1
        },
        next: {
          translate: [0, 0, 0],
          rotate: [0, 0, 0],
          opacity: 1,
          scale: 1
        }
      }
    });
    const i = e => "string" == typeof e ? e : `${e}px`;
    me({
      effect: "creative",
      swiper: t,
      on: a,
      setTranslate: () => {
        const {
            slides: e,
            wrapperEl: s,
            slidesSizesGrid: a
          } = t,
          r = t.params.creativeEffect,
          {
            progressMultiplier: n
          } = r,
          l = t.params.centeredSlides,
          o = M(t);
        if (l) {
          const e = a[0] / 2 - t.params.slidesOffsetBefore || 0;
          s.style.transform = `translateX(calc(50% - ${e}px))`;
        }
        for (let s = 0; s < e.length; s += 1) {
          const a = e[s],
            d = a.progress,
            c = Math.min(Math.max(a.progress, -r.limitProgress), r.limitProgress);
          let p = c;
          l || (p = Math.min(Math.max(a.originalProgress, -r.limitProgress), r.limitProgress));
          const u = a.swiperSlideOffset,
            m = [t.params.cssMode ? -u - t.translate : -u, 0, 0],
            h = [0, 0, 0];
          let f = !1;
          t.isHorizontal() || (m[1] = m[0], m[0] = 0);
          let g = {
            translate: [0, 0, 0],
            rotate: [0, 0, 0],
            scale: 1,
            opacity: 1
          };
          c < 0 ? (g = r.next, f = !0) : c > 0 && (g = r.prev, f = !0), m.forEach((e, t) => {
            m[t] = `calc(${e}px + (${i(g.translate[t])} * ${Math.abs(c * n)}))`;
          }), h.forEach((e, t) => {
            let s = g.rotate[t] * Math.abs(c * n);
            h[t] = s;
          }), a.style.zIndex = -Math.abs(Math.round(d)) + e.length;
          const v = m.join(", "),
            w = `rotateX(${o(h[0])}deg) rotateY(${o(h[1])}deg) rotateZ(${o(h[2])}deg)`,
            b = p < 0 ? `scale(${1 + (1 - g.scale) * p * n})` : `scale(${1 - (1 - g.scale) * p * n})`,
            y = p < 0 ? 1 + (1 - g.opacity) * p * n : 1 - (1 - g.opacity) * p * n,
            E = `translate3d(${v}) ${w} ${b}`;
          if (f && g.shadow || !f) {
            let e = a.querySelector(".swiper-slide-shadow");
            if (!e && g.shadow && (e = ge("creative", a)), e) {
              const t = r.shadowPerProgress ? c * (1 / r.limitProgress) : c;
              e.style.opacity = Math.min(Math.max(Math.abs(t), 0), 1);
            }
          }
          const x = he(0, a);
          x.style.transform = E, x.style.opacity = y, g.origin && (x.style.transformOrigin = g.origin);
        }
      },
      setTransition: e => {
        const s = t.slides.map(e => h(e));
        s.forEach(t => {
          t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow").forEach(t => {
            t.style.transitionDuration = `${e}ms`;
          });
        }), fe({
          swiper: t,
          duration: e,
          transformElements: s,
          allSlides: !0
        });
      },
      perspective: () => t.params.creativeEffect.perspective,
      overwriteParams: () => ({
        watchSlidesProgress: !0,
        virtualTranslate: !t.params.cssMode
      })
    });
  }, function (e) {
    let {
      swiper: t,
      extendParams: s,
      on: a
    } = e;
    s({
      cardsEffect: {
        slideShadows: !0,
        rotate: !0,
        perSlideRotate: 2,
        perSlideOffset: 8
      }
    }), me({
      effect: "cards",
      swiper: t,
      on: a,
      setTranslate: () => {
        const {
            slides: e,
            activeIndex: s,
            rtlTranslate: a
          } = t,
          i = t.params.cardsEffect,
          {
            startTranslate: r,
            isTouched: n
          } = t.touchEventsData,
          l = a ? -t.translate : t.translate;
        for (let o = 0; o < e.length; o += 1) {
          const d = e[o],
            c = d.progress,
            p = Math.min(Math.max(c, -4), 4);
          let u = d.swiperSlideOffset;
          t.params.centeredSlides && !t.params.cssMode && (t.wrapperEl.style.transform = `translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (u -= e[0].swiperSlideOffset);
          let m = t.params.cssMode ? -u - t.translate : -u,
            h = 0;
          const f = -100 * Math.abs(p);
          let g = 1,
            v = -i.perSlideRotate * p,
            w = i.perSlideOffset - .75 * Math.abs(p);
          const b = t.virtual && t.params.virtual.enabled ? t.virtual.from + o : o,
            y = (b === s || b === s - 1) && p > 0 && p < 1 && (n || t.params.cssMode) && l < r,
            E = (b === s || b === s + 1) && p < 0 && p > -1 && (n || t.params.cssMode) && l > r;
          if (y || E) {
            const e = (1 - Math.abs((Math.abs(p) - .5) / .5)) ** .5;
            v += -28 * p * e, g += -.5 * e, w += 96 * e, h = -25 * e * Math.abs(p) + "%";
          }
          if (m = p < 0 ? `calc(${m}px ${a ? "-" : "+"} (${w * Math.abs(p)}%))` : p > 0 ? `calc(${m}px ${a ? "-" : "+"} (-${w * Math.abs(p)}%))` : `${m}px`, !t.isHorizontal()) {
            const e = h;
            h = m, m = e;
          }
          const x = p < 0 ? "" + (1 + (1 - g) * p) : "" + (1 - (1 - g) * p),
            S = `\n        translate3d(${m}, ${h}, ${f}px)\n        rotateZ(${i.rotate ? a ? -v : v : 0}deg)\n        scale(${x})\n      `;
          if (i.slideShadows) {
            let e = d.querySelector(".swiper-slide-shadow");
            e || (e = ge("cards", d)), e && (e.style.opacity = Math.min(Math.max((Math.abs(p) - .5) / .5, 0), 1));
          }
          d.style.zIndex = -Math.abs(Math.round(c)) + e.length;
          he(0, d).style.transform = S;
        }
      },
      setTransition: e => {
        const s = t.slides.map(e => h(e));
        s.forEach(t => {
          t.style.transitionDuration = `${e}ms`, t.querySelectorAll(".swiper-slide-shadow").forEach(t => {
            t.style.transitionDuration = `${e}ms`;
          });
        }), fe({
          swiper: t,
          duration: e,
          transformElements: s
        });
      },
      perspective: () => !0,
      overwriteParams: () => ({
        _loopSwapReset: !1,
        watchSlidesProgress: !0,
        loopAdditionalSlides: t.params.cardsEffect.rotate ? 3 : 2,
        centeredSlides: !0,
        virtualTranslate: !t.params.cssMode
      })
    });
  }];
  return re.use(ve), re;
}();
!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).IMask = {});
}(this, function (t) {
  "use strict";

  function e(t) {
    return "string" == typeof t || t instanceof String;
  }
  function s(t) {
    var e;
    return "object" == typeof t && null != t && "Object" === (null == t || null == (e = t.constructor) ? void 0 : e.name);
  }
  function i(t, e) {
    return Array.isArray(e) ? i(t, (t, s) => e.includes(s)) : Object.entries(t).reduce((t, s) => {
      let [i, a] = s;
      return e(a, i) && (t[i] = a), t;
    }, {});
  }
  const a = {
    NONE: "NONE",
    LEFT: "LEFT",
    FORCE_LEFT: "FORCE_LEFT",
    RIGHT: "RIGHT",
    FORCE_RIGHT: "FORCE_RIGHT"
  };
  function u(t) {
    switch (t) {
      case a.LEFT:
        return a.FORCE_LEFT;
      case a.RIGHT:
        return a.FORCE_RIGHT;
      default:
        return t;
    }
  }
  function n(t) {
    return t.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
  }
  function r(t, e) {
    if (e === t) return !0;
    const s = Array.isArray(e),
      i = Array.isArray(t);
    let a;
    if (s && i) {
      if (e.length != t.length) return !1;
      for (a = 0; a < e.length; a++) if (!r(e[a], t[a])) return !1;
      return !0;
    }
    if (s != i) return !1;
    if (e && t && "object" == typeof e && "object" == typeof t) {
      const s = e instanceof Date,
        i = t instanceof Date;
      if (s && i) return e.getTime() == t.getTime();
      if (s != i) return !1;
      const u = e instanceof RegExp,
        n = t instanceof RegExp;
      if (u && n) return e.toString() == t.toString();
      if (u != n) return !1;
      const h = Object.keys(e);
      for (a = 0; a < h.length; a++) if (!Object.prototype.hasOwnProperty.call(t, h[a])) return !1;
      for (a = 0; a < h.length; a++) if (!r(t[h[a]], e[h[a]])) return !1;
      return !0;
    }
    return !(!e || !t || "function" != typeof e || "function" != typeof t) && e.toString() === t.toString();
  }
  class h {
    constructor(t) {
      for (Object.assign(this, t); this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos);) --this.oldSelection.start;
      if (this.insertedCount) for (; this.value.slice(this.cursorPos) !== this.oldValue.slice(this.oldSelection.end);) this.value.length - this.cursorPos < this.oldValue.length - this.oldSelection.end ? ++this.oldSelection.end : ++this.cursorPos;
    }
    get startChangePos() {
      return Math.min(this.cursorPos, this.oldSelection.start);
    }
    get insertedCount() {
      return this.cursorPos - this.startChangePos;
    }
    get inserted() {
      return this.value.substr(this.startChangePos, this.insertedCount);
    }
    get removedCount() {
      return Math.max(this.oldSelection.end - this.startChangePos || this.oldValue.length - this.value.length, 0);
    }
    get removed() {
      return this.oldValue.substr(this.startChangePos, this.removedCount);
    }
    get head() {
      return this.value.substring(0, this.startChangePos);
    }
    get tail() {
      return this.value.substring(this.startChangePos + this.insertedCount);
    }
    get removeDirection() {
      return !this.removedCount || this.insertedCount ? a.NONE : this.oldSelection.end !== this.cursorPos && this.oldSelection.start !== this.cursorPos || this.oldSelection.end !== this.oldSelection.start ? a.LEFT : a.RIGHT;
    }
  }
  function o(t, e) {
    return new o.InputMask(t, e);
  }
  function l(t) {
    if (null == t) throw new Error("mask property should be defined");
    return t instanceof RegExp ? o.MaskedRegExp : e(t) ? o.MaskedPattern : t === Date ? o.MaskedDate : t === Number ? o.MaskedNumber : Array.isArray(t) || t === Array ? o.MaskedDynamic : o.Masked && t.prototype instanceof o.Masked ? t : o.Masked && t instanceof o.Masked ? t.constructor : t instanceof Function ? o.MaskedFunction : (console.warn("Mask not found for mask", t), o.Masked);
  }
  function p(t) {
    if (!t) throw new Error("Options in not defined");
    if (o.Masked) {
      if (t.prototype instanceof o.Masked) return {
        mask: t
      };
      const {
        mask: e,
        ...a
      } = t instanceof o.Masked ? {
        mask: t
      } : s(t) && t.mask instanceof o.Masked ? t : {};
      if (e) {
        const t = e.mask;
        return {
          ...i(e, (t, e) => !e.startsWith("_")),
          mask: e.constructor,
          _mask: t,
          ...a
        };
      }
    }
    return s(t) ? {
      ...t
    } : {
      mask: t
    };
  }
  function d(t) {
    if (o.Masked && t instanceof o.Masked) return t;
    const e = p(t),
      s = l(e.mask);
    if (!s) throw new Error("Masked class is not found for provided mask " + e.mask + ", appropriate module needs to be imported manually before creating mask.");
    return e.mask === s && delete e.mask, e._mask && (e.mask = e._mask, delete e._mask), new s(e);
  }
  o.createMask = d;
  class c {
    get selectionStart() {
      let t;
      try {
        t = this._unsafeSelectionStart;
      } catch {}
      return null != t ? t : this.value.length;
    }
    get selectionEnd() {
      let t;
      try {
        t = this._unsafeSelectionEnd;
      } catch {}
      return null != t ? t : this.value.length;
    }
    select(t, e) {
      if (null != t && null != e && (t !== this.selectionStart || e !== this.selectionEnd)) try {
        this._unsafeSelect(t, e);
      } catch {}
    }
    get isActive() {
      return !1;
    }
  }
  o.MaskElement = c;
  class g extends c {
    constructor(t) {
      super(), this.input = t, this._onKeydown = this._onKeydown.bind(this), this._onInput = this._onInput.bind(this), this._onBeforeinput = this._onBeforeinput.bind(this), this._onCompositionEnd = this._onCompositionEnd.bind(this);
    }
    get rootElement() {
      var t, e, s;
      return null != (t = null == (e = (s = this.input).getRootNode) ? void 0 : e.call(s)) ? t : document;
    }
    get isActive() {
      return this.input === this.rootElement.activeElement;
    }
    bindEvents(t) {
      this.input.addEventListener("keydown", this._onKeydown), this.input.addEventListener("input", this._onInput), this.input.addEventListener("beforeinput", this._onBeforeinput), this.input.addEventListener("compositionend", this._onCompositionEnd), this.input.addEventListener("drop", t.drop), this.input.addEventListener("click", t.click), this.input.addEventListener("focus", t.focus), this.input.addEventListener("blur", t.commit), this._handlers = t;
    }
    _onKeydown(t) {
      return this._handlers.redo && (90 === t.keyCode && t.shiftKey && (t.metaKey || t.ctrlKey) || 89 === t.keyCode && t.ctrlKey) ? (t.preventDefault(), this._handlers.redo(t)) : this._handlers.undo && 90 === t.keyCode && (t.metaKey || t.ctrlKey) ? (t.preventDefault(), this._handlers.undo(t)) : void (t.isComposing || this._handlers.selectionChange(t));
    }
    _onBeforeinput(t) {
      return "historyUndo" === t.inputType && this._handlers.undo ? (t.preventDefault(), this._handlers.undo(t)) : "historyRedo" === t.inputType && this._handlers.redo ? (t.preventDefault(), this._handlers.redo(t)) : void 0;
    }
    _onCompositionEnd(t) {
      this._handlers.input(t);
    }
    _onInput(t) {
      t.isComposing || this._handlers.input(t);
    }
    unbindEvents() {
      this.input.removeEventListener("keydown", this._onKeydown), this.input.removeEventListener("input", this._onInput), this.input.removeEventListener("beforeinput", this._onBeforeinput), this.input.removeEventListener("compositionend", this._onCompositionEnd), this.input.removeEventListener("drop", this._handlers.drop), this.input.removeEventListener("click", this._handlers.click), this.input.removeEventListener("focus", this._handlers.focus), this.input.removeEventListener("blur", this._handlers.commit), this._handlers = {};
    }
  }
  o.HTMLMaskElement = g;
  class k extends g {
    constructor(t) {
      super(t), this.input = t;
    }
    get _unsafeSelectionStart() {
      return null != this.input.selectionStart ? this.input.selectionStart : this.value.length;
    }
    get _unsafeSelectionEnd() {
      return this.input.selectionEnd;
    }
    _unsafeSelect(t, e) {
      this.input.setSelectionRange(t, e);
    }
    get value() {
      return this.input.value;
    }
    set value(t) {
      this.input.value = t;
    }
  }
  o.HTMLMaskElement = g;
  class m extends g {
    get _unsafeSelectionStart() {
      const t = this.rootElement,
        e = t.getSelection && t.getSelection(),
        s = e && e.anchorOffset,
        i = e && e.focusOffset;
      return null == i || null == s || s < i ? s : i;
    }
    get _unsafeSelectionEnd() {
      const t = this.rootElement,
        e = t.getSelection && t.getSelection(),
        s = e && e.anchorOffset,
        i = e && e.focusOffset;
      return null == i || null == s || s > i ? s : i;
    }
    _unsafeSelect(t, e) {
      if (!this.rootElement.createRange) return;
      const s = this.rootElement.createRange();
      s.setStart(this.input.firstChild || this.input, t), s.setEnd(this.input.lastChild || this.input, e);
      const i = this.rootElement,
        a = i.getSelection && i.getSelection();
      a && (a.removeAllRanges(), a.addRange(s));
    }
    get value() {
      return this.input.textContent || "";
    }
    set value(t) {
      this.input.textContent = t;
    }
  }
  o.HTMLContenteditableMaskElement = m;
  class _ {
    constructor() {
      this.states = [], this.currentIndex = 0;
    }
    get currentState() {
      return this.states[this.currentIndex];
    }
    get isEmpty() {
      return 0 === this.states.length;
    }
    push(t) {
      this.currentIndex < this.states.length - 1 && (this.states.length = this.currentIndex + 1), this.states.push(t), this.states.length > _.MAX_LENGTH && this.states.shift(), this.currentIndex = this.states.length - 1;
    }
    go(t) {
      return this.currentIndex = Math.min(Math.max(this.currentIndex + t, 0), this.states.length - 1), this.currentState;
    }
    undo() {
      return this.go(-1);
    }
    redo() {
      return this.go(1);
    }
    clear() {
      this.states.length = 0, this.currentIndex = 0;
    }
  }
  _.MAX_LENGTH = 100;
  class f {
    constructor(t, e) {
      this.el = t instanceof c ? t : t.isContentEditable && "INPUT" !== t.tagName && "TEXTAREA" !== t.tagName ? new m(t) : new k(t), this.masked = d(e), this._listeners = {}, this._value = "", this._unmaskedValue = "", this._rawInputValue = "", this.history = new _(), this._saveSelection = this._saveSelection.bind(this), this._onInput = this._onInput.bind(this), this._onChange = this._onChange.bind(this), this._onDrop = this._onDrop.bind(this), this._onFocus = this._onFocus.bind(this), this._onClick = this._onClick.bind(this), this._onUndo = this._onUndo.bind(this), this._onRedo = this._onRedo.bind(this), this.alignCursor = this.alignCursor.bind(this), this.alignCursorFriendly = this.alignCursorFriendly.bind(this), this._bindEvents(), this.updateValue(), this._onChange();
    }
    maskEquals(t) {
      var e;
      return null == t || (null == (e = this.masked) ? void 0 : e.maskEquals(t));
    }
    get mask() {
      return this.masked.mask;
    }
    set mask(t) {
      if (this.maskEquals(t)) return;
      if (!(t instanceof o.Masked) && this.masked.constructor === l(t)) return void this.masked.updateOptions({
        mask: t
      });
      const e = t instanceof o.Masked ? t : d({
        mask: t
      });
      e.unmaskedValue = this.masked.unmaskedValue, this.masked = e;
    }
    get value() {
      return this._value;
    }
    set value(t) {
      this.value !== t && (this.masked.value = t, this.updateControl("auto"));
    }
    get unmaskedValue() {
      return this._unmaskedValue;
    }
    set unmaskedValue(t) {
      this.unmaskedValue !== t && (this.masked.unmaskedValue = t, this.updateControl("auto"));
    }
    get rawInputValue() {
      return this._rawInputValue;
    }
    set rawInputValue(t) {
      this.rawInputValue !== t && (this.masked.rawInputValue = t, this.updateControl(), this.alignCursor());
    }
    get typedValue() {
      return this.masked.typedValue;
    }
    set typedValue(t) {
      this.masked.typedValueEquals(t) || (this.masked.typedValue = t, this.updateControl("auto"));
    }
    get displayValue() {
      return this.masked.displayValue;
    }
    _bindEvents() {
      this.el.bindEvents({
        selectionChange: this._saveSelection,
        input: this._onInput,
        drop: this._onDrop,
        click: this._onClick,
        focus: this._onFocus,
        commit: this._onChange,
        undo: this._onUndo,
        redo: this._onRedo
      });
    }
    _unbindEvents() {
      this.el && this.el.unbindEvents();
    }
    _fireEvent(t, e) {
      const s = this._listeners[t];
      s && s.forEach(t => t(e));
    }
    get selectionStart() {
      return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
    }
    get cursorPos() {
      return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
    }
    set cursorPos(t) {
      this.el && this.el.isActive && (this.el.select(t, t), this._saveSelection());
    }
    _saveSelection() {
      this.displayValue !== this.el.value && console.warn("Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly."), this._selection = {
        start: this.selectionStart,
        end: this.cursorPos
      };
    }
    updateValue() {
      this.masked.value = this.el.value, this._value = this.masked.value, this._unmaskedValue = this.masked.unmaskedValue, this._rawInputValue = this.masked.rawInputValue;
    }
    updateControl(t) {
      const e = this.masked.unmaskedValue,
        s = this.masked.value,
        i = this.masked.rawInputValue,
        a = this.displayValue,
        u = this.unmaskedValue !== e || this.value !== s || this._rawInputValue !== i;
      this._unmaskedValue = e, this._value = s, this._rawInputValue = i, this.el.value !== a && (this.el.value = a), "auto" === t ? this.alignCursor() : null != t && (this.cursorPos = t), u && this._fireChangeEvents(), this._historyChanging || !u && !this.history.isEmpty || this.history.push({
        unmaskedValue: e,
        selection: {
          start: this.selectionStart,
          end: this.cursorPos
        }
      });
    }
    updateOptions(t) {
      const {
          mask: e,
          ...s
        } = t,
        i = !this.maskEquals(e),
        a = this.masked.optionsIsChanged(s);
      i && (this.mask = e), a && this.masked.updateOptions(s), (i || a) && this.updateControl();
    }
    updateCursor(t) {
      null != t && (this.cursorPos = t, this._delayUpdateCursor(t));
    }
    _delayUpdateCursor(t) {
      this._abortUpdateCursor(), this._changingCursorPos = t, this._cursorChanging = setTimeout(() => {
        this.el && (this.cursorPos = this._changingCursorPos, this._abortUpdateCursor());
      }, 10);
    }
    _fireChangeEvents() {
      this._fireEvent("accept", this._inputEvent), this.masked.isComplete && this._fireEvent("complete", this._inputEvent);
    }
    _abortUpdateCursor() {
      this._cursorChanging && (clearTimeout(this._cursorChanging), delete this._cursorChanging);
    }
    alignCursor() {
      this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, a.LEFT));
    }
    alignCursorFriendly() {
      this.selectionStart === this.cursorPos && this.alignCursor();
    }
    on(t, e) {
      return this._listeners[t] || (this._listeners[t] = []), this._listeners[t].push(e), this;
    }
    off(t, e) {
      if (!this._listeners[t]) return this;
      if (!e) return delete this._listeners[t], this;
      const s = this._listeners[t].indexOf(e);
      return s >= 0 && this._listeners[t].splice(s, 1), this;
    }
    _onInput(t) {
      this._inputEvent = t, this._abortUpdateCursor();
      const e = new h({
          value: this.el.value,
          cursorPos: this.cursorPos,
          oldValue: this.displayValue,
          oldSelection: this._selection
        }),
        s = this.masked.rawInputValue,
        i = this.masked.splice(e.startChangePos, e.removed.length, e.inserted, e.removeDirection, {
          input: !0,
          raw: !0
        }).offset,
        u = s === this.masked.rawInputValue ? e.removeDirection : a.NONE;
      let n = this.masked.nearestInputPos(e.startChangePos + i, u);
      u !== a.NONE && (n = this.masked.nearestInputPos(n, a.NONE)), this.updateControl(n), delete this._inputEvent;
    }
    _onChange() {
      this.displayValue !== this.el.value && this.updateValue(), this.masked.doCommit(), this.updateControl(), this._saveSelection();
    }
    _onDrop(t) {
      t.preventDefault(), t.stopPropagation();
    }
    _onFocus(t) {
      this.alignCursorFriendly();
    }
    _onClick(t) {
      this.alignCursorFriendly();
    }
    _onUndo() {
      this._applyHistoryState(this.history.undo());
    }
    _onRedo() {
      this._applyHistoryState(this.history.redo());
    }
    _applyHistoryState(t) {
      t && (this._historyChanging = !0, this.unmaskedValue = t.unmaskedValue, this.el.select(t.selection.start, t.selection.end), this._saveSelection(), this._historyChanging = !1);
    }
    destroy() {
      this._unbindEvents(), this._listeners.length = 0, delete this.el;
    }
  }
  o.InputMask = f;
  class v {
    static normalize(t) {
      return Array.isArray(t) ? t : [t, new v()];
    }
    constructor(t) {
      Object.assign(this, {
        inserted: "",
        rawInserted: "",
        tailShift: 0,
        skip: !1
      }, t);
    }
    aggregate(t) {
      return this.inserted += t.inserted, this.rawInserted += t.rawInserted, this.tailShift += t.tailShift, this.skip = this.skip || t.skip, this;
    }
    get offset() {
      return this.tailShift + this.inserted.length;
    }
    get consumed() {
      return Boolean(this.rawInserted) || this.skip;
    }
    equals(t) {
      return this.inserted === t.inserted && this.tailShift === t.tailShift && this.rawInserted === t.rawInserted && this.skip === t.skip;
    }
  }
  o.ChangeDetails = v;
  class E {
    constructor(t, e, s) {
      void 0 === t && (t = ""), void 0 === e && (e = 0), this.value = t, this.from = e, this.stop = s;
    }
    toString() {
      return this.value;
    }
    extend(t) {
      this.value += String(t);
    }
    appendTo(t) {
      return t.append(this.toString(), {
        tail: !0
      }).aggregate(t._appendPlaceholder());
    }
    get state() {
      return {
        value: this.value,
        from: this.from,
        stop: this.stop
      };
    }
    set state(t) {
      Object.assign(this, t);
    }
    unshift(t) {
      if (!this.value.length || null != t && this.from >= t) return "";
      const e = this.value[0];
      return this.value = this.value.slice(1), e;
    }
    shift() {
      if (!this.value.length) return "";
      const t = this.value[this.value.length - 1];
      return this.value = this.value.slice(0, -1), t;
    }
  }
  class C {
    constructor(t) {
      this._value = "", this._update({
        ...C.DEFAULTS,
        ...t
      }), this._initialized = !0;
    }
    updateOptions(t) {
      this.optionsIsChanged(t) && this.withValueRefresh(this._update.bind(this, t));
    }
    _update(t) {
      Object.assign(this, t);
    }
    get state() {
      return {
        _value: this.value,
        _rawInputValue: this.rawInputValue
      };
    }
    set state(t) {
      this._value = t._value;
    }
    reset() {
      this._value = "";
    }
    get value() {
      return this._value;
    }
    set value(t) {
      this.resolve(t, {
        input: !0
      });
    }
    resolve(t, e) {
      void 0 === e && (e = {
        input: !0
      }), this.reset(), this.append(t, e, ""), this.doCommit();
    }
    get unmaskedValue() {
      return this.value;
    }
    set unmaskedValue(t) {
      this.resolve(t, {});
    }
    get typedValue() {
      return this.parse ? this.parse(this.value, this) : this.unmaskedValue;
    }
    set typedValue(t) {
      this.format ? this.value = this.format(t, this) : this.unmaskedValue = String(t);
    }
    get rawInputValue() {
      return this.extractInput(0, this.displayValue.length, {
        raw: !0
      });
    }
    set rawInputValue(t) {
      this.resolve(t, {
        raw: !0
      });
    }
    get displayValue() {
      return this.value;
    }
    get isComplete() {
      return !0;
    }
    get isFilled() {
      return this.isComplete;
    }
    nearestInputPos(t, e) {
      return t;
    }
    totalInputPositions(t, e) {
      return void 0 === t && (t = 0), void 0 === e && (e = this.displayValue.length), Math.min(this.displayValue.length, e - t);
    }
    extractInput(t, e, s) {
      return void 0 === t && (t = 0), void 0 === e && (e = this.displayValue.length), this.displayValue.slice(t, e);
    }
    extractTail(t, e) {
      return void 0 === t && (t = 0), void 0 === e && (e = this.displayValue.length), new E(this.extractInput(t, e), t);
    }
    appendTail(t) {
      return e(t) && (t = new E(String(t))), t.appendTo(this);
    }
    _appendCharRaw(t, e) {
      return t ? (this._value += t, new v({
        inserted: t,
        rawInserted: t
      })) : new v();
    }
    _appendChar(t, e, s) {
      void 0 === e && (e = {});
      const i = this.state;
      let a;
      if ([t, a] = this.doPrepareChar(t, e), t && (a = a.aggregate(this._appendCharRaw(t, e)), !a.rawInserted && "pad" === this.autofix)) {
        const s = this.state;
        this.state = i;
        let u = this.pad(e);
        const n = this._appendCharRaw(t, e);
        u = u.aggregate(n), n.rawInserted || u.equals(a) ? a = u : this.state = s;
      }
      if (a.inserted) {
        let t,
          u = !1 !== this.doValidate(e);
        if (u && null != s) {
          const e = this.state;
          if (!0 === this.overwrite) {
            t = s.state;
            for (let t = 0; t < a.rawInserted.length; ++t) s.unshift(this.displayValue.length - a.tailShift);
          }
          let i = this.appendTail(s);
          if (u = i.rawInserted.length === s.toString().length, !(u && i.inserted || "shift" !== this.overwrite)) {
            this.state = e, t = s.state;
            for (let t = 0; t < a.rawInserted.length; ++t) s.shift();
            i = this.appendTail(s), u = i.rawInserted.length === s.toString().length;
          }
          u && i.inserted && (this.state = e);
        }
        u || (a = new v(), this.state = i, s && t && (s.state = t));
      }
      return a;
    }
    _appendPlaceholder() {
      return new v();
    }
    _appendEager() {
      return new v();
    }
    append(t, s, i) {
      if (!e(t)) throw new Error("value should be string");
      const a = e(i) ? new E(String(i)) : i;
      let u;
      null != s && s.tail && (s._beforeTailState = this.state), [t, u] = this.doPrepare(t, s);
      for (let e = 0; e < t.length; ++e) {
        const i = this._appendChar(t[e], s, a);
        if (!i.rawInserted && !this.doSkipInvalid(t[e], s, a)) break;
        u.aggregate(i);
      }
      return (!0 === this.eager || "append" === this.eager) && null != s && s.input && t && u.aggregate(this._appendEager()), null != a && (u.tailShift += this.appendTail(a).tailShift), u;
    }
    remove(t, e) {
      return void 0 === t && (t = 0), void 0 === e && (e = this.displayValue.length), this._value = this.displayValue.slice(0, t) + this.displayValue.slice(e), new v();
    }
    withValueRefresh(t) {
      if (this._refreshing || !this._initialized) return t();
      this._refreshing = !0;
      const e = this.rawInputValue,
        s = this.value,
        i = t();
      return this.rawInputValue = e, this.value && this.value !== s && 0 === s.indexOf(this.value) && (this.append(s.slice(this.displayValue.length), {}, ""), this.doCommit()), delete this._refreshing, i;
    }
    runIsolated(t) {
      if (this._isolated || !this._initialized) return t(this);
      this._isolated = !0;
      const e = this.state,
        s = t(this);
      return this.state = e, delete this._isolated, s;
    }
    doSkipInvalid(t, e, s) {
      return Boolean(this.skipInvalid);
    }
    doPrepare(t, e) {
      return void 0 === e && (e = {}), v.normalize(this.prepare ? this.prepare(t, this, e) : t);
    }
    doPrepareChar(t, e) {
      return void 0 === e && (e = {}), v.normalize(this.prepareChar ? this.prepareChar(t, this, e) : t);
    }
    doValidate(t) {
      return (!this.validate || this.validate(this.value, this, t)) && (!this.parent || this.parent.doValidate(t));
    }
    doCommit() {
      this.commit && this.commit(this.value, this);
    }
    splice(t, e, s, i, n) {
      void 0 === s && (s = ""), void 0 === i && (i = a.NONE), void 0 === n && (n = {
        input: !0
      });
      const r = t + e,
        h = this.extractTail(r),
        o = !0 === this.eager || "remove" === this.eager;
      let l;
      o && (i = u(i), l = this.extractInput(0, r, {
        raw: !0
      }));
      let p = t;
      const d = new v();
      if (i !== a.NONE && (p = this.nearestInputPos(t, e > 1 && 0 !== t && !o ? a.NONE : i), d.tailShift = p - t), d.aggregate(this.remove(p)), o && i !== a.NONE && l === this.rawInputValue) if (i === a.FORCE_LEFT) {
        let t;
        for (; l === this.rawInputValue && (t = this.displayValue.length);) d.aggregate(new v({
          tailShift: -1
        })).aggregate(this.remove(t - 1));
      } else i === a.FORCE_RIGHT && h.unshift();
      return d.aggregate(this.append(s, n, h));
    }
    maskEquals(t) {
      return this.mask === t;
    }
    optionsIsChanged(t) {
      return !r(this, t);
    }
    typedValueEquals(t) {
      const e = this.typedValue;
      return t === e || C.EMPTY_VALUES.includes(t) && C.EMPTY_VALUES.includes(e) || !!this.format && this.format(t, this) === this.format(this.typedValue, this);
    }
    pad(t) {
      return new v();
    }
  }
  C.DEFAULTS = {
    skipInvalid: !0
  }, C.EMPTY_VALUES = [void 0, null, ""], o.Masked = C;
  class A {
    constructor(t, e) {
      void 0 === t && (t = []), void 0 === e && (e = 0), this.chunks = t, this.from = e;
    }
    toString() {
      return this.chunks.map(String).join("");
    }
    extend(t) {
      if (!String(t)) return;
      t = e(t) ? new E(String(t)) : t;
      const s = this.chunks[this.chunks.length - 1],
        i = s && (s.stop === t.stop || null == t.stop) && t.from === s.from + s.toString().length;
      if (t instanceof E) i ? s.extend(t.toString()) : this.chunks.push(t);else if (t instanceof A) {
        if (null == t.stop) {
          let e;
          for (; t.chunks.length && null == t.chunks[0].stop;) e = t.chunks.shift(), e.from += t.from, this.extend(e);
        }
        t.toString() && (t.stop = t.blockIndex, this.chunks.push(t));
      }
    }
    appendTo(t) {
      if (!(t instanceof o.MaskedPattern)) {
        return new E(this.toString()).appendTo(t);
      }
      const e = new v();
      for (let s = 0; s < this.chunks.length; ++s) {
        const i = this.chunks[s],
          a = t._mapPosToBlock(t.displayValue.length),
          u = i.stop;
        let n;
        if (null != u && (!a || a.index <= u) && ((i instanceof A || t._stops.indexOf(u) >= 0) && e.aggregate(t._appendPlaceholder(u)), n = i instanceof A && t._blocks[u]), n) {
          const s = n.appendTail(i);
          e.aggregate(s);
          const a = i.toString().slice(s.rawInserted.length);
          a && e.aggregate(t.append(a, {
            tail: !0
          }));
        } else e.aggregate(t.append(i.toString(), {
          tail: !0
        }));
      }
      return e;
    }
    get state() {
      return {
        chunks: this.chunks.map(t => t.state),
        from: this.from,
        stop: this.stop,
        blockIndex: this.blockIndex
      };
    }
    set state(t) {
      const {
        chunks: e,
        ...s
      } = t;
      Object.assign(this, s), this.chunks = e.map(t => {
        const e = "chunks" in t ? new A() : new E();
        return e.state = t, e;
      });
    }
    unshift(t) {
      if (!this.chunks.length || null != t && this.from >= t) return "";
      const e = null != t ? t - this.from : t;
      let s = 0;
      for (; s < this.chunks.length;) {
        const t = this.chunks[s],
          i = t.unshift(e);
        if (t.toString()) {
          if (!i) break;
          ++s;
        } else this.chunks.splice(s, 1);
        if (i) return i;
      }
      return "";
    }
    shift() {
      if (!this.chunks.length) return "";
      let t = this.chunks.length - 1;
      for (; 0 <= t;) {
        const e = this.chunks[t],
          s = e.shift();
        if (e.toString()) {
          if (!s) break;
          --t;
        } else this.chunks.splice(t, 1);
        if (s) return s;
      }
      return "";
    }
  }
  class F {
    constructor(t, e) {
      this.masked = t, this._log = [];
      const {
        offset: s,
        index: i
      } = t._mapPosToBlock(e) || (e < 0 ? {
        index: 0,
        offset: 0
      } : {
        index: this.masked._blocks.length,
        offset: 0
      });
      this.offset = s, this.index = i, this.ok = !1;
    }
    get block() {
      return this.masked._blocks[this.index];
    }
    get pos() {
      return this.masked._blockStartPos(this.index) + this.offset;
    }
    get state() {
      return {
        index: this.index,
        offset: this.offset,
        ok: this.ok
      };
    }
    set state(t) {
      Object.assign(this, t);
    }
    pushState() {
      this._log.push(this.state);
    }
    popState() {
      const t = this._log.pop();
      return t && (this.state = t), t;
    }
    bindBlock() {
      this.block || (this.index < 0 && (this.index = 0, this.offset = 0), this.index >= this.masked._blocks.length && (this.index = this.masked._blocks.length - 1, this.offset = this.block.displayValue.length));
    }
    _pushLeft(t) {
      for (this.pushState(), this.bindBlock(); 0 <= this.index; --this.index, this.offset = (null == (e = this.block) ? void 0 : e.displayValue.length) || 0) {
        var e;
        if (t()) return this.ok = !0;
      }
      return this.ok = !1;
    }
    _pushRight(t) {
      for (this.pushState(), this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0) if (t()) return this.ok = !0;
      return this.ok = !1;
    }
    pushLeftBeforeFilled() {
      return this._pushLeft(() => {
        if (!this.block.isFixed && this.block.value) return this.offset = this.block.nearestInputPos(this.offset, a.FORCE_LEFT), 0 !== this.offset || void 0;
      });
    }
    pushLeftBeforeInput() {
      return this._pushLeft(() => {
        if (!this.block.isFixed) return this.offset = this.block.nearestInputPos(this.offset, a.LEFT), !0;
      });
    }
    pushLeftBeforeRequired() {
      return this._pushLeft(() => {
        if (!(this.block.isFixed || this.block.isOptional && !this.block.value)) return this.offset = this.block.nearestInputPos(this.offset, a.LEFT), !0;
      });
    }
    pushRightBeforeFilled() {
      return this._pushRight(() => {
        if (!this.block.isFixed && this.block.value) return this.offset = this.block.nearestInputPos(this.offset, a.FORCE_RIGHT), this.offset !== this.block.value.length || void 0;
      });
    }
    pushRightBeforeInput() {
      return this._pushRight(() => {
        if (!this.block.isFixed) return this.offset = this.block.nearestInputPos(this.offset, a.NONE), !0;
      });
    }
    pushRightBeforeRequired() {
      return this._pushRight(() => {
        if (!(this.block.isFixed || this.block.isOptional && !this.block.value)) return this.offset = this.block.nearestInputPos(this.offset, a.NONE), !0;
      });
    }
  }
  class x {
    constructor(t) {
      Object.assign(this, t), this._value = "", this.isFixed = !0;
    }
    get value() {
      return this._value;
    }
    get unmaskedValue() {
      return this.isUnmasking ? this.value : "";
    }
    get rawInputValue() {
      return this._isRawInput ? this.value : "";
    }
    get displayValue() {
      return this.value;
    }
    reset() {
      this._isRawInput = !1, this._value = "";
    }
    remove(t, e) {
      return void 0 === t && (t = 0), void 0 === e && (e = this._value.length), this._value = this._value.slice(0, t) + this._value.slice(e), this._value || (this._isRawInput = !1), new v();
    }
    nearestInputPos(t, e) {
      void 0 === e && (e = a.NONE);
      const s = this._value.length;
      switch (e) {
        case a.LEFT:
        case a.FORCE_LEFT:
          return 0;
        default:
          return s;
      }
    }
    totalInputPositions(t, e) {
      return void 0 === t && (t = 0), void 0 === e && (e = this._value.length), this._isRawInput ? e - t : 0;
    }
    extractInput(t, e, s) {
      return void 0 === t && (t = 0), void 0 === e && (e = this._value.length), void 0 === s && (s = {}), s.raw && this._isRawInput && this._value.slice(t, e) || "";
    }
    get isComplete() {
      return !0;
    }
    get isFilled() {
      return Boolean(this._value);
    }
    _appendChar(t, e) {
      if (void 0 === e && (e = {}), this.isFilled) return new v();
      const s = !0 === this.eager || "append" === this.eager,
        i = this.char === t && (this.isUnmasking || e.input || e.raw) && (!e.raw || !s) && !e.tail,
        a = new v({
          inserted: this.char,
          rawInserted: i ? this.char : ""
        });
      return this._value = this.char, this._isRawInput = i && (e.raw || e.input), a;
    }
    _appendEager() {
      return this._appendChar(this.char, {
        tail: !0
      });
    }
    _appendPlaceholder() {
      const t = new v();
      return this.isFilled || (this._value = t.inserted = this.char), t;
    }
    extractTail() {
      return new E("");
    }
    appendTail(t) {
      return e(t) && (t = new E(String(t))), t.appendTo(this);
    }
    append(t, e, s) {
      const i = this._appendChar(t[0], e);
      return null != s && (i.tailShift += this.appendTail(s).tailShift), i;
    }
    doCommit() {}
    get state() {
      return {
        _value: this._value,
        _rawInputValue: this.rawInputValue
      };
    }
    set state(t) {
      this._value = t._value, this._isRawInput = Boolean(t._rawInputValue);
    }
    pad(t) {
      return this._appendPlaceholder();
    }
  }
  class S {
    constructor(t) {
      const {
        parent: e,
        isOptional: s,
        placeholderChar: i,
        displayChar: a,
        lazy: u,
        eager: n,
        ...r
      } = t;
      this.masked = d(r), Object.assign(this, {
        parent: e,
        isOptional: s,
        placeholderChar: i,
        displayChar: a,
        lazy: u,
        eager: n
      });
    }
    reset() {
      this.isFilled = !1, this.masked.reset();
    }
    remove(t, e) {
      return void 0 === t && (t = 0), void 0 === e && (e = this.value.length), 0 === t && e >= 1 ? (this.isFilled = !1, this.masked.remove(t, e)) : new v();
    }
    get value() {
      return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : "");
    }
    get unmaskedValue() {
      return this.masked.unmaskedValue;
    }
    get rawInputValue() {
      return this.masked.rawInputValue;
    }
    get displayValue() {
      return this.masked.value && this.displayChar || this.value;
    }
    get isComplete() {
      return Boolean(this.masked.value) || this.isOptional;
    }
    _appendChar(t, e) {
      if (void 0 === e && (e = {}), this.isFilled) return new v();
      const s = this.masked.state;
      let i = this.masked._appendChar(t, this.currentMaskFlags(e));
      return i.inserted && !1 === this.doValidate(e) && (i = new v(), this.masked.state = s), i.inserted || this.isOptional || this.lazy || e.input || (i.inserted = this.placeholderChar), i.skip = !i.inserted && !this.isOptional, this.isFilled = Boolean(i.inserted), i;
    }
    append(t, e, s) {
      return this.masked.append(t, this.currentMaskFlags(e), s);
    }
    _appendPlaceholder() {
      return this.isFilled || this.isOptional ? new v() : (this.isFilled = !0, new v({
        inserted: this.placeholderChar
      }));
    }
    _appendEager() {
      return new v();
    }
    extractTail(t, e) {
      return this.masked.extractTail(t, e);
    }
    appendTail(t) {
      return this.masked.appendTail(t);
    }
    extractInput(t, e, s) {
      return void 0 === t && (t = 0), void 0 === e && (e = this.value.length), this.masked.extractInput(t, e, s);
    }
    nearestInputPos(t, e) {
      void 0 === e && (e = a.NONE);
      const s = this.value.length,
        i = Math.min(Math.max(t, 0), s);
      switch (e) {
        case a.LEFT:
        case a.FORCE_LEFT:
          return this.isComplete ? i : 0;
        case a.RIGHT:
        case a.FORCE_RIGHT:
          return this.isComplete ? i : s;
        default:
          return i;
      }
    }
    totalInputPositions(t, e) {
      return void 0 === t && (t = 0), void 0 === e && (e = this.value.length), this.value.slice(t, e).length;
    }
    doValidate(t) {
      return this.masked.doValidate(this.currentMaskFlags(t)) && (!this.parent || this.parent.doValidate(this.currentMaskFlags(t)));
    }
    doCommit() {
      this.masked.doCommit();
    }
    get state() {
      return {
        _value: this.value,
        _rawInputValue: this.rawInputValue,
        masked: this.masked.state,
        isFilled: this.isFilled
      };
    }
    set state(t) {
      this.masked.state = t.masked, this.isFilled = t.isFilled;
    }
    currentMaskFlags(t) {
      var e;
      return {
        ...t,
        _beforeTailState: (null == t || null == (e = t._beforeTailState) ? void 0 : e.masked) || (null == t ? void 0 : t._beforeTailState)
      };
    }
    pad(t) {
      return new v();
    }
  }
  S.DEFAULT_DEFINITIONS = {
    0: /\d/,
    a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
    "*": /./
  };
  class B extends C {
    updateOptions(t) {
      super.updateOptions(t);
    }
    _update(t) {
      const e = t.mask;
      e && (t.validate = t => t.search(e) >= 0), super._update(t);
    }
  }
  o.MaskedRegExp = B;
  class b extends C {
    constructor(t) {
      super({
        ...b.DEFAULTS,
        ...t,
        definitions: Object.assign({}, S.DEFAULT_DEFINITIONS, null == t ? void 0 : t.definitions)
      });
    }
    updateOptions(t) {
      super.updateOptions(t);
    }
    _update(t) {
      t.definitions = Object.assign({}, this.definitions, t.definitions), super._update(t), this._rebuildMask();
    }
    _rebuildMask() {
      const t = this.definitions;
      this._blocks = [], this.exposeBlock = void 0, this._stops = [], this._maskedBlocks = {};
      const e = this.mask;
      if (!e || !t) return;
      let s = !1,
        i = !1;
      for (let a = 0; a < e.length; ++a) {
        if (this.blocks) {
          const t = e.slice(a),
            s = Object.keys(this.blocks).filter(e => 0 === t.indexOf(e));
          s.sort((t, e) => e.length - t.length);
          const i = s[0];
          if (i) {
            const {
                expose: t,
                repeat: e,
                ...s
              } = p(this.blocks[i]),
              u = {
                lazy: this.lazy,
                eager: this.eager,
                placeholderChar: this.placeholderChar,
                displayChar: this.displayChar,
                overwrite: this.overwrite,
                autofix: this.autofix,
                ...s,
                repeat: e,
                parent: this
              },
              n = null != e ? new o.RepeatBlock(u) : d(u);
            n && (this._blocks.push(n), t && (this.exposeBlock = n), this._maskedBlocks[i] || (this._maskedBlocks[i] = []), this._maskedBlocks[i].push(this._blocks.length - 1)), a += i.length - 1;
            continue;
          }
        }
        let u = e[a],
          n = u in t;
        if (u === b.STOP_CHAR) {
          this._stops.push(this._blocks.length);
          continue;
        }
        if ("{" === u || "}" === u) {
          s = !s;
          continue;
        }
        if ("[" === u || "]" === u) {
          i = !i;
          continue;
        }
        if (u === b.ESCAPE_CHAR) {
          if (++a, u = e[a], !u) break;
          n = !1;
        }
        const r = n ? new S({
          isOptional: i,
          lazy: this.lazy,
          eager: this.eager,
          placeholderChar: this.placeholderChar,
          displayChar: this.displayChar,
          ...p(t[u]),
          parent: this
        }) : new x({
          char: u,
          eager: this.eager,
          isUnmasking: s
        });
        this._blocks.push(r);
      }
    }
    get state() {
      return {
        ...super.state,
        _blocks: this._blocks.map(t => t.state)
      };
    }
    set state(t) {
      if (!t) return void this.reset();
      const {
        _blocks: e,
        ...s
      } = t;
      this._blocks.forEach((t, s) => t.state = e[s]), super.state = s;
    }
    reset() {
      super.reset(), this._blocks.forEach(t => t.reset());
    }
    get isComplete() {
      return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every(t => t.isComplete);
    }
    get isFilled() {
      return this._blocks.every(t => t.isFilled);
    }
    get isFixed() {
      return this._blocks.every(t => t.isFixed);
    }
    get isOptional() {
      return this._blocks.every(t => t.isOptional);
    }
    doCommit() {
      this._blocks.forEach(t => t.doCommit()), super.doCommit();
    }
    get unmaskedValue() {
      return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce((t, e) => t + e.unmaskedValue, "");
    }
    set unmaskedValue(t) {
      if (this.exposeBlock) {
        const e = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
        this.exposeBlock.unmaskedValue = t, this.appendTail(e), this.doCommit();
      } else super.unmaskedValue = t;
    }
    get value() {
      return this.exposeBlock ? this.exposeBlock.value : this._blocks.reduce((t, e) => t + e.value, "");
    }
    set value(t) {
      if (this.exposeBlock) {
        const e = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
        this.exposeBlock.value = t, this.appendTail(e), this.doCommit();
      } else super.value = t;
    }
    get typedValue() {
      return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;
    }
    set typedValue(t) {
      if (this.exposeBlock) {
        const e = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
        this.exposeBlock.typedValue = t, this.appendTail(e), this.doCommit();
      } else super.typedValue = t;
    }
    get displayValue() {
      return this._blocks.reduce((t, e) => t + e.displayValue, "");
    }
    appendTail(t) {
      return super.appendTail(t).aggregate(this._appendPlaceholder());
    }
    _appendEager() {
      var t;
      const e = new v();
      let s = null == (t = this._mapPosToBlock(this.displayValue.length)) ? void 0 : t.index;
      if (null == s) return e;
      this._blocks[s].isFilled && ++s;
      for (let t = s; t < this._blocks.length; ++t) {
        const s = this._blocks[t]._appendEager();
        if (!s.inserted) break;
        e.aggregate(s);
      }
      return e;
    }
    _appendCharRaw(t, e) {
      void 0 === e && (e = {});
      const s = this._mapPosToBlock(this.displayValue.length),
        i = new v();
      if (!s) return i;
      for (let u, n = s.index; u = this._blocks[n]; ++n) {
        var a;
        const s = u._appendChar(t, {
          ...e,
          _beforeTailState: null == (a = e._beforeTailState) || null == (a = a._blocks) ? void 0 : a[n]
        });
        if (i.aggregate(s), s.consumed) break;
      }
      return i;
    }
    extractTail(t, e) {
      void 0 === t && (t = 0), void 0 === e && (e = this.displayValue.length);
      const s = new A();
      return t === e || this._forEachBlocksInRange(t, e, (t, e, i, a) => {
        const u = t.extractTail(i, a);
        u.stop = this._findStopBefore(e), u.from = this._blockStartPos(e), u instanceof A && (u.blockIndex = e), s.extend(u);
      }), s;
    }
    extractInput(t, e, s) {
      if (void 0 === t && (t = 0), void 0 === e && (e = this.displayValue.length), void 0 === s && (s = {}), t === e) return "";
      let i = "";
      return this._forEachBlocksInRange(t, e, (t, e, a, u) => {
        i += t.extractInput(a, u, s);
      }), i;
    }
    _findStopBefore(t) {
      let e;
      for (let s = 0; s < this._stops.length; ++s) {
        const i = this._stops[s];
        if (!(i <= t)) break;
        e = i;
      }
      return e;
    }
    _appendPlaceholder(t) {
      const e = new v();
      if (this.lazy && null == t) return e;
      const s = this._mapPosToBlock(this.displayValue.length);
      if (!s) return e;
      const i = s.index,
        a = null != t ? t : this._blocks.length;
      return this._blocks.slice(i, a).forEach(s => {
        var i;
        s.lazy && null == t || e.aggregate(s._appendPlaceholder(null == (i = s._blocks) ? void 0 : i.length));
      }), e;
    }
    _mapPosToBlock(t) {
      let e = "";
      for (let s = 0; s < this._blocks.length; ++s) {
        const i = this._blocks[s],
          a = e.length;
        if (e += i.displayValue, t <= e.length) return {
          index: s,
          offset: t - a
        };
      }
    }
    _blockStartPos(t) {
      return this._blocks.slice(0, t).reduce((t, e) => t + e.displayValue.length, 0);
    }
    _forEachBlocksInRange(t, e, s) {
      void 0 === e && (e = this.displayValue.length);
      const i = this._mapPosToBlock(t);
      if (i) {
        const t = this._mapPosToBlock(e),
          a = t && i.index === t.index,
          u = i.offset,
          n = t && a ? t.offset : this._blocks[i.index].displayValue.length;
        if (s(this._blocks[i.index], i.index, u, n), t && !a) {
          for (let e = i.index + 1; e < t.index; ++e) s(this._blocks[e], e, 0, this._blocks[e].displayValue.length);
          s(this._blocks[t.index], t.index, 0, t.offset);
        }
      }
    }
    remove(t, e) {
      void 0 === t && (t = 0), void 0 === e && (e = this.displayValue.length);
      const s = super.remove(t, e);
      return this._forEachBlocksInRange(t, e, (t, e, i, a) => {
        s.aggregate(t.remove(i, a));
      }), s;
    }
    nearestInputPos(t, e) {
      if (void 0 === e && (e = a.NONE), !this._blocks.length) return 0;
      const s = new F(this, t);
      if (e === a.NONE) return s.pushRightBeforeInput() ? s.pos : (s.popState(), s.pushLeftBeforeInput() ? s.pos : this.displayValue.length);
      if (e === a.LEFT || e === a.FORCE_LEFT) {
        if (e === a.LEFT) {
          if (s.pushRightBeforeFilled(), s.ok && s.pos === t) return t;
          s.popState();
        }
        if (s.pushLeftBeforeInput(), s.pushLeftBeforeRequired(), s.pushLeftBeforeFilled(), e === a.LEFT) {
          if (s.pushRightBeforeInput(), s.pushRightBeforeRequired(), s.ok && s.pos <= t) return s.pos;
          if (s.popState(), s.ok && s.pos <= t) return s.pos;
          s.popState();
        }
        return s.ok ? s.pos : e === a.FORCE_LEFT ? 0 : (s.popState(), s.ok ? s.pos : (s.popState(), s.ok ? s.pos : 0));
      }
      return e === a.RIGHT || e === a.FORCE_RIGHT ? (s.pushRightBeforeInput(), s.pushRightBeforeRequired(), s.pushRightBeforeFilled() ? s.pos : e === a.FORCE_RIGHT ? this.displayValue.length : (s.popState(), s.ok ? s.pos : (s.popState(), s.ok ? s.pos : this.nearestInputPos(t, a.LEFT)))) : t;
    }
    totalInputPositions(t, e) {
      void 0 === t && (t = 0), void 0 === e && (e = this.displayValue.length);
      let s = 0;
      return this._forEachBlocksInRange(t, e, (t, e, i, a) => {
        s += t.totalInputPositions(i, a);
      }), s;
    }
    maskedBlock(t) {
      return this.maskedBlocks(t)[0];
    }
    maskedBlocks(t) {
      const e = this._maskedBlocks[t];
      return e ? e.map(t => this._blocks[t]) : [];
    }
    pad(t) {
      const e = new v();
      return this._forEachBlocksInRange(0, this.displayValue.length, s => e.aggregate(s.pad(t))), e;
    }
  }
  b.DEFAULTS = {
    ...C.DEFAULTS,
    lazy: !0,
    placeholderChar: "_"
  }, b.STOP_CHAR = "`", b.ESCAPE_CHAR = "\\", b.InputDefinition = S, b.FixedDefinition = x, o.MaskedPattern = b;
  class D extends b {
    get _matchFrom() {
      return this.maxLength - String(this.from).length;
    }
    constructor(t) {
      super(t);
    }
    updateOptions(t) {
      super.updateOptions(t);
    }
    _update(t) {
      const {
        to: e = this.to || 0,
        from: s = this.from || 0,
        maxLength: i = this.maxLength || 0,
        autofix: a = this.autofix,
        ...u
      } = t;
      this.to = e, this.from = s, this.maxLength = Math.max(String(e).length, i), this.autofix = a;
      const n = String(this.from).padStart(this.maxLength, "0"),
        r = String(this.to).padStart(this.maxLength, "0");
      let h = 0;
      for (; h < r.length && r[h] === n[h];) ++h;
      u.mask = r.slice(0, h).replace(/0/g, "\\0") + "0".repeat(this.maxLength - h), super._update(u);
    }
    get isComplete() {
      return super.isComplete && Boolean(this.value);
    }
    boundaries(t) {
      let e = "",
        s = "";
      const [, i, a] = t.match(/^(\D*)(\d*)(\D*)/) || [];
      return a && (e = "0".repeat(i.length) + a, s = "9".repeat(i.length) + a), e = e.padEnd(this.maxLength, "0"), s = s.padEnd(this.maxLength, "9"), [e, s];
    }
    doPrepareChar(t, e) {
      let s;
      return void 0 === e && (e = {}), [t, s] = super.doPrepareChar(t.replace(/\D/g, ""), e), t || (s.skip = !this.isComplete), [t, s];
    }
    _appendCharRaw(t, e) {
      if (void 0 === e && (e = {}), !this.autofix || this.value.length + 1 > this.maxLength) return super._appendCharRaw(t, e);
      const s = String(this.from).padStart(this.maxLength, "0"),
        i = String(this.to).padStart(this.maxLength, "0"),
        [a, u] = this.boundaries(this.value + t);
      return Number(u) < this.from ? super._appendCharRaw(s[this.value.length], e) : Number(a) > this.to ? !e.tail && "pad" === this.autofix && this.value.length + 1 < this.maxLength ? super._appendCharRaw(s[this.value.length], e).aggregate(this._appendCharRaw(t, e)) : super._appendCharRaw(i[this.value.length], e) : super._appendCharRaw(t, e);
    }
    doValidate(t) {
      const e = this.value;
      if (-1 === e.search(/[^0]/) && e.length <= this._matchFrom) return !0;
      const [s, i] = this.boundaries(e);
      return this.from <= Number(i) && Number(s) <= this.to && super.doValidate(t);
    }
    pad(t) {
      const e = new v();
      if (this.value.length === this.maxLength) return e;
      const s = this.value,
        i = this.maxLength - this.value.length;
      if (i) {
        this.reset();
        for (let s = 0; s < i; ++s) e.aggregate(super._appendCharRaw("0", t));
        s.split("").forEach(t => this._appendCharRaw(t));
      }
      return e;
    }
  }
  o.MaskedRange = D;
  class y extends b {
    static extractPatternOptions(t) {
      const {
        mask: s,
        pattern: i,
        ...a
      } = t;
      return {
        ...a,
        mask: e(s) ? s : i
      };
    }
    constructor(t) {
      super(y.extractPatternOptions({
        ...y.DEFAULTS,
        ...t
      }));
    }
    updateOptions(t) {
      super.updateOptions(t);
    }
    _update(t) {
      const {
          mask: s,
          pattern: i,
          blocks: a,
          ...u
        } = {
          ...y.DEFAULTS,
          ...t
        },
        n = Object.assign({}, y.GET_DEFAULT_BLOCKS());
      t.min && (n.Y.from = t.min.getFullYear()), t.max && (n.Y.to = t.max.getFullYear()), t.min && t.max && n.Y.from === n.Y.to && (n.m.from = t.min.getMonth() + 1, n.m.to = t.max.getMonth() + 1, n.m.from === n.m.to && (n.d.from = t.min.getDate(), n.d.to = t.max.getDate())), Object.assign(n, this.blocks, a), super._update({
        ...u,
        mask: e(s) ? s : i,
        blocks: n
      });
    }
    doValidate(t) {
      const e = this.date;
      return super.doValidate(t) && (!this.isComplete || this.isDateExist(this.value) && null != e && (null == this.min || this.min <= e) && (null == this.max || e <= this.max));
    }
    isDateExist(t) {
      return this.format(this.parse(t, this), this).indexOf(t) >= 0;
    }
    get date() {
      return this.typedValue;
    }
    set date(t) {
      this.typedValue = t;
    }
    get typedValue() {
      return this.isComplete ? super.typedValue : null;
    }
    set typedValue(t) {
      super.typedValue = t;
    }
    maskEquals(t) {
      return t === Date || super.maskEquals(t);
    }
    optionsIsChanged(t) {
      return super.optionsIsChanged(y.extractPatternOptions(t));
    }
  }
  y.GET_DEFAULT_BLOCKS = () => ({
    d: {
      mask: D,
      from: 1,
      to: 31,
      maxLength: 2
    },
    m: {
      mask: D,
      from: 1,
      to: 12,
      maxLength: 2
    },
    Y: {
      mask: D,
      from: 1900,
      to: 9999
    }
  }), y.DEFAULTS = {
    ...b.DEFAULTS,
    mask: Date,
    pattern: "d{.}`m{.}`Y",
    format: (t, e) => {
      if (!t) return "";
      return [String(t.getDate()).padStart(2, "0"), String(t.getMonth() + 1).padStart(2, "0"), t.getFullYear()].join(".");
    },
    parse: (t, e) => {
      const [s, i, a] = t.split(".").map(Number);
      return new Date(a, i - 1, s);
    }
  }, o.MaskedDate = y;
  class M extends C {
    constructor(t) {
      super({
        ...M.DEFAULTS,
        ...t
      }), this.currentMask = void 0;
    }
    updateOptions(t) {
      super.updateOptions(t);
    }
    _update(t) {
      super._update(t), "mask" in t && (this.exposeMask = void 0, this.compiledMasks = Array.isArray(t.mask) ? t.mask.map(t => {
        const {
            expose: e,
            ...s
          } = p(t),
          i = d({
            overwrite: this._overwrite,
            eager: this._eager,
            skipInvalid: this._skipInvalid,
            ...s
          });
        return e && (this.exposeMask = i), i;
      }) : []);
    }
    _appendCharRaw(t, e) {
      void 0 === e && (e = {});
      const s = this._applyDispatch(t, e);
      return this.currentMask && s.aggregate(this.currentMask._appendChar(t, this.currentMaskFlags(e))), s;
    }
    _applyDispatch(t, e, s) {
      void 0 === t && (t = ""), void 0 === e && (e = {}), void 0 === s && (s = "");
      const i = e.tail && null != e._beforeTailState ? e._beforeTailState._value : this.value,
        a = this.rawInputValue,
        u = e.tail && null != e._beforeTailState ? e._beforeTailState._rawInputValue : a,
        n = a.slice(u.length),
        r = this.currentMask,
        h = new v(),
        o = null == r ? void 0 : r.state;
      return this.currentMask = this.doDispatch(t, {
        ...e
      }, s), this.currentMask && (this.currentMask !== r ? (this.currentMask.reset(), u && (this.currentMask.append(u, {
        raw: !0
      }), h.tailShift = this.currentMask.value.length - i.length), n && (h.tailShift += this.currentMask.append(n, {
        raw: !0,
        tail: !0
      }).tailShift)) : o && (this.currentMask.state = o)), h;
    }
    _appendPlaceholder() {
      const t = this._applyDispatch();
      return this.currentMask && t.aggregate(this.currentMask._appendPlaceholder()), t;
    }
    _appendEager() {
      const t = this._applyDispatch();
      return this.currentMask && t.aggregate(this.currentMask._appendEager()), t;
    }
    appendTail(t) {
      const e = new v();
      return t && e.aggregate(this._applyDispatch("", {}, t)), e.aggregate(this.currentMask ? this.currentMask.appendTail(t) : super.appendTail(t));
    }
    currentMaskFlags(t) {
      var e, s;
      return {
        ...t,
        _beforeTailState: (null == (e = t._beforeTailState) ? void 0 : e.currentMaskRef) === this.currentMask && (null == (s = t._beforeTailState) ? void 0 : s.currentMask) || t._beforeTailState
      };
    }
    doDispatch(t, e, s) {
      return void 0 === e && (e = {}), void 0 === s && (s = ""), this.dispatch(t, this, e, s);
    }
    doValidate(t) {
      return super.doValidate(t) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(t)));
    }
    doPrepare(t, e) {
      void 0 === e && (e = {});
      let [s, i] = super.doPrepare(t, e);
      if (this.currentMask) {
        let t;
        [s, t] = super.doPrepare(s, this.currentMaskFlags(e)), i = i.aggregate(t);
      }
      return [s, i];
    }
    doPrepareChar(t, e) {
      void 0 === e && (e = {});
      let [s, i] = super.doPrepareChar(t, e);
      if (this.currentMask) {
        let t;
        [s, t] = super.doPrepareChar(s, this.currentMaskFlags(e)), i = i.aggregate(t);
      }
      return [s, i];
    }
    reset() {
      var t;
      null == (t = this.currentMask) || t.reset(), this.compiledMasks.forEach(t => t.reset());
    }
    get value() {
      return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : "";
    }
    set value(t) {
      this.exposeMask ? (this.exposeMask.value = t, this.currentMask = this.exposeMask, this._applyDispatch()) : super.value = t;
    }
    get unmaskedValue() {
      return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : "";
    }
    set unmaskedValue(t) {
      this.exposeMask ? (this.exposeMask.unmaskedValue = t, this.currentMask = this.exposeMask, this._applyDispatch()) : super.unmaskedValue = t;
    }
    get typedValue() {
      return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : "";
    }
    set typedValue(t) {
      if (this.exposeMask) return this.exposeMask.typedValue = t, this.currentMask = this.exposeMask, void this._applyDispatch();
      let e = String(t);
      this.currentMask && (this.currentMask.typedValue = t, e = this.currentMask.unmaskedValue), this.unmaskedValue = e;
    }
    get displayValue() {
      return this.currentMask ? this.currentMask.displayValue : "";
    }
    get isComplete() {
      var t;
      return Boolean(null == (t = this.currentMask) ? void 0 : t.isComplete);
    }
    get isFilled() {
      var t;
      return Boolean(null == (t = this.currentMask) ? void 0 : t.isFilled);
    }
    remove(t, e) {
      const s = new v();
      return this.currentMask && s.aggregate(this.currentMask.remove(t, e)).aggregate(this._applyDispatch()), s;
    }
    get state() {
      var t;
      return {
        ...super.state,
        _rawInputValue: this.rawInputValue,
        compiledMasks: this.compiledMasks.map(t => t.state),
        currentMaskRef: this.currentMask,
        currentMask: null == (t = this.currentMask) ? void 0 : t.state
      };
    }
    set state(t) {
      const {
        compiledMasks: e,
        currentMaskRef: s,
        currentMask: i,
        ...a
      } = t;
      e && this.compiledMasks.forEach((t, s) => t.state = e[s]), null != s && (this.currentMask = s, this.currentMask.state = i), super.state = a;
    }
    extractInput(t, e, s) {
      return this.currentMask ? this.currentMask.extractInput(t, e, s) : "";
    }
    extractTail(t, e) {
      return this.currentMask ? this.currentMask.extractTail(t, e) : super.extractTail(t, e);
    }
    doCommit() {
      this.currentMask && this.currentMask.doCommit(), super.doCommit();
    }
    nearestInputPos(t, e) {
      return this.currentMask ? this.currentMask.nearestInputPos(t, e) : super.nearestInputPos(t, e);
    }
    get overwrite() {
      return this.currentMask ? this.currentMask.overwrite : this._overwrite;
    }
    set overwrite(t) {
      this._overwrite = t;
    }
    get eager() {
      return this.currentMask ? this.currentMask.eager : this._eager;
    }
    set eager(t) {
      this._eager = t;
    }
    get skipInvalid() {
      return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;
    }
    set skipInvalid(t) {
      this._skipInvalid = t;
    }
    get autofix() {
      return this.currentMask ? this.currentMask.autofix : this._autofix;
    }
    set autofix(t) {
      this._autofix = t;
    }
    maskEquals(t) {
      return Array.isArray(t) ? this.compiledMasks.every((e, s) => {
        if (!t[s]) return;
        const {
          mask: i,
          ...a
        } = t[s];
        return r(e, a) && e.maskEquals(i);
      }) : super.maskEquals(t);
    }
    typedValueEquals(t) {
      var e;
      return Boolean(null == (e = this.currentMask) ? void 0 : e.typedValueEquals(t));
    }
  }
  M.DEFAULTS = {
    ...C.DEFAULTS,
    dispatch: (t, e, s, i) => {
      if (!e.compiledMasks.length) return;
      const u = e.rawInputValue,
        n = e.compiledMasks.map((n, r) => {
          const h = e.currentMask === n,
            o = h ? n.displayValue.length : n.nearestInputPos(n.displayValue.length, a.FORCE_LEFT);
          return n.rawInputValue !== u ? (n.reset(), n.append(u, {
            raw: !0
          })) : h || n.remove(o), n.append(t, e.currentMaskFlags(s)), n.appendTail(i), {
            index: r,
            weight: n.rawInputValue.length,
            totalInputPositions: n.totalInputPositions(0, Math.max(o, n.nearestInputPos(n.displayValue.length, a.FORCE_LEFT)))
          };
        });
      return n.sort((t, e) => e.weight - t.weight || e.totalInputPositions - t.totalInputPositions), e.compiledMasks[n[0].index];
    }
  }, o.MaskedDynamic = M;
  class I extends b {
    constructor(t) {
      super({
        ...I.DEFAULTS,
        ...t
      });
    }
    updateOptions(t) {
      super.updateOptions(t);
    }
    _update(t) {
      const {
        enum: e,
        ...s
      } = t;
      if (e) {
        const t = e.map(t => t.length),
          i = Math.min(...t),
          a = Math.max(...t) - i;
        s.mask = "*".repeat(i), a && (s.mask += "[" + "*".repeat(a) + "]"), this.enum = e;
      }
      super._update(s);
    }
    _appendCharRaw(t, e) {
      void 0 === e && (e = {});
      const s = Math.min(this.nearestInputPos(0, a.FORCE_RIGHT), this.value.length),
        i = this.enum.filter(e => this.matchValue(e, this.unmaskedValue + t, s));
      if (i.length) {
        1 === i.length && this._forEachBlocksInRange(0, this.value.length, (t, s) => {
          const a = i[0][s];
          s >= this.value.length || a === t.value || (t.reset(), t._appendChar(a, e));
        });
        const t = super._appendCharRaw(i[0][this.value.length], e);
        return 1 === i.length && i[0].slice(this.unmaskedValue.length).split("").forEach(e => t.aggregate(super._appendCharRaw(e))), t;
      }
      return new v({
        skip: !this.isComplete
      });
    }
    extractTail(t, e) {
      return void 0 === t && (t = 0), void 0 === e && (e = this.displayValue.length), new E("", t);
    }
    remove(t, e) {
      if (void 0 === t && (t = 0), void 0 === e && (e = this.displayValue.length), t === e) return new v();
      const s = Math.min(super.nearestInputPos(0, a.FORCE_RIGHT), this.value.length);
      let i;
      for (i = t; i >= 0; --i) {
        if (this.enum.filter(t => this.matchValue(t, this.value.slice(s, i), s)).length > 1) break;
      }
      const u = super.remove(i, e);
      return u.tailShift += i - t, u;
    }
    get isComplete() {
      return this.enum.indexOf(this.value) >= 0;
    }
  }
  I.DEFAULTS = {
    ...b.DEFAULTS,
    matchValue: (t, e, s) => t.indexOf(e, s) === s
  }, o.MaskedEnum = I;
  class V extends C {
    updateOptions(t) {
      super.updateOptions(t);
    }
    _update(t) {
      super._update({
        ...t,
        validate: t.mask
      });
    }
  }
  var T;
  o.MaskedFunction = V;
  class w extends C {
    constructor(t) {
      super({
        ...w.DEFAULTS,
        ...t
      });
    }
    updateOptions(t) {
      super.updateOptions(t);
    }
    _update(t) {
      super._update(t), this._updateRegExps();
    }
    _updateRegExps() {
      const t = "^" + (this.allowNegative ? "[+|\\-]?" : ""),
        e = (this.scale ? "(" + n(this.radix) + "\\d{0," + this.scale + "})?" : "") + "$";
      this._numberRegExp = new RegExp(t + "\\d*" + e), this._mapToRadixRegExp = new RegExp("[" + this.mapToRadix.map(n).join("") + "]", "g"), this._thousandsSeparatorRegExp = new RegExp(n(this.thousandsSeparator), "g");
    }
    _removeThousandsSeparators(t) {
      return t.replace(this._thousandsSeparatorRegExp, "");
    }
    _insertThousandsSeparators(t) {
      const e = t.split(this.radix);
      return e[0] = e[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator), e.join(this.radix);
    }
    doPrepareChar(t, e) {
      void 0 === e && (e = {});
      const [s, i] = super.doPrepareChar(this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (e.input && e.raw || !e.input && !e.raw) ? t.replace(this._mapToRadixRegExp, this.radix) : t), e);
      return t && !s && (i.skip = !0), !s || this.allowPositive || this.value || "-" === s || i.aggregate(this._appendChar("-")), [s, i];
    }
    _separatorsCount(t, e) {
      void 0 === e && (e = !1);
      let s = 0;
      for (let i = 0; i < t; ++i) this._value.indexOf(this.thousandsSeparator, i) === i && (++s, e && (t += this.thousandsSeparator.length));
      return s;
    }
    _separatorsCountFromSlice(t) {
      return void 0 === t && (t = this._value), this._separatorsCount(this._removeThousandsSeparators(t).length, !0);
    }
    extractInput(t, e, s) {
      return void 0 === t && (t = 0), void 0 === e && (e = this.displayValue.length), [t, e] = this._adjustRangeWithSeparators(t, e), this._removeThousandsSeparators(super.extractInput(t, e, s));
    }
    _appendCharRaw(t, e) {
      void 0 === e && (e = {});
      const s = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value,
        i = this._separatorsCountFromSlice(s);
      this._value = this._removeThousandsSeparators(this.value);
      const a = this._value;
      this._value += t;
      const u = this.number;
      let n,
        r = !isNaN(u),
        h = !1;
      if (r) {
        let t;
        null != this.min && this.min < 0 && this.number < this.min && (t = this.min), null != this.max && this.max > 0 && this.number > this.max && (t = this.max), null != t && (this.autofix ? (this._value = this.format(t, this).replace(w.UNMASKED_RADIX, this.radix), h || (h = a === this._value && !e.tail)) : r = !1), r && (r = Boolean(this._value.match(this._numberRegExp)));
      }
      r ? n = new v({
        inserted: this._value.slice(a.length),
        rawInserted: h ? "" : t,
        skip: h
      }) : (this._value = a, n = new v()), this._value = this._insertThousandsSeparators(this._value);
      const o = e.tail && e._beforeTailState ? e._beforeTailState._value : this._value,
        l = this._separatorsCountFromSlice(o);
      return n.tailShift += (l - i) * this.thousandsSeparator.length, n;
    }
    _findSeparatorAround(t) {
      if (this.thousandsSeparator) {
        const e = t - this.thousandsSeparator.length + 1,
          s = this.value.indexOf(this.thousandsSeparator, e);
        if (s <= t) return s;
      }
      return -1;
    }
    _adjustRangeWithSeparators(t, e) {
      const s = this._findSeparatorAround(t);
      s >= 0 && (t = s);
      const i = this._findSeparatorAround(e);
      return i >= 0 && (e = i + this.thousandsSeparator.length), [t, e];
    }
    remove(t, e) {
      void 0 === t && (t = 0), void 0 === e && (e = this.displayValue.length), [t, e] = this._adjustRangeWithSeparators(t, e);
      const s = this.value.slice(0, t),
        i = this.value.slice(e),
        a = this._separatorsCount(s.length);
      this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(s + i));
      const u = this._separatorsCountFromSlice(s);
      return new v({
        tailShift: (u - a) * this.thousandsSeparator.length
      });
    }
    nearestInputPos(t, e) {
      if (!this.thousandsSeparator) return t;
      switch (e) {
        case a.NONE:
        case a.LEFT:
        case a.FORCE_LEFT:
          {
            const s = this._findSeparatorAround(t - 1);
            if (s >= 0) {
              const i = s + this.thousandsSeparator.length;
              if (t < i || this.value.length <= i || e === a.FORCE_LEFT) return s;
            }
            break;
          }
        case a.RIGHT:
        case a.FORCE_RIGHT:
          {
            const e = this._findSeparatorAround(t);
            if (e >= 0) return e + this.thousandsSeparator.length;
          }
      }
      return t;
    }
    doCommit() {
      if (this.value) {
        const t = this.number;
        let e = t;
        null != this.min && (e = Math.max(e, this.min)), null != this.max && (e = Math.min(e, this.max)), e !== t && (this.unmaskedValue = this.format(e, this));
        let s = this.value;
        this.normalizeZeros && (s = this._normalizeZeros(s)), this.padFractionalZeros && this.scale > 0 && (s = this._padFractionalZeros(s)), this._value = s;
      }
      super.doCommit();
    }
    _normalizeZeros(t) {
      const e = this._removeThousandsSeparators(t).split(this.radix);
      return e[0] = e[0].replace(/^(\D*)(0*)(\d*)/, (t, e, s, i) => e + i), t.length && !/\d$/.test(e[0]) && (e[0] = e[0] + "0"), e.length > 1 && (e[1] = e[1].replace(/0*$/, ""), e[1].length || (e.length = 1)), this._insertThousandsSeparators(e.join(this.radix));
    }
    _padFractionalZeros(t) {
      if (!t) return t;
      const e = t.split(this.radix);
      return e.length < 2 && e.push(""), e[1] = e[1].padEnd(this.scale, "0"), e.join(this.radix);
    }
    doSkipInvalid(t, e, s) {
      void 0 === e && (e = {});
      const i = 0 === this.scale && t !== this.thousandsSeparator && (t === this.radix || t === w.UNMASKED_RADIX || this.mapToRadix.includes(t));
      return super.doSkipInvalid(t, e, s) && !i;
    }
    get unmaskedValue() {
      return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, w.UNMASKED_RADIX);
    }
    set unmaskedValue(t) {
      super.unmaskedValue = t;
    }
    get typedValue() {
      return this.parse(this.unmaskedValue, this);
    }
    set typedValue(t) {
      this.rawInputValue = this.format(t, this).replace(w.UNMASKED_RADIX, this.radix);
    }
    get number() {
      return this.typedValue;
    }
    set number(t) {
      this.typedValue = t;
    }
    get allowNegative() {
      return null != this.min && this.min < 0 || null != this.max && this.max < 0;
    }
    get allowPositive() {
      return null != this.min && this.min > 0 || null != this.max && this.max > 0;
    }
    typedValueEquals(t) {
      return (super.typedValueEquals(t) || w.EMPTY_VALUES.includes(t) && w.EMPTY_VALUES.includes(this.typedValue)) && !(0 === t && "" === this.value);
    }
  }
  T = w, w.UNMASKED_RADIX = ".", w.EMPTY_VALUES = [...C.EMPTY_VALUES, 0], w.DEFAULTS = {
    ...C.DEFAULTS,
    mask: Number,
    radix: ",",
    thousandsSeparator: "",
    mapToRadix: [T.UNMASKED_RADIX],
    min: Number.MIN_SAFE_INTEGER,
    max: Number.MAX_SAFE_INTEGER,
    scale: 2,
    normalizeZeros: !0,
    padFractionalZeros: !1,
    parse: Number,
    format: t => t.toLocaleString("en-US", {
      useGrouping: !1,
      maximumFractionDigits: 20
    })
  }, o.MaskedNumber = w;
  const R = {
    MASKED: "value",
    UNMASKED: "unmaskedValue",
    TYPED: "typedValue"
  };
  function P(t, e, s) {
    void 0 === e && (e = R.MASKED), void 0 === s && (s = R.MASKED);
    const i = d(t);
    return t => i.runIsolated(i => (i[e] = t, i[s]));
  }
  function O(t, e, s, i) {
    return P(e, s, i)(t);
  }
  o.PIPE_TYPE = R, o.createPipe = P, o.pipe = O;
  class L extends b {
    get repeatFrom() {
      var t;
      return null != (t = Array.isArray(this.repeat) ? this.repeat[0] : this.repeat === 1 / 0 ? 0 : this.repeat) ? t : 0;
    }
    get repeatTo() {
      var t;
      return null != (t = Array.isArray(this.repeat) ? this.repeat[1] : this.repeat) ? t : 1 / 0;
    }
    constructor(t) {
      super(t);
    }
    updateOptions(t) {
      super.updateOptions(t);
    }
    _update(t) {
      var e, s, i;
      const {
        repeat: a,
        ...u
      } = p(t);
      this._blockOpts = Object.assign({}, this._blockOpts, u);
      const n = d(this._blockOpts);
      this.repeat = null != (e = null != (s = null != a ? a : n.repeat) ? s : this.repeat) ? e : 1 / 0, super._update({
        mask: "m".repeat(Math.max(this.repeatTo === 1 / 0 && (null == (i = this._blocks) ? void 0 : i.length) || 0, this.repeatFrom)),
        blocks: {
          m: n
        },
        eager: n.eager,
        overwrite: n.overwrite,
        skipInvalid: n.skipInvalid,
        lazy: n.lazy,
        placeholderChar: n.placeholderChar,
        displayChar: n.displayChar
      });
    }
    _allocateBlock(t) {
      return t < this._blocks.length ? this._blocks[t] : this.repeatTo === 1 / 0 || this._blocks.length < this.repeatTo ? (this._blocks.push(d(this._blockOpts)), this.mask += "m", this._blocks[this._blocks.length - 1]) : void 0;
    }
    _appendCharRaw(t, e) {
      void 0 === e && (e = {});
      const s = new v();
      for (let r, h, o = null != (i = null == (a = this._mapPosToBlock(this.displayValue.length)) ? void 0 : a.index) ? i : Math.max(this._blocks.length - 1, 0); r = null != (u = this._blocks[o]) ? u : h = !h && this._allocateBlock(o); ++o) {
        var i, a, u, n;
        const l = r._appendChar(t, {
          ...e,
          _beforeTailState: null == (n = e._beforeTailState) || null == (n = n._blocks) ? void 0 : n[o]
        });
        if (l.skip && h) {
          this._blocks.pop(), this.mask = this.mask.slice(1);
          break;
        }
        if (s.aggregate(l), l.consumed) break;
      }
      return s;
    }
    _trimEmptyTail(t, e) {
      var s, i;
      void 0 === t && (t = 0);
      const a = Math.max((null == (s = this._mapPosToBlock(t)) ? void 0 : s.index) || 0, this.repeatFrom, 0);
      let u;
      null != e && (u = null == (i = this._mapPosToBlock(e)) ? void 0 : i.index), null == u && (u = this._blocks.length - 1);
      let n = 0;
      for (let t = u; a <= t && !this._blocks[t].unmaskedValue; --t, ++n);
      n && (this._blocks.splice(u - n + 1, n), this.mask = this.mask.slice(n));
    }
    reset() {
      super.reset(), this._trimEmptyTail();
    }
    remove(t, e) {
      void 0 === t && (t = 0), void 0 === e && (e = this.displayValue.length);
      const s = super.remove(t, e);
      return this._trimEmptyTail(t, e), s;
    }
    totalInputPositions(t, e) {
      return void 0 === t && (t = 0), null == e && this.repeatTo === 1 / 0 ? 1 / 0 : super.totalInputPositions(t, e);
    }
    get state() {
      return super.state;
    }
    set state(t) {
      this._blocks.length = t._blocks.length, this.mask = this.mask.slice(0, this._blocks.length), super.state = t;
    }
  }
  o.RepeatBlock = L;
  try {
    globalThis.IMask = o;
  } catch {}
  t.ChangeDetails = v, t.ChunksTailDetails = A, t.DIRECTION = a, t.HTMLContenteditableMaskElement = m, t.HTMLInputMaskElement = k, t.HTMLMaskElement = g, t.InputMask = f, t.MaskElement = c, t.Masked = C, t.MaskedDate = y, t.MaskedDynamic = M, t.MaskedEnum = I, t.MaskedFunction = V, t.MaskedNumber = w, t.MaskedPattern = b, t.MaskedRange = D, t.MaskedRegExp = B, t.PIPE_TYPE = R, t.PatternFixedDefinition = x, t.PatternInputDefinition = S, t.RepeatBlock = L, t.createMask = d, t.createPipe = P, t.default = o, t.forceDirection = u, t.normalizeOpts = p, t.pipe = O, Object.defineProperty(t, "__esModule", {
    value: !0
  });
});
(function () {
  //const agreementElems = document.querySelectorAll('.contacts__agreement');
  const agreementElems = document.querySelectorAll('[class$="__agreement"]');
  for (let i = 0; i < agreementElems.length; i++) {
    let agreementElem = agreementElems[i];
    //const submitBtn = agreementElem.querySelector('.contacts__submit');
    const submitBtn = agreementElem.querySelector('button[type=submit]');
    const agreementCheckbox = agreementElem.querySelector('input[name=agreement]');
    if (agreementCheckbox) {
      agreementCheckbox.addEventListener('change', function (e) {
        if (!e.target.checked) {
          submitBtn.disabled = true;
        } else {
          submitBtn.disabled = false;
        }
      });
    }
  }
})();
(function () {
  //if (!autosize()) return;
  autosize(document.querySelectorAll('textarea'));
})();
(function () {
  // Добавление/удаление модификаторов при клике на переключение видимости
  // const toggler = document.getElementById('menu-toggler');
  // if(toggler){
  //   toggler.addEventListener('click', mainNavVisibleToggle);

  //   function mainNavVisibleToggle(e) {
  //     e.preventDefault();
  //     toggler.classList.toggle('burger--close'); // модификатор иконки (должен быть .burger)
  //     //document.getElementById('main-nav').classList.toggle('main-nav--open');
  //   }
  // }

  // Добавление/удаление модификаторов при фокусировке на ссылочном элементе
  const linkClassName = 'main-nav__link';
  const linkClassNameShowChild = 'main-nav__item--show-child';
  const findLinkClassName = new RegExp(linkClassName);
  // Слежение за всплывшим событием focus (нужно добавить класс, показывающий потомков)
  document.addEventListener('focus', function (event) {
    // Если событие всплыло от одной из ссылок гл. меню
    if (findLinkClassName.test(event.target.className)) {
      // Добавим классы, показывающие списки вложенных уровней, на всех родителей
      event.target.parents('.main-nav__item').forEach(function (item) {
        item.classList.add(linkClassNameShowChild);
      });
    }
  }, true);
  // Слежение за всплывшим событием blur (нужно убрать класс, показывающий потомков)
  document.addEventListener('blur', function (event) {
    // Если событие всплыло от одной из ссылок гл. меню
    if (findLinkClassName.test(event.target.className)) {
      // Уберем все классы, показывающие списки 2+ уровней
      // event.target.closest('.main-nav').querySelectorAll('.'+linkClassNameShowChild).forEach(function(item){
      document.querySelectorAll('.' + linkClassNameShowChild).forEach(function (item) {
        item.classList.remove(linkClassNameShowChild);
      });
    }
  }, true);

  // Добавление метода .parents()
  Element.prototype.parents = function (selector) {
    const elements = [];
    let elem = this;
    let ishaveselector = selector !== undefined;
    while ((elem = elem.parentElement) !== null) {
      if (elem.nodeType !== Node.ELEMENT_NODE) {
        continue;
      }
      if (!ishaveselector || elem.matches(selector)) {
        elements.push(elem);
      }
    }
    return elements;
  };

  // Добавление метода .closest() (полифил, собственно)
  // (function(e){
  //  e.closest = e.closest || function(css){
  //    var node = this;

  //    while (node) {
  //       if (node.matches(css)) return node;
  //       else node = node.parentElement;
  //    }
  //    return null;
  //  }
  // })(Element.prototype);
})();
/*(function (){
  let new_scroll_position = 0;
  let last_scroll_position;
  const header = document.getElementById('header');
  const scrollHandler = function(e) {
    last_scroll_position = window.scrollY;

    // Scrolling down
    if (new_scroll_position < last_scroll_position && last_scroll_position > 80) {
      // header.removeClass('slideDown').addClass('slideUp');
      header.classList.remove('page-header--slideDown');
      header.classList.add('page-header--slideUp');

    // Scrolling up
    } else if (new_scroll_position > last_scroll_position) {
      // header.removeClass('slideUp').addClass('slideDown');
      header.classList.remove('page-header--slideUp');
      header.classList.add('page-header--slideDown');
    }

    new_scroll_position = last_scroll_position;
  };

  window.addEventListener('scroll', scrollHandler, { passive: true });
})()*/
(function () {
  const HIDE_HEADER_SCROLL = 120;
  let new_scroll_position = 0;
  let last_scroll_position;
  const header = document.getElementById('header');
  if (!header) return;
  function clearHeaderClasses() {
    header.classList.remove('page-header--slideUp', 'page-header--slideDown');
  }
  function scrollHandler() {
    last_scroll_position = window.scrollY;
    if (last_scroll_position === 0) {
      clearHeaderClasses();
    } else if (new_scroll_position < last_scroll_position && last_scroll_position > HIDE_HEADER_SCROLL) {
      header.classList.remove('page-header--slideDown');
      header.classList.add('page-header--slideUp');
    } else if (new_scroll_position > last_scroll_position) {
      header.classList.remove('page-header--slideUp');
      header.classList.add('page-header--slideDown');
    }
    new_scroll_position = last_scroll_position;
  }

  // requestAnimationFrame-throttle
  let ticking = false;
  window.addEventListener('scroll', function () {
    if (!ticking) {
      window.requestAnimationFrame(function () {
        scrollHandler();
        ticking = false;
      });
      ticking = true;
    }
  }, {
    passive: true
  });
})();
document.addEventListener('DOMContentLoaded', function () {
  (function () {
    // указатель на текущую страницу
    var pagination = document.querySelector('.pagination');
    var btns = document.querySelectorAll('.pagination__item');
    Array.prototype.forEach.call(btns, function (item) {
      var link = item.children[0];
      if (item.classList.contains('active')) {
        link.setAttribute('aria-current', 'page');
      } else {
        link.removeAttribute('aria-current');
      }
    });
  })();
});
document.addEventListener('DOMContentLoaded', function () {
  var links = document.querySelectorAll('[href^="#"][data-scroll-link]');
  for (var i = 0; i < links.length; i++) {
    links[i].addEventListener('click', function (e) {
      var hash = this.href.replace(/[^#]*(.*)/, '$1');
      if (hash && hash !== '#') {
        e.preventDefault();
        var scroll = window.pageYOffset;
        var targetTop = getOffsetRect(document.querySelector(hash)).top - 136; // С поправкой в 10px
        var scrollDiff = (scroll - targetTop) * -1;
        animate({
          duration: 500,
          timing: function (timeFraction) {
            return Math.pow(timeFraction, 4); // https://learn.javascript.ru/js-animation
          },
          draw: function (progress) {
            var scrollNow = scroll + progress * scrollDiff;
            window.scrollTo(0, scrollNow);
          }
        });
      }
    }, false);
  }
  function animate(_ref) {
    var timing = _ref.timing,
      draw = _ref.draw,
      duration = _ref.duration;
    var start = performance.now();
    requestAnimationFrame(function animate(time) {
      var timeFraction = (time - start) / duration;
      if (timeFraction > 1) timeFraction = 1;
      var progress = timing(timeFraction);
      draw(progress);
      if (timeFraction < 1) {
        requestAnimationFrame(animate);
      }
    });
  }
  function getOffsetRect(elem) {
    var box = elem.getBoundingClientRect();
    var body = document.body;
    var docElem = document.documentElement;
    var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
    var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
    var clientTop = docElem.clientTop || body.clientTop || 0;
    var clientLeft = docElem.clientLeft || body.clientLeft || 0;
    var top = box.top + scrollTop - clientTop;
    var left = box.left + scrollLeft - clientLeft;
    return {
      top: Math.round(top),
      left: Math.round(left)
    };
  }
});
svg4everybody();
(function () {
  if (document.getElementById('toTop')) {
    document.getElementById('toTop').addEventListener('click', function (e) {
      e.preventDefault();
      var scroll = window.pageYOffset;
      var targetTop = 0;
      var scrollDiff = (scroll - targetTop) * -1;
      animate({
        duration: 500,
        timing: function (timeFraction) {
          return Math.pow(timeFraction, 4); // https://learn.javascript.ru/js-animation
        },
        draw: function (progress) {
          var scrollNow = scroll + progress * scrollDiff;
          window.scrollTo(0, scrollNow);
        }
      });
    }, false);
    window.addEventListener('scroll', visibilityToggle);
    visibilityToggle();
  }
  function visibilityToggle() {
    if (window.pageYOffset >= 500) {
      document.getElementById('toTop').classList.add('to-top--visible');
    } else {
      document.getElementById('toTop').classList.remove('to-top--visible');
    }
  }
  function animate(_ref) {
    var timing = _ref.timing,
      draw = _ref.draw,
      duration = _ref.duration;
    var start = performance.now();
    requestAnimationFrame(function animate(time) {
      var timeFraction = (time - start) / duration;
      if (timeFraction > 1) timeFraction = 1;
      var progress = timing(timeFraction);
      draw(progress);
      if (timeFraction < 1) {
        requestAnimationFrame(animate);
      }
    });
  }
})();
(function () {
  const hero = new Swiper('.hero__slider', {
    speed: 400,
    spaceBetween: 0,
    slidesPerView: 1,
    loop: true,
    // autoplay: {
    //   delay: 4000,
    // },
    navigation: {
      nextEl: '.hero__btn-next',
      prevEl: '.hero__btn-prev'
    },
    pagination: {
      el: '.hero__pagination',
      type: 'fraction'
    }
  });
})();
document.addEventListener('DOMContentLoaded', function () {
  /**
  * Theme toggler accessibility enhancer
  *
  * - НЕ переключает классы и темы!
  * - Обеспечивает корректные aria-label и aria-pressed для кнопки.
  * - Работает независимо от основного скрипта темизации.
  * - Использовать совместно с основным скриптом, который управляет классами.
  */

  const block = 'theme-toggler';
  const btn = document.querySelector(`.${block}`);
  if (!btn) return;

  // Утилита: Получить текущую тему по модификатору
  function getTheme() {
    if (btn.classList.contains(`${block}--dark`)) return 'dark';
    if (btn.classList.contains(`${block}--light`)) return 'light';
    return 'light'; // дефолт
  }

  // Установить aria-атрибуты
  function setA11yAttrs(theme) {
    btn.setAttribute('aria-pressed', theme === 'dark' ? 'true' : 'false');
    btn.setAttribute('aria-label', theme === 'dark' ? 'Переключити на світлу тему' : 'Переключити на темну тему');
  }

  // Обновлять aria при каждом изменении классов (например, после переключения темы)
  const observer = new MutationObserver(() => setA11yAttrs(getTheme()));
  observer.observe(btn, {
    attributes: true,
    attributeFilter: ['class']
  });

  // Инициализация на старте
  setA11yAttrs(getTheme());

  // Доступность: space/enter
  btn.addEventListener('keydown', e => {
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      btn.click();
    }
  });
});
document.addEventListener('DOMContentLoaded', function () {
  const tariffs = new Swiper('.tariffs__slider-content', {
    speed: 400,
    spaceBetween: 0,
    slidesPerView: 'auto',
    navigation: {
      nextEl: '.tariffs__btn-next',
      prevEl: '.tariffs__btn-prev'
    },
    pagination: {
      el: '.tariffs__pagination',
      type: 'fraction'
    }
  });
});
(function () {
  const cardsAll = document.querySelectorAll('.tariff-card');
  if (!cardsAll) {
    return;
  }
  for (let i = 0; i < cardsAll.length; i++) {
    const card = cardsAll[i];
    const moreBtn = card.querySelector('.tariff-card__more-btn');
    const returnBtn = card.querySelector('.tariff-card__back-btn');
    const flipElem = card.querySelector('.tariff-card__inner');
    const moreBtnClickpriceHandler = function (e) {
      flipElem.classList.toggle('tariff-card__inner--backfaced');
    };
    if (moreBtn && returnBtn) {
      moreBtn.addEventListener('click', moreBtnClickpriceHandler);
      returnBtn.addEventListener('click', moreBtnClickpriceHandler);
    }
  }
})();
document.addEventListener('DOMContentLoaded', function () {
  const spOffers = new Swiper('.sp-offers__slider', {
    speed: 400,
    spaceBetween: 16,
    slidesPerView: 'auto',
    initialSlide: 1,
    // autoplay: {
    //   delay: 4000,
    // },
    navigation: {
      nextEl: '.sp-offers__btn-next',
      prevEl: '.sp-offers__btn-prev'
    },
    pagination: {
      el: '.sp-offers__pagination',
      type: 'fraction'
    },
    breakpoints: {
      768: {
        spaceBetween: 24
      }
    }
  });
});

document.addEventListener('DOMContentLoaded', function () {
  const news = new Swiper('.news-slider__container', {
    speed: 400,
    spaceBetween: 16,
    slidesPerView: 'auto',
    //initialSlide: 1,
    // autoplay: {
    //   delay: 4000,
    // },
    navigation: {
      nextEl: '.news-slider__btn-next',
      prevEl: '.news-slider__btn-prev'
    },
    pagination: {
      el: '.news-slider__pagination',
      type: 'fraction'
    },
    breakpoints: {
      768: {
        spaceBetween: 24
      }
    }
  });
});
document.addEventListener('DOMContentLoaded', function () {
  const slideElements = document.querySelectorAll('.reviews-slider__content .swiper-slide');
  const slidesCount = slideElements.length;
  const initialSlide = Math.floor(slidesCount / 2);
  const review = new Swiper('.reviews-slider__content', {
    speed: 400,
    spaceBetween: 16,
    slidesPerView: 'auto',
    centeredSlides: true,
    //initialSlide: initialSlide,
    loop: true,
    // autoplay: {
    //   delay: 4000,
    // },
    navigation: {
      nextEl: '.reviews-slider__btn-next',
      prevEl: '.reviews-slider__btn-prev'
    },
    pagination: {
      el: '.reviews-slider__pagination',
      type: 'fraction'
    },
    breakpoints: {
      768: {
        spaceBetween: 24
      }
    }
  });
});
(function () {
  // CSS-класс .visually-hidden должен быть в CSS
  const VISUALLY_HIDDEN_CLASS = 'visually-hidden';
  document.querySelectorAll('select.choices, input.choices').forEach(function (element) {
    // Надёжно получаем текст имени поля
    const ariaLabel = element.getAttribute('aria-label') || element.getAttribute('placeholder') || 'Select a value';

    // Убедимся, что у select есть id (нужен для связывания label[for])
    if (!element.id) {
      element.id = 'choices-select-' + Math.random().toString(36).slice(2, 9);
    }

    // Ищем реальный <label for="..."> (если есть)
    let labelEl = document.querySelector('label[for="' + CSS.escape(element.id) + '"]');

    // Если label отсутствует — создаём скрытый, но корректный label с текстом
    if (!labelEl) {
      labelEl = document.createElement('label');
      labelEl.className = 'visually-hidden';
      labelEl.id = 'choices-label-' + Math.random().toString(36).slice(2, 9);
      labelEl.setAttribute('for', element.id);
      labelEl.textContent = ariaLabel;
      labelEl.dataset.choicesLabel = 'true'; // пометка
      element.parentNode.insertBefore(labelEl, element);
    } else {
      // если label найден — убедимся, что у него есть id и текст
      if (!labelEl.id) labelEl.id = 'choices-label-' + Math.random().toString(36).slice(2, 9);
      if (!labelEl.textContent || !labelEl.textContent.trim()) labelEl.textContent = ariaLabel;
      labelEl.removeAttribute('aria-hidden');
    }

    // Формируем опции для Choices и передаём labelId (официальная опция)
    const options = {
      placeholderValue: element.getAttribute('placeholder') || '',
      shouldSort: false,
      itemSelectText: '',
      searchEnabled: element.tagName === 'SELECT',
      removeItemButton: element.tagName === 'INPUT',
      labelId: labelEl.id
    };

    // допускаем доп. опции из data-атрибутов
    if (element.dataset && element.dataset.choicesOptions) {
      try {
        Object.assign(options, JSON.parse(element.dataset.choicesOptions));
      } catch (e) {/* ignore */}
    }

    // Инициализируем Choices
    new Choices(element, options);
  });
})();
document.addEventListener('DOMContentLoaded', function () {
  const header = document.getElementById('header');
  const mobNavMenu = document.getElementById('mobNav');
  const burger = document.getElementById('menuToggler');
  if (!mobNavMenu || !burger) return;
  function getVisibleHeaderHeight() {
    if (header.classList.contains('page-header--slideUp')) {
      // Возьмите только ту часть, которая остаётся видимой
      const mainPart = header.querySelector('.page-header__main');
      return mainPart ? mainPart.offsetHeight : header.offsetHeight;
    } else {
      // Когда header полностью видим
      return header.offsetHeight;
    }
  }
  function updateMobNavTop() {
    const viewportWidth = window.innerWidth;
    //const topMenuOffset = 10;
    // Получаем значение CSS-переменной
    const topMenuOffset = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mob-menu-offset'), 10) || 0;
    if (viewportWidth >= 768 && viewportWidth < 1280) {
      if (header.classList.contains('page-header--slideUp')) {
        mobNavMenu.style.top = getVisibleHeaderHeight() + topMenuOffset + 'px';
      } else {
        mobNavMenu.style.top = getVisibleHeaderHeight() + topMenuOffset + 'px';
      }
    } else {
      mobNavMenu.style.top = '';
    }
  }
  mobNavMenu.addEventListener('show.bs.offcanvas', event => {
    burger.classList.add('burger--close');
    updateMobNavTop();
  });
  mobNavMenu.addEventListener('hide.bs.offcanvas', event => {
    burger.classList.remove('burger--close');
  });

  // При изменении размера окна, если меню открыто — обновляем top
  window.addEventListener('resize', function () {
    // Bootstrap offcanvas добавляет класс "show" при открытии
    if (mobNavMenu.classList.contains('show')) {
      updateMobNavTop();
    }
  });
});
document.addEventListener('DOMContentLoaded', function () {
  const faqSlider = new Swiper('.faq-slider__container', {
    speed: 400,
    spaceBetween: 24,
    slidesPerView: 1,
    // autoplay: {
    //   delay: 4000,
    // },
    navigation: {
      nextEl: '.faq-slider__btn-next',
      prevEl: '.faq-slider__btn-prev'
    },
    pagination: {
      el: '.faq-slider__pagination',
      type: 'fraction'
    },
    breakpoints: {
      768: {
        //spaceBetween: 24,
        slidesPerView: 2
      },
      1280: {
        slidesPerView: 3
      }
    }
  });
});
/*document.addEventListener('DOMContentLoaded', function () {
  const spOfferGrid = new Swiper('.sp-offers-grid-slider__container', {
    speed: 400,
    spaceBetween: 24,
    slidesPerView: 1,
    slidesPerGroup: 1,
    watchOverflow: true,
    observer: true,
    observeParents: true,
    grid: {
      rows: 4,
      fill: 'row',
    },
    navigation: {
      nextEl: '.sp-offers-grid-slider__btn-next',
      prevEl: '.sp-offers-grid-slider__btn-prev',
    },
    pagination: {
      el: '.sp-offers-grid-slider__pagination',
      type: 'fraction',
    },
    breakpoints: {
      768: {
        slidesPerView: 2,
        slidesPerGroup: 2,
        grid: {
          rows: 2,
          //fill: 'column'
        },
      }
    },

    // on: {
    //   afterInit(sw) { sw.update(); },
    //   resize(sw) { sw.update(); },
    //   breakpoint(sw) { sw.update(); },
    // }
  });
});

*/
/*
document.addEventListener('DOMContentLoaded', function () {
  const sliderSelector = '.sp-offers-grid-slider__container';
  const wrapper = document.querySelector(`${sliderSelector} .swiper-wrapper`);

  // 1) Источник истины: сохраняем исходные слайды и признак "новый"
  const allSlides = Array.from(wrapper.children).map((el) => ({
    html: el.outerHTML,
    isNew: el.dataset.new === 'true'
  }));

  // 2) Инициализация Swiper (твой исходный конфиг)
  const spOfferGrid = new Swiper(sliderSelector, {
    speed: 400,
    spaceBetween: 24,
    slidesPerView: 1,
    slidesPerGroup: 1,
    watchOverflow: true,
    observer: true,
    observeParents: true,
    grid: {
      rows: 4,
      fill: 'row',
    },
    navigation: {
      nextEl: '.sp-offers-grid-slider__btn-next',
      prevEl: '.sp-offers-grid-slider__btn-prev',
    },
    pagination: {
      el: '.sp-offers-grid-slider__pagination',
      type: 'fraction',
    },
    breakpoints: {
      768: {
        slidesPerView: 2,
        slidesPerGroup: 2,
        grid: {
          rows: 2,
          // fill: 'column'
        },
      }
    },
  });

  // 3) Утилиты для пересборки
  function rebuildSlides(list) {
    spOfferGrid.removeAllSlides();
    // appendSlide принимает массив строк с HTML или элементы
    spOfferGrid.appendSlide(list.map(item => item.html));
    spOfferGrid.update();
    spOfferGrid.slideTo(0);
  }

  function applyFilter(value) {
    let filtered;
    switch (value) {
      case 'new':
        filtered = allSlides.filter(s => s.isNew);
        break;
      case 'existing':
        // "Все кроме новых"
        filtered = allSlides.filter(s => !s.isNew);
        break;
      case 'all':
      default:
        filtered = allSlides;
        break;
    }
    rebuildSlides(filtered);
  }

  // 4) Обработчики радиокнопок
  const inputs = document.querySelectorAll('.field-filter .field-filter__input[name="offers"]');
  inputs.forEach(input => {
    input.addEventListener('change', (e) => {
      applyFilter(e.target.value);
    });
  });

  // На всякий: если по умолчанию выбран не "all", применим стартовый фильтр
  const checked = document.querySelector('.field-filter .field-filter__input[name="offers"]:checked');
  if (checked && checked.value !== 'all') {
    applyFilter(checked.value);
  }
});*/

document.addEventListener('DOMContentLoaded', () => {
  const sliderSelector = '.sp-offers-grid-slider__container';
  const wrapper = document.querySelector(`${sliderSelector} .swiper-wrapper`);
  if (!sliderSelector || !wrapper) return;

  // Сохраняем исходные слайды и признак "новый"
  const allSlides = Array.from(wrapper.children).map(el => ({
    html: el.outerHTML,
    isNew: el.dataset.new === 'true'
  }));
  let spOfferGrid;
  const swiperConfig = {
    speed: 400,
    spaceBetween: 24,
    slidesPerView: 1,
    slidesPerGroup: 1,
    watchOverflow: true,
    observer: true,
    observeParents: true,
    grid: {
      rows: 4,
      fill: 'row'
    },
    navigation: {
      nextEl: '.sp-offers-grid-slider__btn-next',
      prevEl: '.sp-offers-grid-slider__btn-prev'
    },
    pagination: {
      el: '.sp-offers-grid-slider__pagination',
      type: 'fraction'
    },
    breakpoints: {
      768: {
        slidesPerView: 2,
        slidesPerGroup: 2,
        grid: {
          rows: 2
        }
      }
    }
  };
  function initSwiper() {
    spOfferGrid = new Swiper(sliderSelector, swiperConfig);
  }
  function mountSlides(list) {
    // Вставляем нужные слайды (HTML уже содержит классы swiper-slide)
    wrapper.innerHTML = list.map(s => s.html).join('');
  }
  function rebuild(list) {
    // Чисто уничтожаем инстанс, затем пересоздаём
    if (spOfferGrid) {
      spOfferGrid.destroy(true, true);
      spOfferGrid = null;
    }
    mountSlides(list);
    // Форсируем reflow, чтобы браузер применил DOM перед инициализацией
    // (иногда помогает против редких гонок расчёта высоты)
    // eslint-disable-next-line no-unused-expressions
    wrapper.offsetHeight;
    initSwiper();
  }
  function applyFilter(value) {
    let filtered = allSlides;
    if (value === 'new') filtered = allSlides.filter(s => s.isNew);else if (value === 'existing') filtered = allSlides.filter(s => !s.isNew);
    rebuild(filtered);
  }

  // Инициализация
  initSwiper();

  // Обработчики фильтров
  document.querySelectorAll('.field-filter .field-filter__input[name="offers"]').forEach(input => {
    input.addEventListener('change', e => applyFilter(e.target.value));
  });

  // Если дефолт выбран не "all" — применим сразу
  const checked = document.querySelector('.field-filter .field-filter__input[name="offers"]:checked');
  if (checked && checked.value !== 'all') {
    applyFilter(checked.value);
  }
});
(function () {
  const prodAll = document.querySelectorAll('.product-card');
  if (!prodAll) {
    return;
  }
  for (let i = 0; i < prodAll.length; i++) {
    const card = prodAll[i];
    const moreBtn = card.querySelector('.product-card__more-btn');
    const returnBtn = card.querySelector('.product-card__back-btn');
    const flipElem = card.querySelector('.product-card__inner');
    const moreBtnClickHandler = function (e) {
      flipElem.classList.toggle('product-card__inner--backfaced');
    };
    if (moreBtn && returnBtn) {
      moreBtn.addEventListener('click', moreBtnClickHandler);
      returnBtn.addEventListener('click', moreBtnClickHandler);
    }
  }
})();
document.addEventListener('DOMContentLoaded', function () {
  const prodThumb = new Swiper(".product__slider-thumb", {
    spaceBetween: 8,
    slidesPerView: 'auto',
    freeMode: true,
    watchSlidesProgress: true
  });
  const prodMain = new Swiper(".product__slider-main", {
    spaceBetween: 24,
    slidesPerView: 1,
    grabCursor: true,
    navigation: {
      nextEl: ".product__btn-next",
      prevEl: ".product__btn-prev"
    },
    thumbs: {
      swiper: prodThumb
    }
  });
});
(function () {
  const tvTariffAll = document.querySelectorAll('.tv-card');
  if (!tvTariffAll) {
    return;
  }
  for (let i = 0; i < tvTariffAll.length; i++) {
    const card = tvTariffAll[i];
    const moreBtn = card.querySelector('.tv-card__more-btn');
    const returnBtn = card.querySelector('.tv-card__back-btn');
    const flipElem = card.querySelector('.tv-card__inner');
    const moreBtnClickHandler = function (e) {
      flipElem.classList.toggle('tv-card__inner--backfaced');
    };
    if (moreBtn && returnBtn) {
      moreBtn.addEventListener('click', moreBtnClickHandler);
      returnBtn.addEventListener('click', moreBtnClickHandler);
    }
  }
})();
document.addEventListener('DOMContentLoaded', () => {
  const roots = document.querySelectorAll('.biz-tariffs-slider');
  if (!roots.length) return;
  roots.forEach(root => {
    const el = root.querySelector('.tariffs__slider-content');
    const nextBtn = root.querySelector('.tariffs__btn-next');
    const prevBtn = root.querySelector('.tariffs__btn-prev');
    const fractionEl = root.querySelector('.tariffs__pagination');
    if (!el) return;

    // Сносим прежний инстанс, если вдруг был
    if (el.swiper) {
      try {
        el.swiper.destroy(true, true);
      } catch (e) {}
    }
    const swiper = new Swiper(el, {
      slidesPerView: 'auto',
      spaceBetween: 0,
      speed: 400,
      // Листаем по ОДНОМУ слайду
      slidesPerGroup: 1,
      freeMode: false,
      centeredSlides: false,
      observer: true,
      observeParents: true,
      watchOverflow: true
    });

    // Помощники для fraction
    const getCurrent = () => (typeof swiper.realIndex === 'number' ? swiper.realIndex : swiper.activeIndex) + 1;
    const getTotal = () => {
      const slides = Array.from(swiper.slides || []);
      // если когда-то включите loop — не считаем дубликаты
      const total = slides.filter(s => !s.classList.contains('swiper-slide-duplicate')).length;
      return total || slides.length || 0;
    };
    const updateUI = () => {
      // fraction по слайдам
      if (fractionEl) {
        fractionEl.textContent = `${getCurrent()} / ${getTotal()}`;
      }
      const lock = getTotal() <= 1;
      // классы как у встроенной Navigation
      prevBtn?.classList.toggle('swiper-button-disabled', swiper.isBeginning || lock);
      prevBtn?.classList.toggle('swiper-button-lock', lock);
      nextBtn?.classList.toggle('swiper-button-disabled', swiper.isEnd || lock);
      nextBtn?.classList.toggle('swiper-button-lock', lock);
    };

    // Свои клики, отрезаем возможные глобальные обработчики
    nextBtn?.addEventListener('click', e => {
      e.preventDefault();
      e.stopImmediatePropagation();
      swiper.slideNext();
    });
    prevBtn?.addEventListener('click', e => {
      e.preventDefault();
      e.stopImmediatePropagation();
      swiper.slidePrev();
    });

    // Обновления UI
    updateUI();
    swiper.on('slideChange', updateUI);
    swiper.on('transitionEnd', updateUI);
    swiper.on('slidesLengthChange', updateUI);
    swiper.on('resize', () => {
      swiper.update();
      updateUI();
    });
  });
});
document.documentElement.className = document.documentElement.className.replace('no-js', 'js');

// Добавление 1vh (использование: height: 100vh; height: calc(var(--vh, 1vh) * 100);) для фикса 100vh на мобилках
let vh = window.innerHeight * 0.01;
document.documentElement.style.setProperty('--vh', `${vh}px`);
window.addEventListener('resize', () => {
  let vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh', `${vh}px`);
});
(function () {
  function canUseWebp() {
    let elem = document.createElement('canvas');
    return !!(elem.getContext && elem.getContext('2d')) && elem.toDataURL('image/webp').indexOf('data:image/webp') === 0;
  }
  function loadBackgroundImage(element, fastScroll) {
    let isWebpSupported = canUseWebp();
    let bgImage = isWebpSupported ? element.getAttribute('data-bg-webp') : element.getAttribute('data-bg');
    if (bgImage) {
      element.style.backgroundImage = `url(${bgImage})`;
      element.removeAttribute('data-bg');
      element.removeAttribute('data-bg-webp');

      // Читаем скорость из атрибута (по умолчанию 1 сек)
      let speed = parseFloat(element.getAttribute('data-bg-speed')) || 1;
      if (fastScroll) speed *= 0.5; // Ускоряем при быстрой прокрутке

      // Плавное появление
      requestAnimationFrame(() => {
        element.style.transition = `opacity ${speed}s ease-out`;
        element.style.opacity = 1;
      });
    }
  }
  function observeLazyLoad() {
    let lazyElements = document.querySelectorAll('[data-bg], [data-bg-webp]');
    lazyElements.forEach(el => {
      el.style.opacity = '0';
      el.style.willChange = 'opacity';
    });
    let lastTime = performance.now();
    let lastScrollY = window.scrollY;
    if ('IntersectionObserver' in window) {
      let observer = new IntersectionObserver((entries, obs) => {
        let now = performance.now();
        let deltaY = Math.abs(window.scrollY - lastScrollY);
        let deltaT = now - lastTime;
        let speed = deltaY / (deltaT || 1);
        let fastScroll = speed > 1;
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            loadBackgroundImage(entry.target, fastScroll);
            obs.unobserve(entry.target);
          }
        });
        lastTime = now;
        lastScrollY = window.scrollY;
      }, {
        rootMargin: '0px',
        threshold: 0.1
      });
      lazyElements.forEach(el => observer.observe(el));
    } else {
      lazyElements.forEach(el => loadBackgroundImage(el, false));
    }
  }
  document.addEventListener('DOMContentLoaded', observeLazyLoad);

  /* Разметка:
    // Фон появится за 0.5 секунды
    <div data-bg="/images/image2.jpg" data-bg-webp="/images/image2.webp" data-bg-speed="0.5"></div>
      // Фон появится дефолтно за 1 сек
    <div data-bg="/img/image.jpg" data-bg-webp="/img/image.webp"></div>
  */
})();
(function () {
  const html = document.documentElement;
  const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
  const btnId = 'toggle-theme';
  const STORAGE_KEY = 'site-theme'; // ключ для хранения выбранной темы

  /**
   * Получить сохранённую тему из localStorage
   * @returns {'light'|'dark'|null}
   */
  function getSavedTheme() {
    try {
      const value = localStorage.getItem(STORAGE_KEY);
      if (value === 'light' || value === 'dark') return value;
    } catch {}
    return null;
  }

  /**
   * Сохранить выбранную тему в localStorage
   * @param {'light'|'dark'} theme
   */
  function saveTheme(theme) {
    try {
      localStorage.setItem(STORAGE_KEY, theme);
    } catch {}
  }

  /**
   * Получить текущую системную тему
   */
  function getSystemTheme() {
    return prefersDark.matches ? 'dark' : 'light';
  }

  /**
   * Отключить анимацию при первой установке темы (чтобы не было моргания)
   */
  function disableTransitionTemporarily() {
    html.classList.add('no-transition');
    void html.offsetWidth;
    setTimeout(() => {
      html.classList.remove('no-transition');
    }, 10);
  }

  /**
   * Включить плавный переход (используется при ручном переключении)
   */
  function enableThemeTransition() {
    html.classList.add('theme-transition');
    setTimeout(() => {
      html.classList.remove('theme-transition');
    }, 350); // время должно совпадать с CSS
  }

  /**
   * Применить классы для элементов с data-theme-light/data-theme-dark
   * Работает даже если указан только один из вариантов!
   */
  function applyThemeClasses(theme) {
    document.querySelectorAll('[data-theme-light], [data-theme-dark]').forEach(el => {
      const lightClass = el.getAttribute('data-theme-light');
      const darkClass = el.getAttribute('data-theme-dark');
      if (lightClass) el.classList.toggle(lightClass, theme === 'light');
      if (darkClass) el.classList.toggle(darkClass, theme === 'dark');
    });
  }

  /**
   * Применить стиль для Google Maps через data-атрибуты на #map
   */
  // function applyMapStyle(theme) {
  //   const mapEl = document.getElementById('map');
  //   if (!mapEl || !window.myMap || !window.google) return;
  //   const styleUrl = mapEl.getAttribute(`data-map-${theme}`);
  //   if (!styleUrl) return;
  //   fetch(styleUrl)
  //     .then(r => {
  //       if (!r.ok) throw new Error('Style JSON not found');
  //       return r.json();
  //     })
  //     .then(styleJson => {
  //       window.myMap.setOptions({ styles: styleJson });
  //     })
  //     .catch(() => {});
  // }

  function applyMapStyle(theme) {
    const mapEl = document.getElementById('map');
    if (!mapEl || !window.myMap) return;
    const mapId = mapEl.getAttribute(`data-map-${theme}`);
    if (!mapId) return;
    window.myMap.setOptions({
      mapId
    });
    //window.location.reload(); // принудительная перезарузка
  }

  /**
   * Применить тему (основная функция)
   * @param {'light'|'dark'} theme
   * @param {boolean} animate
   */
  function applyTheme(theme, animate = false) {
    if (animate) enableThemeTransition();
    html.setAttribute('data-theme', theme);
    applyThemeClasses(theme);
    applyMapStyle(theme);
  }

  /**
   * Переключение темы по кнопке
   */
  function toggleTheme() {
    const current = html.getAttribute('data-theme') || getSystemTheme();
    const next = current === 'dark' ? 'light' : 'dark';
    saveTheme(next); // сохраняем выбор пользователя!
    applyTheme(next, true);
  }

  /**
   * Инициализация
   */
  window.addEventListener('DOMContentLoaded', () => {
    disableTransitionTemporarily();

    // 1. Смотрим, есть ли сохранённая тема
    const savedTheme = getSavedTheme();
    if (savedTheme) {
      applyTheme(savedTheme, false);
    } else {
      // 2. Если нет, берём system theme
      applyTheme(getSystemTheme(), false);
    }
    const btn = document.getElementById(btnId);
    if (btn) btn.addEventListener('click', toggleTheme);

    // Автоматическая смена темы при изменении системной настройки (только если пользователь не выбрал вручную)
    prefersDark.addEventListener('change', e => {
      if (!getSavedTheme()) {
        applyTheme(e.matches ? 'dark' : 'light', true);
      }
    });
  });
})();
(function () {
  const popoverTriggerList = document.querySelectorAll('[data-bs-toggle="popover"]');
  const popoverList = [...popoverTriggerList].map(popoverTriggerEl => new bootstrap.Popover(popoverTriggerEl, {
    container: 'body',
    popperConfig: function (defaultConfig) {
      return {
        ...defaultConfig,
        modifiers: [...defaultConfig.modifiers, {
          name: 'offset',
          options: {
            offset: [8, 8] // Сдвиг окна относительно элемента-триггера [x, y]
          }
        }]
      };
    }
  }));
})();
(function () {
  const phoneElems = document.getElementsByClassName('phone-mask');
  Array.prototype.forEach.call(phoneElems, function (item) {
    const phoneMask = IMask(item, {
      mask: '+{38} (\\000) 000 00 00',
      lazy: true // make placeholder always visible
    });
  });
})();